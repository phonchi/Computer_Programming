{"title":"Other collections - Dictionaries and Sets","markdown":{"yaml":{"title":"Other collections - Dictionaries and Sets","author":"phonchi","date":"03/17/2023","format":{"html":{"toc":true,"toc-depth":4,"code-line-numbers":true,"code-fold":true,"code-tools":true}}},"headingText":"Dictionaries","containsRefs":false,"markdown":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/05_Dictionaries_sets.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/05_Dictionaries_sets.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n\nWe’ve discussed three built-in sequence collections — `strings`, `lists` and `tuples`. Now, we consider the built-in non-sequence collections — `dictionaries` and `sets`. A `dictionary` is an unordered collection which stores ***key–value*** pairs that map immutable keys to values, just as a conventional dictionary maps words to definitions. A `set` is an unordered collection of unique immutable elements.\n\nLike a `list`, a `dictionary` is a mutable collection of many values, but more general. In a `list`, the index positions have to be integers; in a `dictionary`, the indices can be any immutable data type. You can think of a dictionary as a mapping between a set of indices (which are called ***keys***) and a set of ***values***. Each key maps to a value. The association of a key and a value is called a ***key-value*** pair or sometimes an ***item***.\n\nA `dictionary`’s keys must be immutable (such as `strings`, `integers` or `tuples`) and unique (that is, no duplicates). However, multiple keys can have the same value.\n\n<center><img src=\"https://pynative.com/wp-content/uploads/2021/02/dictionaries-in-python.jpg\"></center>\n<div align=\"center\"> source: https://pynative.com/python-dictionaries/ </div>\n\n> It is noted that as of Python 3.7, dictionary items maintain the order in which they are inserted into the dictionary. However, `dictionaries` are considered unordered collections and do not write code that depends on the order of the key–value pairs. \n\nAs an example, we’ll build a dictionary that maps from subjects to grades, so the keys are `string` while the values are `integers`. The function `dict` creates a new dictionary with no items. \n\nTo add/update items to the dictionary, you can again use subscript operator (square brackets):\n\nYou can create a `dictionary` that contains multiple items by enclosing in curly braces, `{}`, a comma-separated list of key–value pairs, each of the form `key:value`.\n\nYou can store them using separate `lists` for subjects and scores, but the following update and maintenance will become tedious:\n\n```python\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nscore = [85, 80, 90, 95]\n````\n\nYou can now use the keys to look up the corresponding values:\n\nYou can obtain the number of items using `len()`\n\n> Note that you can't access items in them using integer indexes like `grade[0]` because it is unordered collections. (Consider the case when you use 4, 2, 1, 0 as the keys). Therefore, you can't use slice syntax for dictionaries. \n\nTrying to access a key that does not exist in a `dictionary` will result in a `KeyError` error message, much like a `list’s` “out-of-range” `IndexError` error message.\n\nTo add or delete an entry, it is similar to list\n\nYou can delete a key–value pair from a dictionary with the `del` statement:\n\n### The `keys()`, `values()`, and `items()` Methods\n\nThere are three `dictionary` methods that will return `list`-like values of the `dictionary`’s keys, values, or both keys and values: `keys()`, `values()`, and `items()`. The values returned by these methods are not true lists, but these data types (`dict_keys`, `dict_values`, and `dict_items`, respectively) can be used in `for` loops (Just like `range` object)!\n\nIf you want a true list from one of these methods, pass its list-like return value to the `list()` function\n\nHere, a `for` loop iterates over each of the values in the `grade` dictionary. A `for` loop can also iterate over the keys:\n\n> Note that by default, it will traverse over the keys!\n\nDictionaries have a method called `items()` that returns a list of tuples, where each tuple is a key-value pair:\n\nCombining `items()`, multiple assignment, and `for`, you can see a nice code pattern for traversing the keys and values of a dictionary in a single loop:\n\n#### Checking Whether a Key or Value Exists in a Dictionary\n\nRecall from the previous chapter that the `in` and `not in` operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary\n\n> Again, it will check keys by default. Therefore, in the previous example, `'calculus' in grade` is essentially a shorter version of writing `'calculus' in grade.keys()`. This is always the case: if you ever want to check whether a value is (or isn’t) a key in the `dictionary`, you can simply use the `in` (or `not in`) keyword with the `dictionary` itself.\n\n#### Retrieve value uisng  `get()` Method\n\nIt’s tedious to check whether a key exists in a `dictionary` before accessing that key’s value. Fortunately, dictionaries have a `get()` method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\nBecause there is no 'eggs' key in the `picnicItems` dictionary, the default value 0 is returned by the `get()` method. Without using `get()`, the code would have caused a `KeyError` message\n\n#### Update value using `setdefault()` Method\n\nYou’ll often have to set a value in a `dictionary` for a certain key only if that key does not already have a value. The code looks something like this:\n\nThe `setdefault()` method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist.\n\nThe `setdefault()` method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a `string`.\n\nYou can view the execution of this program at [https://autbor.com/setdefault](https://autbor.com/setdefault). The program loops over each character in the `message` variable’s string, counting how often each character appears. The `setdefault()` method ensures that the key is in the `count` `dictionary` (with a default value of 0) so the program doesn’t throw a `KeyError` error when `count[character] = count[character] + 1` is executed!\n\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time.\n\n### Pretty Printing\n\nIf you import the `pprint` module into your programs, you’ll have access to the `pprint()` function that will “pretty print” a `dictionary`’s values. This is helpful when you want a cleaner display of the items in a `dictionary` than what `print()` provides.\n\nYou can view the execution of this program at [https://autbor.com/pprint/](https://autbor.com/pprint/). This time, when the program is run, the output looks much cleaner, ***with the keys sorted***. The `pprint.pprint()` function is especially helpful when the dictionary itself contains nested `lists` or `dictionaries`.\n\n#### Dictionary Comprehensions\n\nDictionary comprehensions provide a convenient notation for quickly generating `dictionaries`, often by mapping one `dictionary` to another. For example, in a `dictionary` with unique values, you can reverse the key–value pairs: \n\nCurly braces delimit a dictionary comprehension, and the expression to the left of the `for` specifies a key–value pair of the form `key:value`. The comprehension iterates through `months.items()`, unpacking each key–value pair tuple into the variables `name` and `number`. The expression `number:name` reverses the key and value, so the new dictionary maps the month numbers to the month names. \n\nA dictionary comprehension also can map a `dictionary`’s values to new values. The following comprehension converts a `dictionary` of names and `lists` of grades into a `dictionary` of names and grade-point averages. The variables `k` and `v` commonly mean key and value:\n\n> Note the above is nested structure, with a `list` in a `dictionary`!\n\n### Using Data Structures to Model Real-World Things\n\nA `tic-tac-toe` board looks like a large hash symbol (`#`) with nine slots that can each contain an `X`, an `O`, or a blank. To represent the board with a `dictionary`, you can assign each slot a key, as shown in below:\n\n<div align=\"center\">\n\n| 1 | 2 | 3 |\n|---|---|---|\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |\n\n</div>\n\nYou can use string values to represent what’s in each slot on the board: 'X', 'O', or ' ' (a space). Thus, you’ll need to store nine strings. You can use a dictionary of values for this. The string value with the key '3' can represent the top-right corner, the string value with the key '7' can represent the bottom-left corner, the string value with the key '5' can represent the middle, and so on. This dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named `board`.\n\nA board where player O has won by placing Os across the top might look like this:\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000020.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter5/ </div>\n\nOf course, the player should see only what is printed to the screen, not the contents of variables. Let’s create a function to print the board dictionary onto the screen:\n\nThe `printBoard()` function can handle any tic-tac-toe data structure you pass it!\n\nNow let’s add code that allows the players to enter their moves.\n\nWe can also check whether player has won the game or not using the following code:\n\n> Note that by enclosing the condiations with `()`, we do not have to add `\\` for multipline commands.\n\n### > Exercise 1: Tic-tac-toe is a classic pencil-and-paper game played on a 3 × 3 grid. Players take turns placing their 'X' or 'O' marks, trying to get three in a row. Try to complete the following game design by complete three functions `getBlankBoard()`, `isValidSpace()` and `isBoardFull()`.\n\n### Nested Dictionaries and Lists\n\n#### A List of Dictionaries\n\nConsider a game featuring aliens that can have different colors and point values. This simple `dictionary` stores information about a particular alien:\n\nThe `alien_0` dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a screen full of aliens. How can you manage a fleet of aliens? One way is to make a list of aliens in which each alien is a `dictionary` of information about that alien.\n\nThese aliens all have the same characteristics, but `Python` considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progresses. When it’s time to change colors, we can use a `for` loop and an `if` statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this:\n\n## Sets\n\nA  `set` is an unordered collection of unique values. `Sets` may contain only immutable objects, like `strings`, `ints`,  `floats` and `tuples` that contain only immutable elements. \n\nThe following code creates a `set` of strings named `colors`: \n\nNotice that the duplicate string `'red'` was ignored (without causing an error). An important use of `sets` is ***duplicate elimination***, which is automatic when creating a `set`. Also, the resulting `set’s` values may not be displayed in the same order as they were listed! Though the color names are displayed in sorted order, ***sets are unordered***. You should not write code that depends on the order of their elements!\n\n> Note that we also use curly bracket to create a set!\n\nThough `sets` are iterable, they are not sequences and do not support indexing and slicing with square brackets, `[]`.\n\nYou can determine the number of items in a set with the built-in `len()` function: \n\nYou can check whether a `set` contains a particular value using the `in` and `not in` operators:\n\n`Sets` are iterable, so you can process each set element with a `for` loop:\n\n`Sets` are unordered, so there’s no significance to the iteration order!\n\n### Creating a `Set` with the Built-In `set()` Function\n\nYou can create a `set` from another collection of values by using the built-in `set()` function — here we create a `list` that contains several duplicate integer values and use that `list` as `set`’s argument:\n\nIf you need to create an empty `set`, you must use the `set()` function with empty parentheses, rather than empty braces, `{}`, which represent an empty `dictionary`:\n\n> Python displays an empty `set` as `set()` to avoid confusion with Python’s string representation of an empty `dictionary` (`{}`).\n\n### `Set` Operators and Methods\n\n`Sets` are mutable — you can add and remove elements, but set elements must be immutable. Therefore, a `set` cannot have other `sets` as elements.\n\n#### Methods for Adding and Removing Elements\n\n Here we first discuss operators and methods that modify an existing `set`. \n\nSet method `update()` performs a union operation modifying the set in-place — the argument can be any iterable:\n\n`Set` method `add()` inserts its argument if the argument is not already in the set; otherwise, the\n`set` remains unchanged:\n\n`Set` method `remove()` removes its argument from the `set` — a `KeyError` occurs if the value is not in the `set`:\n\nMethod `discard()` also removes its argument from the `set` but does not cause an exception if the value is not in the `set`. \n\n###  Mathematical Set Operations\n\nThe operators and methods presented in this section each result in a new set!\n\n#### Union \n\nThe union of two `sets` is a set consisting of all the unique elements from both sets. You can calculate the union with the `|` operator or with the set `union()` method:\n\nThe operands of the binary set operators, like `|`, must both be `sets`. The corresponding `set` methods may receive any iterable object as an argument — we passed a `list`. **When a mathematical `set` method receives a non-set iterable argument, it first converts the iterable to a set, then applies the mathematical operation.** \n\n#### Intersection \n\nThe intersection of two `sets` is a set consisting of all the unique elements that the two `sets` have in common. You can calculate the intersection with the `&` operator or with the set `intersection()` method:\n\n#### Difference \n\nThe difference between two `sets` is a set consisting of the elements in the left operand that are not in the right operand. You can calculate the difference with the `-` operator or with the set `difference()` method:\n\n#### Symmetric Difference \n\nThe symmetric difference between two sets is a set consisting of the elements of both sets that are ***not in common with one another***. You can calculate the symmetric difference with the `^` operator or with the set `symmetric_difference` method:\n\n#### Disjoint\n\nTwo `sets` are disjoint if they do not have any common elements. You can determine this with the set `isdisjoint()` method:\n\n### Set Comprehensions\n\nLike dictionary comprehensions, you define set comprehensions in curly braces. Let’s create a new `set` containing only the unique even values in the `list` numbers:\n\n### Sorting the `set` and `dictionary` \n\nAs we mentioned last week, data types like `tuples` don’t provide methods like `sort()`. However `Python` provides the built-in function `sorted()`, which takes any sequence as a parameter and returns a new container with the same elements in a different order. You can also apply `sorted` to the set, but the returning container will be `list`.\n\nNote that we have changed the behavior of the `sorted()` function by providing the custom key that allows us to sort the data in a specific order using the predefined `list` and the `index()` function.\n\nIf you would like to sort the `dictionary`, you need to use the `items()` method (Otherwise, it will only return keys). The returning container will again be a `list`:\n\nIf you would like to sort by the value, use the following code:\n\n### > Exercise 2: Try to design a program that counts the number of unique characters in a string. Be sure to exclude the punctuation and white space and the character with upper and lower cases are treated as different characters. \n\n<center><img src=\"https://realpython.com/cdn-cgi/image/width=960,format=auto/https://files.realpython.com/media/Encodings--Number-Systems_Watermarked.906d62e907dc.jpg\"></center>\n<div align=\"center\"> source: https://realpython.com/python-encodings-guide/ </div>\n\nIn this chapter, we discussed Python’s `dictionary` and `set` collections. They are both unorder, mutable and do not allow duplicates.\n\nWe said what a dictionary is and presented several examples. We showed the syntax of key–value pairs and showed how to use them to create `dictionaries` with comma-separated lists of key–value pairs in curly braces, `{}`. You also created dictionaries with dictionary comprehensions. You used square brackets, `[]`, to retrieve the value corresponding to a key, and to insert and update key–value pairs. You also used the dictionary method update to change a key’s associated value. You iterated through a dictionary’s keys, values and items.\n\nYou created `sets` of unique immutable values. You combined `sets` with set operators and methods, changed sets’ values with the mutable set operations and created `sets` with set comprehensions. You saw that sets are mutable.\n\nA short comparison of the containers is shown below:\n\n\n| Feature          | List    | Tuple   | Dictionary  | Set         |\n|------------------|---------|---------|-------------|-------------|\n| Mutable (Can be modified in place)         | Yes     | No      | Yes (keys are immutable)    | Yes         |\n| Iterable (Can be use in for loop)         | Yes     | Yes     | Yes         | Yes         |\n| Ordered (Can access by index, slicing)         | Yes     | Yes     | No          | No          |\n| Duplicate Values | Allowed | Allowed | Not in keys | Not allowed |\n\n\n","srcMarkdownNoYaml":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/05_Dictionaries_sets.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/05_Dictionaries_sets.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n## Dictionaries\n\nWe’ve discussed three built-in sequence collections — `strings`, `lists` and `tuples`. Now, we consider the built-in non-sequence collections — `dictionaries` and `sets`. A `dictionary` is an unordered collection which stores ***key–value*** pairs that map immutable keys to values, just as a conventional dictionary maps words to definitions. A `set` is an unordered collection of unique immutable elements.\n\nLike a `list`, a `dictionary` is a mutable collection of many values, but more general. In a `list`, the index positions have to be integers; in a `dictionary`, the indices can be any immutable data type. You can think of a dictionary as a mapping between a set of indices (which are called ***keys***) and a set of ***values***. Each key maps to a value. The association of a key and a value is called a ***key-value*** pair or sometimes an ***item***.\n\nA `dictionary`’s keys must be immutable (such as `strings`, `integers` or `tuples`) and unique (that is, no duplicates). However, multiple keys can have the same value.\n\n<center><img src=\"https://pynative.com/wp-content/uploads/2021/02/dictionaries-in-python.jpg\"></center>\n<div align=\"center\"> source: https://pynative.com/python-dictionaries/ </div>\n\n> It is noted that as of Python 3.7, dictionary items maintain the order in which they are inserted into the dictionary. However, `dictionaries` are considered unordered collections and do not write code that depends on the order of the key–value pairs. \n\nAs an example, we’ll build a dictionary that maps from subjects to grades, so the keys are `string` while the values are `integers`. The function `dict` creates a new dictionary with no items. \n\nTo add/update items to the dictionary, you can again use subscript operator (square brackets):\n\nYou can create a `dictionary` that contains multiple items by enclosing in curly braces, `{}`, a comma-separated list of key–value pairs, each of the form `key:value`.\n\nYou can store them using separate `lists` for subjects and scores, but the following update and maintenance will become tedious:\n\n```python\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nscore = [85, 80, 90, 95]\n````\n\nYou can now use the keys to look up the corresponding values:\n\nYou can obtain the number of items using `len()`\n\n> Note that you can't access items in them using integer indexes like `grade[0]` because it is unordered collections. (Consider the case when you use 4, 2, 1, 0 as the keys). Therefore, you can't use slice syntax for dictionaries. \n\nTrying to access a key that does not exist in a `dictionary` will result in a `KeyError` error message, much like a `list’s` “out-of-range” `IndexError` error message.\n\nTo add or delete an entry, it is similar to list\n\nYou can delete a key–value pair from a dictionary with the `del` statement:\n\n### The `keys()`, `values()`, and `items()` Methods\n\nThere are three `dictionary` methods that will return `list`-like values of the `dictionary`’s keys, values, or both keys and values: `keys()`, `values()`, and `items()`. The values returned by these methods are not true lists, but these data types (`dict_keys`, `dict_values`, and `dict_items`, respectively) can be used in `for` loops (Just like `range` object)!\n\nIf you want a true list from one of these methods, pass its list-like return value to the `list()` function\n\nHere, a `for` loop iterates over each of the values in the `grade` dictionary. A `for` loop can also iterate over the keys:\n\n> Note that by default, it will traverse over the keys!\n\nDictionaries have a method called `items()` that returns a list of tuples, where each tuple is a key-value pair:\n\nCombining `items()`, multiple assignment, and `for`, you can see a nice code pattern for traversing the keys and values of a dictionary in a single loop:\n\n#### Checking Whether a Key or Value Exists in a Dictionary\n\nRecall from the previous chapter that the `in` and `not in` operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary\n\n> Again, it will check keys by default. Therefore, in the previous example, `'calculus' in grade` is essentially a shorter version of writing `'calculus' in grade.keys()`. This is always the case: if you ever want to check whether a value is (or isn’t) a key in the `dictionary`, you can simply use the `in` (or `not in`) keyword with the `dictionary` itself.\n\n#### Retrieve value uisng  `get()` Method\n\nIt’s tedious to check whether a key exists in a `dictionary` before accessing that key’s value. Fortunately, dictionaries have a `get()` method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\nBecause there is no 'eggs' key in the `picnicItems` dictionary, the default value 0 is returned by the `get()` method. Without using `get()`, the code would have caused a `KeyError` message\n\n#### Update value using `setdefault()` Method\n\nYou’ll often have to set a value in a `dictionary` for a certain key only if that key does not already have a value. The code looks something like this:\n\nThe `setdefault()` method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist.\n\nThe `setdefault()` method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a `string`.\n\nYou can view the execution of this program at [https://autbor.com/setdefault](https://autbor.com/setdefault). The program loops over each character in the `message` variable’s string, counting how often each character appears. The `setdefault()` method ensures that the key is in the `count` `dictionary` (with a default value of 0) so the program doesn’t throw a `KeyError` error when `count[character] = count[character] + 1` is executed!\n\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time.\n\n### Pretty Printing\n\nIf you import the `pprint` module into your programs, you’ll have access to the `pprint()` function that will “pretty print” a `dictionary`’s values. This is helpful when you want a cleaner display of the items in a `dictionary` than what `print()` provides.\n\nYou can view the execution of this program at [https://autbor.com/pprint/](https://autbor.com/pprint/). This time, when the program is run, the output looks much cleaner, ***with the keys sorted***. The `pprint.pprint()` function is especially helpful when the dictionary itself contains nested `lists` or `dictionaries`.\n\n#### Dictionary Comprehensions\n\nDictionary comprehensions provide a convenient notation for quickly generating `dictionaries`, often by mapping one `dictionary` to another. For example, in a `dictionary` with unique values, you can reverse the key–value pairs: \n\nCurly braces delimit a dictionary comprehension, and the expression to the left of the `for` specifies a key–value pair of the form `key:value`. The comprehension iterates through `months.items()`, unpacking each key–value pair tuple into the variables `name` and `number`. The expression `number:name` reverses the key and value, so the new dictionary maps the month numbers to the month names. \n\nA dictionary comprehension also can map a `dictionary`’s values to new values. The following comprehension converts a `dictionary` of names and `lists` of grades into a `dictionary` of names and grade-point averages. The variables `k` and `v` commonly mean key and value:\n\n> Note the above is nested structure, with a `list` in a `dictionary`!\n\n### Using Data Structures to Model Real-World Things\n\nA `tic-tac-toe` board looks like a large hash symbol (`#`) with nine slots that can each contain an `X`, an `O`, or a blank. To represent the board with a `dictionary`, you can assign each slot a key, as shown in below:\n\n<div align=\"center\">\n\n| 1 | 2 | 3 |\n|---|---|---|\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |\n\n</div>\n\nYou can use string values to represent what’s in each slot on the board: 'X', 'O', or ' ' (a space). Thus, you’ll need to store nine strings. You can use a dictionary of values for this. The string value with the key '3' can represent the top-right corner, the string value with the key '7' can represent the bottom-left corner, the string value with the key '5' can represent the middle, and so on. This dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named `board`.\n\nA board where player O has won by placing Os across the top might look like this:\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000020.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter5/ </div>\n\nOf course, the player should see only what is printed to the screen, not the contents of variables. Let’s create a function to print the board dictionary onto the screen:\n\nThe `printBoard()` function can handle any tic-tac-toe data structure you pass it!\n\nNow let’s add code that allows the players to enter their moves.\n\nWe can also check whether player has won the game or not using the following code:\n\n> Note that by enclosing the condiations with `()`, we do not have to add `\\` for multipline commands.\n\n### > Exercise 1: Tic-tac-toe is a classic pencil-and-paper game played on a 3 × 3 grid. Players take turns placing their 'X' or 'O' marks, trying to get three in a row. Try to complete the following game design by complete three functions `getBlankBoard()`, `isValidSpace()` and `isBoardFull()`.\n\n### Nested Dictionaries and Lists\n\n#### A List of Dictionaries\n\nConsider a game featuring aliens that can have different colors and point values. This simple `dictionary` stores information about a particular alien:\n\nThe `alien_0` dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a screen full of aliens. How can you manage a fleet of aliens? One way is to make a list of aliens in which each alien is a `dictionary` of information about that alien.\n\nThese aliens all have the same characteristics, but `Python` considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progresses. When it’s time to change colors, we can use a `for` loop and an `if` statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this:\n\n## Sets\n\nA  `set` is an unordered collection of unique values. `Sets` may contain only immutable objects, like `strings`, `ints`,  `floats` and `tuples` that contain only immutable elements. \n\nThe following code creates a `set` of strings named `colors`: \n\nNotice that the duplicate string `'red'` was ignored (without causing an error). An important use of `sets` is ***duplicate elimination***, which is automatic when creating a `set`. Also, the resulting `set’s` values may not be displayed in the same order as they were listed! Though the color names are displayed in sorted order, ***sets are unordered***. You should not write code that depends on the order of their elements!\n\n> Note that we also use curly bracket to create a set!\n\nThough `sets` are iterable, they are not sequences and do not support indexing and slicing with square brackets, `[]`.\n\nYou can determine the number of items in a set with the built-in `len()` function: \n\nYou can check whether a `set` contains a particular value using the `in` and `not in` operators:\n\n`Sets` are iterable, so you can process each set element with a `for` loop:\n\n`Sets` are unordered, so there’s no significance to the iteration order!\n\n### Creating a `Set` with the Built-In `set()` Function\n\nYou can create a `set` from another collection of values by using the built-in `set()` function — here we create a `list` that contains several duplicate integer values and use that `list` as `set`’s argument:\n\nIf you need to create an empty `set`, you must use the `set()` function with empty parentheses, rather than empty braces, `{}`, which represent an empty `dictionary`:\n\n> Python displays an empty `set` as `set()` to avoid confusion with Python’s string representation of an empty `dictionary` (`{}`).\n\n### `Set` Operators and Methods\n\n`Sets` are mutable — you can add and remove elements, but set elements must be immutable. Therefore, a `set` cannot have other `sets` as elements.\n\n#### Methods for Adding and Removing Elements\n\n Here we first discuss operators and methods that modify an existing `set`. \n\nSet method `update()` performs a union operation modifying the set in-place — the argument can be any iterable:\n\n`Set` method `add()` inserts its argument if the argument is not already in the set; otherwise, the\n`set` remains unchanged:\n\n`Set` method `remove()` removes its argument from the `set` — a `KeyError` occurs if the value is not in the `set`:\n\nMethod `discard()` also removes its argument from the `set` but does not cause an exception if the value is not in the `set`. \n\n###  Mathematical Set Operations\n\nThe operators and methods presented in this section each result in a new set!\n\n#### Union \n\nThe union of two `sets` is a set consisting of all the unique elements from both sets. You can calculate the union with the `|` operator or with the set `union()` method:\n\nThe operands of the binary set operators, like `|`, must both be `sets`. The corresponding `set` methods may receive any iterable object as an argument — we passed a `list`. **When a mathematical `set` method receives a non-set iterable argument, it first converts the iterable to a set, then applies the mathematical operation.** \n\n#### Intersection \n\nThe intersection of two `sets` is a set consisting of all the unique elements that the two `sets` have in common. You can calculate the intersection with the `&` operator or with the set `intersection()` method:\n\n#### Difference \n\nThe difference between two `sets` is a set consisting of the elements in the left operand that are not in the right operand. You can calculate the difference with the `-` operator or with the set `difference()` method:\n\n#### Symmetric Difference \n\nThe symmetric difference between two sets is a set consisting of the elements of both sets that are ***not in common with one another***. You can calculate the symmetric difference with the `^` operator or with the set `symmetric_difference` method:\n\n#### Disjoint\n\nTwo `sets` are disjoint if they do not have any common elements. You can determine this with the set `isdisjoint()` method:\n\n### Set Comprehensions\n\nLike dictionary comprehensions, you define set comprehensions in curly braces. Let’s create a new `set` containing only the unique even values in the `list` numbers:\n\n### Sorting the `set` and `dictionary` \n\nAs we mentioned last week, data types like `tuples` don’t provide methods like `sort()`. However `Python` provides the built-in function `sorted()`, which takes any sequence as a parameter and returns a new container with the same elements in a different order. You can also apply `sorted` to the set, but the returning container will be `list`.\n\nNote that we have changed the behavior of the `sorted()` function by providing the custom key that allows us to sort the data in a specific order using the predefined `list` and the `index()` function.\n\nIf you would like to sort the `dictionary`, you need to use the `items()` method (Otherwise, it will only return keys). The returning container will again be a `list`:\n\nIf you would like to sort by the value, use the following code:\n\n### > Exercise 2: Try to design a program that counts the number of unique characters in a string. Be sure to exclude the punctuation and white space and the character with upper and lower cases are treated as different characters. \n\n<center><img src=\"https://realpython.com/cdn-cgi/image/width=960,format=auto/https://files.realpython.com/media/Encodings--Number-Systems_Watermarked.906d62e907dc.jpg\"></center>\n<div align=\"center\"> source: https://realpython.com/python-encodings-guide/ </div>\n\nIn this chapter, we discussed Python’s `dictionary` and `set` collections. They are both unorder, mutable and do not allow duplicates.\n\nWe said what a dictionary is and presented several examples. We showed the syntax of key–value pairs and showed how to use them to create `dictionaries` with comma-separated lists of key–value pairs in curly braces, `{}`. You also created dictionaries with dictionary comprehensions. You used square brackets, `[]`, to retrieve the value corresponding to a key, and to insert and update key–value pairs. You also used the dictionary method update to change a key’s associated value. You iterated through a dictionary’s keys, values and items.\n\nYou created `sets` of unique immutable values. You combined `sets` with set operators and methods, changed sets’ values with the mutable set operations and created `sets` with set comprehensions. You saw that sets are mutable.\n\nA short comparison of the containers is shown below:\n\n\n| Feature          | List    | Tuple   | Dictionary  | Set         |\n|------------------|---------|---------|-------------|-------------|\n| Mutable (Can be modified in place)         | Yes     | No      | Yes (keys are immutable)    | Yes         |\n| Iterable (Can be use in for loop)         | Yes     | Yes     | Yes         | Yes         |\n| Ordered (Can access by index, slicing)         | Yes     | Yes     | No          | No          |\n| Duplicate Values | Allowed | Allowed | Not in keys | Not allowed |\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"05_Dictionaries_sets.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","theme":"cosmo","title":"Other collections - Dictionaries and Sets","author":"phonchi","date":"03/17/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}