{"title":"Files and Exceptions","markdown":{"yaml":{"title":"Files and Exceptions","author":"phonchi","date":"03/31/2023","format":{"html":{"toc":true,"toc-depth":4,"code-line-numbers":true,"code-fold":true,"code-tools":true}}},"headingText":"Reading from a File","containsRefs":false,"markdown":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/07_Files.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/07_Files.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n\nNow that you've mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable.\n\nAn incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file.\n\n### Reading the Contents of a File\n\nTo begin, we need a file with a few lines of text in it. Let’s start with a file that contains `pi` to 30 decimal places:\n\nHere’s a program that opens this file, reads it, and prints the contents of the file to the screen:\n\nTo do any work with a file, even just printing its contents, you first need to open the file to access it. The `open()` function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that’s currently being executed is stored.  The `open()` function returns an object representing the file. Here, `open('pi_digits.txt')` returns an object representing `pi_digits.txt`. Python assigns this object to `file_object`, which we’ll work with later in the program.\n\nThe keyword `with` closes the file once access to it is no longer needed. Notice how we call `open()` in this program but not `close()`. You could open and close the file by calling `open()` and `close()`, but if a bug in your program \nprevents the `close()` method from being executed, the file may never close! This may seem trivial, but improperly closed files can cause data to be lost or corrupted. \n\nOnce we have a file object representing `pi_digits.txt`, we use the `read()` method in the second line of our program to read the entire contents of the file and store it as one long string in `contents`. Since `read()` returns an empty string when it reaches the end of the file; this empty string shows up as a blank line. If you want to remove the extra blank line, you can use `strip()` in the call to `print()`.\n\n> It’s not always easy to know exactly when you should close a file, but with the structure shown here, Python will figure \nthat out for you. All you have to do is open the file and work with it as desired, trusting that Python will close it \nautomatically when the `with` block finishes execution. \n\n### File Paths\n\nSometimes, depending on how you organize your work, the file you want to open won't be in the same directory as your program file.  To get Python to open files from a directory other than the one where your program file is stored, you need to provide a file path , which tells Python to look in a specific location on your system.  A ***relative file path*** will tell Python to look for a given location relative to the directory where the currently running program file is stored. For example, you’d write:\n\n```python\nwith open('text_files/filename.txt') as file_object:\n```\n\nThis line tells Python to look for the desired .txt file in the folder `text_files` and assumes that `text_files` is located in the current directory.\n\n> Windows systems use a backslash (`\\`) instead of a forward slash (`/`) when displaying file paths, but you can still use forward slashes in your code.\n\nYou can also tell Python exactly where the file is on your computer regardless of where the program that’s being executed is stored. This is called an ***absolute file path***. Absolute paths are usually longer than relative paths, so it’s helpful to assign them to a variable and then pass that variable to `open()`:\n\n```python\nfile_path = '/home/phonchi/other_files/text_files/filename.txt'\nwith open(file_path) as file_object:\n```\n\n### Reading Line by Line\n\nWhen you're reading a file, you'll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. You can use a `for` loop on the file object to examine each line from a file one at a time:\n\nTo examine the file's contents, we work through each line in the file by looping over the file object. Since there is a newline in each line of file and  the print function adds its own newline each time we call it, so we will end up with two newline characters at the end of each line: one from the file and one from `print()`. Using `strip()` on each line in the `print()` call eliminates these extra blank lines.\n\n### Making a List of Lines from a File\n\nWhen you use `with`, **the file object returned by `open()` is only available inside the with block that contains it**. If you want to retain access to a file's contents outside the `with` block, you can store the file's lines in a `list` inside the block and then work with that `list`!\n\nThe `readlines()` method takes each line from the file and stores it in a list. This list is then assigned to `lines`, which we can continue to work with after the `with` block ends. Here, we create a variable, `pi_string`, to hold the digits of pi. We then create a loop that adds each line of digits to `pi_string` and removes the newline character from each line.\n\n> When Python reads from a text file, it interprets all text in the file as a `string`. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the `int()` function or convert it to a float using the `float()` function.\n\n### Writing to a File\n\nOne of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program \nfinishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later!\n\n#### Writing to an Empty File\n\nTo write text to a file, you need to call `open()` with a second argument telling Python that you want to write to the file\n\nThe call to `open()` in this example has two arguments. The first argument is still the name of the file we want to open. The second argument, 'w', tells Python that we want to open the file in write mode.  You can open a file in read mode ('r'), write mode ('w'), append mode ('a'), or a mode that allows you to read and write to the file ( 'r+'). If you omit the mode argument, Python opens the file in read-only mode by default. Here, we use the `write()` method on the file object to write a string to the file.\n\n> Python can only write strings to a text file. If you want to store numerical data in a text file, you'll have to convert the \ndata to string format first using the `str()` function.\n\n\n> The `open()` function automatically creates the file you're writing to if it doesn't already exist. However, be careful opening a file in write mode ('w') because if the file does exist, Python will erase the contents of the file before returning the file object.\n\nWhile reading through a file, the system maintains a ***file-position pointer***(index) representing the location of the next character to read. Therefore, the following code snippet will allow you to append it to the end of the file. \n\nThe `tell()` function will return the current position of the file-position pointer. We can also use `seek()` to change the position. Checkout more details about file-position pointer [here](https://pynative.com/python-file-seek/).\n\n### Appending to a File\n\nIf you want to add content to a file instead of writing over existing content, you can also open the file in append mode. When you open a file in append mode, Python doesn’t erase the contents of the file before returning the file object. \nAny lines you write to the file will be added at the end of the file. If the file doesn’t exist yet, Python will create an empty file for you. \n\nThe `write()` function doesn’t add any newlines to the text you write. So we need to add newline characters if we would like to. There is also a `writelines()` function that can write list of strings into files.\n\n## Storing Data\n\nMany of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for visualization. Whatever the focus of your program is, you'll store the information users provide in data structures such as `lists` and `dictionaries`. When users close a program, you'll almost always want to save the information they entered. A simple way to do this involves storing your data using the `json` module.\n\nThe `json` module allows you to dump simple Python data structures into a file and load the data from that file the next time the program runs. **You can also use `json` to share data between different programming languages. It’s a useful and portable format.**\n\n#### Using `json.dump()` and `json.load()`\n\nThe `json.dump()` function takes two arguments: a piece of data to store and a file object it can use to store the data.\n\nNow we’ll write a program that uses `json.load()` to read the list back into memory\n\n## Exceptions\n\nPython uses special objects called exceptions to manage errors that arise during a program's execution. Whenever an error makes Python unsure of what to do next, it creates an `exception` object. If we write code that handles the exception, the program will continue running. If you don't handle the exception, the program will halt and show a ***traceback***, which includes a report of the exception that was raised.\n\nExceptions are handled with `try-except` blocks. A `try-except` block tells Python what to do if an exception is raised. When we use `try-except` blocks, our programs will continue running even if things go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that we write!\n\n### Handling the `ZeroDivisionError` Exception\n\nThe error reported at the first line in the traceback, `ZeroDivisionError`, is an exception object. Python creates this kind of object in response to a situation where it can't do what we ask. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program.\n\nWhen we think an error may occur, you can write a `try-except` block to handle the exception that might be raised. We tell Python to try running some code and tell it what to do if the code results in a particular kind of exception.\n\nWe put `print(5/0)`, the line that caused the error, inside a `try` block. If the code in a `try` block works, Python skips over the `except` block. If the code in the `try` block causes an error, Python looks for an `except` block whose error matches the one that was raised and ran the code in that block. In this example, the user sees a friendly error message instead of a traceback.\n\nIf you do not add any exception type, it will capture all exceptions!\n\n### Using Exceptions to Prevent Crashes\n\nHandling errors correctly is especially important when the program has more work to do after the error occurs. Let’s create a simple calculator that does only division:\n\nHere, the error may occur on the line that performs the division, so that's where we'll put the `try-except` block. This example also includes an `else` block. Any code that depends on the `try` block executing successfully goes into the `else` block. In addition, the `finally` clause is guaranteed to execute, regardless of whether its `try` suite executes successfully or an exception occurs.\n\nWe ask Python to try to complete the division operation in a `try` block, which includes only the code that might cause an error. The program continues to run, and the user never sees a traceback.\n\n### Handling the `FileNotFoundError` Exception\n\nOne common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename may be misspelled, or the file may not exist at all\n\nIn this example, the code in the `try` block produces a `FileNotFoundError`, so Python looks for an `except` block that matches that error. Python then runs the code in that block, and the result is a friendly error message instead of a traceback.\n\n### Exercise 1: Assuming we are designing a word game called \"The Mysterious Island\" and we need to load the statistics of the player and enemies each time the game begins. Try to complete the following functions `load_data()` and `save_data()` so that you can load the JSON file if it does not exist using the exception handling techniques you just learned.\n\n\n<center><img src=\"https://cdn.leonardo.ai/users/f26a2ba8-8273-45e9-8db9-958f83058486/generations/905d6875-67b0-4960-8ff9-bb18e1fda05a/Leonardo_Creative_As_you_venture_deeper_into_the_dark_damp_cav_1.jpg\"></center>\n\nIn this chapter, you learned how to work with files. You learned to read an entire file at once and read through a file’s contents one line at a time. You learned to write to a file and append text onto the end of a file. You learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program. Finally, You read about exceptions and how to handle the exceptions you’re likely to see in your programs.  \n","srcMarkdownNoYaml":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/07_Files.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/07_Files.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n## Reading from a File\n\nNow that you've mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable.\n\nAn incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file.\n\n### Reading the Contents of a File\n\nTo begin, we need a file with a few lines of text in it. Let’s start with a file that contains `pi` to 30 decimal places:\n\nHere’s a program that opens this file, reads it, and prints the contents of the file to the screen:\n\nTo do any work with a file, even just printing its contents, you first need to open the file to access it. The `open()` function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that’s currently being executed is stored.  The `open()` function returns an object representing the file. Here, `open('pi_digits.txt')` returns an object representing `pi_digits.txt`. Python assigns this object to `file_object`, which we’ll work with later in the program.\n\nThe keyword `with` closes the file once access to it is no longer needed. Notice how we call `open()` in this program but not `close()`. You could open and close the file by calling `open()` and `close()`, but if a bug in your program \nprevents the `close()` method from being executed, the file may never close! This may seem trivial, but improperly closed files can cause data to be lost or corrupted. \n\nOnce we have a file object representing `pi_digits.txt`, we use the `read()` method in the second line of our program to read the entire contents of the file and store it as one long string in `contents`. Since `read()` returns an empty string when it reaches the end of the file; this empty string shows up as a blank line. If you want to remove the extra blank line, you can use `strip()` in the call to `print()`.\n\n> It’s not always easy to know exactly when you should close a file, but with the structure shown here, Python will figure \nthat out for you. All you have to do is open the file and work with it as desired, trusting that Python will close it \nautomatically when the `with` block finishes execution. \n\n### File Paths\n\nSometimes, depending on how you organize your work, the file you want to open won't be in the same directory as your program file.  To get Python to open files from a directory other than the one where your program file is stored, you need to provide a file path , which tells Python to look in a specific location on your system.  A ***relative file path*** will tell Python to look for a given location relative to the directory where the currently running program file is stored. For example, you’d write:\n\n```python\nwith open('text_files/filename.txt') as file_object:\n```\n\nThis line tells Python to look for the desired .txt file in the folder `text_files` and assumes that `text_files` is located in the current directory.\n\n> Windows systems use a backslash (`\\`) instead of a forward slash (`/`) when displaying file paths, but you can still use forward slashes in your code.\n\nYou can also tell Python exactly where the file is on your computer regardless of where the program that’s being executed is stored. This is called an ***absolute file path***. Absolute paths are usually longer than relative paths, so it’s helpful to assign them to a variable and then pass that variable to `open()`:\n\n```python\nfile_path = '/home/phonchi/other_files/text_files/filename.txt'\nwith open(file_path) as file_object:\n```\n\n### Reading Line by Line\n\nWhen you're reading a file, you'll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. You can use a `for` loop on the file object to examine each line from a file one at a time:\n\nTo examine the file's contents, we work through each line in the file by looping over the file object. Since there is a newline in each line of file and  the print function adds its own newline each time we call it, so we will end up with two newline characters at the end of each line: one from the file and one from `print()`. Using `strip()` on each line in the `print()` call eliminates these extra blank lines.\n\n### Making a List of Lines from a File\n\nWhen you use `with`, **the file object returned by `open()` is only available inside the with block that contains it**. If you want to retain access to a file's contents outside the `with` block, you can store the file's lines in a `list` inside the block and then work with that `list`!\n\nThe `readlines()` method takes each line from the file and stores it in a list. This list is then assigned to `lines`, which we can continue to work with after the `with` block ends. Here, we create a variable, `pi_string`, to hold the digits of pi. We then create a loop that adds each line of digits to `pi_string` and removes the newline character from each line.\n\n> When Python reads from a text file, it interprets all text in the file as a `string`. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the `int()` function or convert it to a float using the `float()` function.\n\n### Writing to a File\n\nOne of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program \nfinishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later!\n\n#### Writing to an Empty File\n\nTo write text to a file, you need to call `open()` with a second argument telling Python that you want to write to the file\n\nThe call to `open()` in this example has two arguments. The first argument is still the name of the file we want to open. The second argument, 'w', tells Python that we want to open the file in write mode.  You can open a file in read mode ('r'), write mode ('w'), append mode ('a'), or a mode that allows you to read and write to the file ( 'r+'). If you omit the mode argument, Python opens the file in read-only mode by default. Here, we use the `write()` method on the file object to write a string to the file.\n\n> Python can only write strings to a text file. If you want to store numerical data in a text file, you'll have to convert the \ndata to string format first using the `str()` function.\n\n\n> The `open()` function automatically creates the file you're writing to if it doesn't already exist. However, be careful opening a file in write mode ('w') because if the file does exist, Python will erase the contents of the file before returning the file object.\n\nWhile reading through a file, the system maintains a ***file-position pointer***(index) representing the location of the next character to read. Therefore, the following code snippet will allow you to append it to the end of the file. \n\nThe `tell()` function will return the current position of the file-position pointer. We can also use `seek()` to change the position. Checkout more details about file-position pointer [here](https://pynative.com/python-file-seek/).\n\n### Appending to a File\n\nIf you want to add content to a file instead of writing over existing content, you can also open the file in append mode. When you open a file in append mode, Python doesn’t erase the contents of the file before returning the file object. \nAny lines you write to the file will be added at the end of the file. If the file doesn’t exist yet, Python will create an empty file for you. \n\nThe `write()` function doesn’t add any newlines to the text you write. So we need to add newline characters if we would like to. There is also a `writelines()` function that can write list of strings into files.\n\n## Storing Data\n\nMany of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for visualization. Whatever the focus of your program is, you'll store the information users provide in data structures such as `lists` and `dictionaries`. When users close a program, you'll almost always want to save the information they entered. A simple way to do this involves storing your data using the `json` module.\n\nThe `json` module allows you to dump simple Python data structures into a file and load the data from that file the next time the program runs. **You can also use `json` to share data between different programming languages. It’s a useful and portable format.**\n\n#### Using `json.dump()` and `json.load()`\n\nThe `json.dump()` function takes two arguments: a piece of data to store and a file object it can use to store the data.\n\nNow we’ll write a program that uses `json.load()` to read the list back into memory\n\n## Exceptions\n\nPython uses special objects called exceptions to manage errors that arise during a program's execution. Whenever an error makes Python unsure of what to do next, it creates an `exception` object. If we write code that handles the exception, the program will continue running. If you don't handle the exception, the program will halt and show a ***traceback***, which includes a report of the exception that was raised.\n\nExceptions are handled with `try-except` blocks. A `try-except` block tells Python what to do if an exception is raised. When we use `try-except` blocks, our programs will continue running even if things go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that we write!\n\n### Handling the `ZeroDivisionError` Exception\n\nThe error reported at the first line in the traceback, `ZeroDivisionError`, is an exception object. Python creates this kind of object in response to a situation where it can't do what we ask. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program.\n\nWhen we think an error may occur, you can write a `try-except` block to handle the exception that might be raised. We tell Python to try running some code and tell it what to do if the code results in a particular kind of exception.\n\nWe put `print(5/0)`, the line that caused the error, inside a `try` block. If the code in a `try` block works, Python skips over the `except` block. If the code in the `try` block causes an error, Python looks for an `except` block whose error matches the one that was raised and ran the code in that block. In this example, the user sees a friendly error message instead of a traceback.\n\nIf you do not add any exception type, it will capture all exceptions!\n\n### Using Exceptions to Prevent Crashes\n\nHandling errors correctly is especially important when the program has more work to do after the error occurs. Let’s create a simple calculator that does only division:\n\nHere, the error may occur on the line that performs the division, so that's where we'll put the `try-except` block. This example also includes an `else` block. Any code that depends on the `try` block executing successfully goes into the `else` block. In addition, the `finally` clause is guaranteed to execute, regardless of whether its `try` suite executes successfully or an exception occurs.\n\nWe ask Python to try to complete the division operation in a `try` block, which includes only the code that might cause an error. The program continues to run, and the user never sees a traceback.\n\n### Handling the `FileNotFoundError` Exception\n\nOne common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename may be misspelled, or the file may not exist at all\n\nIn this example, the code in the `try` block produces a `FileNotFoundError`, so Python looks for an `except` block that matches that error. Python then runs the code in that block, and the result is a friendly error message instead of a traceback.\n\n### Exercise 1: Assuming we are designing a word game called \"The Mysterious Island\" and we need to load the statistics of the player and enemies each time the game begins. Try to complete the following functions `load_data()` and `save_data()` so that you can load the JSON file if it does not exist using the exception handling techniques you just learned.\n\n\n<center><img src=\"https://cdn.leonardo.ai/users/f26a2ba8-8273-45e9-8db9-958f83058486/generations/905d6875-67b0-4960-8ff9-bb18e1fda05a/Leonardo_Creative_As_you_venture_deeper_into_the_dark_damp_cav_1.jpg\"></center>\n\nIn this chapter, you learned how to work with files. You learned to read an entire file at once and read through a file’s contents one line at a time. You learned to write to a file and append text onto the end of a file. You learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program. Finally, You read about exceptions and how to handle the exceptions you’re likely to see in your programs.  \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"07_Files.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","book":{"page-navigation":true,"title":"mybook","author":"phonchi","date":"02/17/2023","chapters":["index.qmd","01_Python.ipynb","02_Flow_control.ipynb","03_Function.ipynb","04_Lists_tuples.ipynb","05_Dictionaries_sets.ipynb","06_Manipulating_string.ipynb","07_Files.ipynb"],"search":{"location":"navbar","type":"overlay"}},"theme":"cosmo","title":"Files and Exceptions","author":"phonchi","date":"03/31/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}