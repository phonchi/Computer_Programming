{"title":"Functions","markdown":{"yaml":{"title":"Functions","author":"phonchi","date":"03/03/2023","format":{"html":{"toc":true,"toc-depth":4,"code-line-numbers":true,"code-fold":true,"code-tools":true}}},"headingText":"Introductions","containsRefs":false,"markdown":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/03_Function.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/03_Function.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n\nExperience has shown that the best way to develop and maintain a large program is to con struct it from smaller, more manageable pieces. This technique is called ***divide and conquer***. We have already seen operations like `print()`, `str()` and `len()`, which involve parentheses wrapped around their operands. These are examples of Python's built-in ***functions***. Programming language allows us to use a name for a series of operations that should be performed on the given parameters. The appearance of a function in an expression or statement is known as a ***function call***, or sometimes ***calling*** a function. \n\n- It allows you to execute a block of codes from various locations in your program by calling the function, rather than duplicating the code. \n\n- It also makes programs easier to modify. When you change a function’s code, all calls to the function execute the updated version.\n\n> A function is a block of organized code that is used to perform a task. They provide better modularity and reusability.\n\n### `def` Statements with Parameters\n\nWhen you call the `print()` or `len()` function, you pass them values, called ***arguments***, by typing them between the parentheses. You can also define your own functions that accept arguments. \n\nThe `def` statement defines the `hello()` function. Any indented lines that follow `def hello():` make up the function's body. The `hello('Alice')` line **calls** the now-created function. This function call is also known as **passing** the string value 'Alice' to the function. \n\n![image.png](attachment:image.png)\n\nYou can view the execution of this program at [https://autbor.com/hellofunc2/](https://autbor.com/hellofunc2/). The definition of the `hello()` function in this program has a ***parameter*** called `name`. When a function is called with arguments, the arguments are stored in the parameters. The first time the `hello()` function is called, it is passed the argument 'Alice'. The program execution enters the function, and the parameter name is automatically set to 'Alice', which is what gets printed by the `print()` statement. One thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added `print(name)` after `hello('Bob')` in the previous program, the program would give you a `NameError` because there is no variable named `name`.\n\n#### Positional Arguments\n\nWhen you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is based on the order of the arguments provided. Values matched up this way are called ***positional arguments***.\n\nWhen we call `describe_pet()`, we need to provide an `animal_type` and a `name`, **in that order**. For example, in the function call, the argument 'hamster' is assigned to the parameter `animal_type` and the argument 'harry' is assigned to the parameter `pet_name`. In the function body, these two parameters are used to display information about the pet being described.\n\nNote that the text on the second line is a comment called a ***docstring (multi-line comments introduced in Chapter 1)***, which describes what the function does. When Python generates documentation for the functions in your programs, it looks for a string immediately after the function's definition. These strings are usually enclosed in triple quotes, which lets you write multiple lines. If you use the `help()` function, it will also be printed out as well as the function name and parameters.\n\n> Note that if there is more than one argument in `print()`, the default separation value is a white space. But you can change this behavior by specifying the `sep` keyword.\n\n#### Return Values and return Statements\n\nWhen you call the `len()` function and pass it an argument such as 'Hello', the function call evaluates to the integer value. The value that a function call evaluates to is called the ***return value*** of the function.\n\nWhen creating a function using the `def` statement, you can specify what the return value should be with a `return` statement.  A `return` statement consists of the following:\n\n- The `return` keyword\n- The value or expression that the function should return\n\nWhen an expression is used with a `return` statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on the number passed as an argument.\n\nYou can view the execution of this program at [https://autbor.com/magic8ball/](https://autbor.com). When this program starts, Python first imports the `random` module. Then the `getAnswer()` function is defined. Because the function is being defined (and not called), the execution skips over the code in it. Next, the `random.randint()` function is called with two arguments: 1 and 9. It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named `r`.\n\nThe `getAnswer()` function is called with `r` as the argument. The program execution moves to the top of the `getAnswer()` function, and the value `r` is stored in a parameter named `answerNumber`. Then, depending on the value in `answerNumber`, the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that was originally called `getAnswer()`. The returned string is assigned to a variable named `fortune`, which then gets passed to a `print()` call and is printed to the screen. The functions that return values are sometimes called ***fruitful functions***.\n\n#### The `None` Value\n\nIn Python, there is a value called `None`, which represents the absence of a value. The `None` value is the only value of the `NoneType` data type. This can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where `None` is used is as the return value of `print()`. The `print()` function displays text on the screen, but it doesn’t need to return anything. But since all function calls need to evaluate to a return value, `print()` returns `None`. A function does not return a value is called a ***void function***\n\n> Behind the scenes, Python adds return `None` in the end of any function definition with no `return` statement. Also, if you use a `return` statement without a value (that is, just the `return` keyword by itself), then `None` is returned.\n\n#### Keyword Arguments\n\nA ***keyword argument*** is a name-value pair you pass to a function. You directly associate the name and the value within the argument, so when you pass the argument to the function, there’s no confusion. Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call.\n\nThe function `describe_pet()` hasn't changed. But when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument 'hamster' to the parameter `animal_type` and the argument 'harry' to `pet_name`. The output correctly shows that we have a hamster named Harry.\n\n#### Default parameter values\n\nWhen writing a function, you can define a default value for each parameter. If an argument for a parameter is provided in the function call, Python uses the argument value. If not, it uses the parameter's default value. For example, if you notice that most of the calls to `describe_pet()` are being used to describe dogs, you can set the default value of `animal_type` to 'dog':\n\nNow when the function is called with no `animal_type` specified, Python knows to use the value 'dog' for this parameter. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet’s name. Python still interprets this as a positional argument, so if the function is called with just a pet’s name, that argument will match up with the first parameter listed in the function’s definition.\n\n> When you use default values, any parameter with a default value needs to be listed after all the parameters that don’t have default values. This allows Python to continue interpreting positional arguments correctly. Otherwise error occurs.\n\n### Advance usage\n\n#### Passing an Arbitrary Number of Arguments\n\nSometimes you won’t know how many arguments a function needs to accept ahead of time. Fortunately, Python allows a function to collect arbitrary arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, `*toppings`, but this parameter collects as many arguments as the calling line provides:\n\nIn the function definition, Python assigns the first value it receives to the parameter `size`. All other values that come after are stored in the `tuple` (which we will discuss in later chapters) with the name `toppings`. The function calls include an argument for the size first, followed by as many toppings as needed.\n\n> You’ll often see the generic parameter name `*args`, which collects arbitrary positional arguments like this. The `*arg` must be the rightmost parameter (except for parameter with default value and the `**kwargs`). \n\n#### Using Arbitrary Keyword Arguments\n\nSometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function `build_profile()` in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:\n\nThe definition of `build_profile()` expects a first and last name, and then it allows the user to pass in as many name-value pairs (Keyword arguments) as they want. The double asterisks before the parameter `**user_info` cause Python to create a `dictionary` (Which we will discuss in later chapters) called `user_info` containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in `user_info` just as you would for any dictionary.\n\nIn the body of `build_profile()`, we add the first and last names to the user_info dictionary because we’ll always receive these two pieces of information from the user, and they haven’t been placed into the dictionary yet. Then we return the `user_info` dictionary to the function call line.\n\n> You’ll often see the parameter name `**kwargs` used to collect nonspecific keyword arguments. The `**kwargs` must be the rightmost paramter.\n\n> ###  Exercise 1: Please write a function implementing the \"guess the number\" game. The function accepts two arguments for the maximum number of tries and the maximum number. The function returns a boolean value indicating whether the player guessed the number correctly or not. If the player doesn't guess the number correctly after the maximum number of tries, the function returns False; otherwise, it should return True. You can set the default value of the max number to an arbitrary number.\n\n<center><img src=\"https://media.discordapp.net/attachments/989268324884049960/1080339545062641786/phonchi_draw_the_cartoon_the_depicts_a_python_and_the_guess_the_71048d5c-3d44-47a3-b398-7500e18db839.png?width=630&height=630\"></center>\n\n> Currently, there exists a delay for the `input()` function in vscode. Therefore, it is recommended to play the game using the script!\n\n### Local and Global Scope\n\nParameters and variables assigned in a called function are said to exist in that function’s ***local scope***. Variables assigned outside all functions are said to exist in the ***global scope***. A variable in a local scope is called a ***local variable***, while a variable in the global scope is called a ***global variable***. A variable must be one or the other; it cannot be both local and global.\n\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. **There is only one global scope, and it is created when your program begins. A local scope is created whenever a function is called. Any variables assigned in the function exist within the function’s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten.** The next time you call the function, the local variables will not remember the values stored in them from the last time it was called.\n\n#### Local Variables Cannot Be Used in the Global Scope\n\nConsider this program, which will cause an error when you run it:\n\nThe error happens because the `eggs` variable exists only in the local scope created when `spam()` is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs.\n\n#### Local Scopes Cannot Use Variables in Other Local Scopes\n\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\nYou can view the execution of this program at [https://autbor.com/otherlocalscopes/](https://autbor.com). When the program starts, the `spam()` function is called, and a local scope is created. The local variable eggs is set to 99. Then the `bacon()` function is called, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable `ham` is set to 101, and a local variable `eggs` — which is different from the one in `spam()`’s local scope—is also created and set to 0. When `bacon()` returns, the local scope for that call is destroyed, including its `eggs` variable. The program execution continues in the `spam()` function to print the value of eggs. Since the local scope for the call to `spam()` still exists, the only `eggs` variable is the `spam()` function’s `eggs` variable, which was set to 99.\n\n#### Global Variables Can Be Read from a Local Scope\n\nYou can view the execution of this program at [https://autbor.com/readglobal/](https://autbor.com). Since there is no parameter named eggs or any code that assigns `eggs` a value in the `spam()` function, when `eggs` is used in `spam()`, Python considers it a reference to the global variable `eggs`. This is why 42 is printed when the previous program is run.\n\n> If you want to modify the global variable, use the `global` keywords.\n\nYou can visulaize the execution [here](https://pythontutor.com/visualize.html#code=def%20spam%28%29%3A%0A%20%20%20%20global%20eggs%20%20%20%20%23%20If%20you%20want%20to%20modify%20the%20global%20eggs%20use%20global%20keyword%0A%20%20%20%20eggs%20%3D%20'spam%20local'%20%0A%20%20%20%20print%28eggs%29%20%20%20%20%23%20prints%20'spam%20local'%0A%0Aeggs%20%3D%20'global'%0Aspam%28%29%0Aprint%28eggs%29&cumulative=false&curInstr=8&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false).\n\n### Storing Your Functions in Modules\n\nOne advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, \nyour programs become much easier to follow. You can go a step further by storing your functions in a separate file called a ***module*** and then importing that module into your main program. An `import` statement tells Python to make the code in a module available in the currently running program file.\n\n> Storing your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.\n\n#### Importing a module\n\nTo start importing functions, we first need to create a module. **A module is a file ending in `.py` that contains the code you want to import into your program**. Let’s make a module that contains the function `make_pizza()`.\n\nWhen Python reads this file, the line import pizza tells Python to open the file `pizza.py` and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. To call a function from an imported module, enter the name of the module you imported, pizza, followed by the name of the function, `make_pizza()`, separated by a dot. \n\n#### Importing Specific Functions using `from`\n\nYou can also import a specific function from a module. \n\nWith this syntax, you don’t need to use the dot notation when you call a function.\n\n#### Importing All Functions in a Module\n\nYou can tell Python to import every function in a module by using the asterisk (*) operator:\n\nThe asterisk in the `import` statement tells Python to copy every function from the module pizza into this program file. Because every function is imported, you can call each function by name without using the dot notation. \n\n> However, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results!\n\n#### Using `as` to Give a Function an Alias\n\nIf the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique alias — an alternate name similar to a nickname for the function.\n\n#### Using `as` to Give a Module an Alias\n\nYou can also provide an alias for a module name. Giving a module a short alias, like p for pizza, allows you to call the module’s functions more quickly. \n\n> ###  Exercise 2: In this word game, the player is in a land full of dragons. Some dragons are friendly and share their treasure. Other dragons are hungry and eat anyone who enters their cave. The player approaches two caves, one with a friendly dragon and the other with a hungry dragon, but doesn’t know which dragon is in which cave. The player must choose between the two. Please completet the design of game by calling the function from the provided `game` module.\n\n<center><img src=\"https://cdn.discordapp.com/attachments/989268324884049960/1080334432004755536/phonchi_You_are_in_a_land_full_of_dragons._In_front_of_you_you__39c4daff-b24b-4dc4-bdfb-637f9e3ddcee.png\"></center>\n\n\nFunctions are the primary way to categorize your code into logical groups. Since the variables in functions exist in their local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when debugging your code.\n\nFunctions are a great tool to help you organize your code. You can think of them as black boxes: they have input in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions.\n","srcMarkdownNoYaml":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/03_Function.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/03_Function.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n## Introductions\n\nExperience has shown that the best way to develop and maintain a large program is to con struct it from smaller, more manageable pieces. This technique is called ***divide and conquer***. We have already seen operations like `print()`, `str()` and `len()`, which involve parentheses wrapped around their operands. These are examples of Python's built-in ***functions***. Programming language allows us to use a name for a series of operations that should be performed on the given parameters. The appearance of a function in an expression or statement is known as a ***function call***, or sometimes ***calling*** a function. \n\n- It allows you to execute a block of codes from various locations in your program by calling the function, rather than duplicating the code. \n\n- It also makes programs easier to modify. When you change a function’s code, all calls to the function execute the updated version.\n\n> A function is a block of organized code that is used to perform a task. They provide better modularity and reusability.\n\n### `def` Statements with Parameters\n\nWhen you call the `print()` or `len()` function, you pass them values, called ***arguments***, by typing them between the parentheses. You can also define your own functions that accept arguments. \n\nThe `def` statement defines the `hello()` function. Any indented lines that follow `def hello():` make up the function's body. The `hello('Alice')` line **calls** the now-created function. This function call is also known as **passing** the string value 'Alice' to the function. \n\n![image.png](attachment:image.png)\n\nYou can view the execution of this program at [https://autbor.com/hellofunc2/](https://autbor.com/hellofunc2/). The definition of the `hello()` function in this program has a ***parameter*** called `name`. When a function is called with arguments, the arguments are stored in the parameters. The first time the `hello()` function is called, it is passed the argument 'Alice'. The program execution enters the function, and the parameter name is automatically set to 'Alice', which is what gets printed by the `print()` statement. One thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added `print(name)` after `hello('Bob')` in the previous program, the program would give you a `NameError` because there is no variable named `name`.\n\n#### Positional Arguments\n\nWhen you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is based on the order of the arguments provided. Values matched up this way are called ***positional arguments***.\n\nWhen we call `describe_pet()`, we need to provide an `animal_type` and a `name`, **in that order**. For example, in the function call, the argument 'hamster' is assigned to the parameter `animal_type` and the argument 'harry' is assigned to the parameter `pet_name`. In the function body, these two parameters are used to display information about the pet being described.\n\nNote that the text on the second line is a comment called a ***docstring (multi-line comments introduced in Chapter 1)***, which describes what the function does. When Python generates documentation for the functions in your programs, it looks for a string immediately after the function's definition. These strings are usually enclosed in triple quotes, which lets you write multiple lines. If you use the `help()` function, it will also be printed out as well as the function name and parameters.\n\n> Note that if there is more than one argument in `print()`, the default separation value is a white space. But you can change this behavior by specifying the `sep` keyword.\n\n#### Return Values and return Statements\n\nWhen you call the `len()` function and pass it an argument such as 'Hello', the function call evaluates to the integer value. The value that a function call evaluates to is called the ***return value*** of the function.\n\nWhen creating a function using the `def` statement, you can specify what the return value should be with a `return` statement.  A `return` statement consists of the following:\n\n- The `return` keyword\n- The value or expression that the function should return\n\nWhen an expression is used with a `return` statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on the number passed as an argument.\n\nYou can view the execution of this program at [https://autbor.com/magic8ball/](https://autbor.com). When this program starts, Python first imports the `random` module. Then the `getAnswer()` function is defined. Because the function is being defined (and not called), the execution skips over the code in it. Next, the `random.randint()` function is called with two arguments: 1 and 9. It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named `r`.\n\nThe `getAnswer()` function is called with `r` as the argument. The program execution moves to the top of the `getAnswer()` function, and the value `r` is stored in a parameter named `answerNumber`. Then, depending on the value in `answerNumber`, the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that was originally called `getAnswer()`. The returned string is assigned to a variable named `fortune`, which then gets passed to a `print()` call and is printed to the screen. The functions that return values are sometimes called ***fruitful functions***.\n\n#### The `None` Value\n\nIn Python, there is a value called `None`, which represents the absence of a value. The `None` value is the only value of the `NoneType` data type. This can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where `None` is used is as the return value of `print()`. The `print()` function displays text on the screen, but it doesn’t need to return anything. But since all function calls need to evaluate to a return value, `print()` returns `None`. A function does not return a value is called a ***void function***\n\n> Behind the scenes, Python adds return `None` in the end of any function definition with no `return` statement. Also, if you use a `return` statement without a value (that is, just the `return` keyword by itself), then `None` is returned.\n\n#### Keyword Arguments\n\nA ***keyword argument*** is a name-value pair you pass to a function. You directly associate the name and the value within the argument, so when you pass the argument to the function, there’s no confusion. Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call.\n\nThe function `describe_pet()` hasn't changed. But when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument 'hamster' to the parameter `animal_type` and the argument 'harry' to `pet_name`. The output correctly shows that we have a hamster named Harry.\n\n#### Default parameter values\n\nWhen writing a function, you can define a default value for each parameter. If an argument for a parameter is provided in the function call, Python uses the argument value. If not, it uses the parameter's default value. For example, if you notice that most of the calls to `describe_pet()` are being used to describe dogs, you can set the default value of `animal_type` to 'dog':\n\nNow when the function is called with no `animal_type` specified, Python knows to use the value 'dog' for this parameter. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet’s name. Python still interprets this as a positional argument, so if the function is called with just a pet’s name, that argument will match up with the first parameter listed in the function’s definition.\n\n> When you use default values, any parameter with a default value needs to be listed after all the parameters that don’t have default values. This allows Python to continue interpreting positional arguments correctly. Otherwise error occurs.\n\n### Advance usage\n\n#### Passing an Arbitrary Number of Arguments\n\nSometimes you won’t know how many arguments a function needs to accept ahead of time. Fortunately, Python allows a function to collect arbitrary arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, `*toppings`, but this parameter collects as many arguments as the calling line provides:\n\nIn the function definition, Python assigns the first value it receives to the parameter `size`. All other values that come after are stored in the `tuple` (which we will discuss in later chapters) with the name `toppings`. The function calls include an argument for the size first, followed by as many toppings as needed.\n\n> You’ll often see the generic parameter name `*args`, which collects arbitrary positional arguments like this. The `*arg` must be the rightmost parameter (except for parameter with default value and the `**kwargs`). \n\n#### Using Arbitrary Keyword Arguments\n\nSometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function `build_profile()` in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:\n\nThe definition of `build_profile()` expects a first and last name, and then it allows the user to pass in as many name-value pairs (Keyword arguments) as they want. The double asterisks before the parameter `**user_info` cause Python to create a `dictionary` (Which we will discuss in later chapters) called `user_info` containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in `user_info` just as you would for any dictionary.\n\nIn the body of `build_profile()`, we add the first and last names to the user_info dictionary because we’ll always receive these two pieces of information from the user, and they haven’t been placed into the dictionary yet. Then we return the `user_info` dictionary to the function call line.\n\n> You’ll often see the parameter name `**kwargs` used to collect nonspecific keyword arguments. The `**kwargs` must be the rightmost paramter.\n\n> ###  Exercise 1: Please write a function implementing the \"guess the number\" game. The function accepts two arguments for the maximum number of tries and the maximum number. The function returns a boolean value indicating whether the player guessed the number correctly or not. If the player doesn't guess the number correctly after the maximum number of tries, the function returns False; otherwise, it should return True. You can set the default value of the max number to an arbitrary number.\n\n<center><img src=\"https://media.discordapp.net/attachments/989268324884049960/1080339545062641786/phonchi_draw_the_cartoon_the_depicts_a_python_and_the_guess_the_71048d5c-3d44-47a3-b398-7500e18db839.png?width=630&height=630\"></center>\n\n> Currently, there exists a delay for the `input()` function in vscode. Therefore, it is recommended to play the game using the script!\n\n### Local and Global Scope\n\nParameters and variables assigned in a called function are said to exist in that function’s ***local scope***. Variables assigned outside all functions are said to exist in the ***global scope***. A variable in a local scope is called a ***local variable***, while a variable in the global scope is called a ***global variable***. A variable must be one or the other; it cannot be both local and global.\n\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. **There is only one global scope, and it is created when your program begins. A local scope is created whenever a function is called. Any variables assigned in the function exist within the function’s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten.** The next time you call the function, the local variables will not remember the values stored in them from the last time it was called.\n\n#### Local Variables Cannot Be Used in the Global Scope\n\nConsider this program, which will cause an error when you run it:\n\nThe error happens because the `eggs` variable exists only in the local scope created when `spam()` is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs.\n\n#### Local Scopes Cannot Use Variables in Other Local Scopes\n\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\nYou can view the execution of this program at [https://autbor.com/otherlocalscopes/](https://autbor.com). When the program starts, the `spam()` function is called, and a local scope is created. The local variable eggs is set to 99. Then the `bacon()` function is called, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable `ham` is set to 101, and a local variable `eggs` — which is different from the one in `spam()`’s local scope—is also created and set to 0. When `bacon()` returns, the local scope for that call is destroyed, including its `eggs` variable. The program execution continues in the `spam()` function to print the value of eggs. Since the local scope for the call to `spam()` still exists, the only `eggs` variable is the `spam()` function’s `eggs` variable, which was set to 99.\n\n#### Global Variables Can Be Read from a Local Scope\n\nYou can view the execution of this program at [https://autbor.com/readglobal/](https://autbor.com). Since there is no parameter named eggs or any code that assigns `eggs` a value in the `spam()` function, when `eggs` is used in `spam()`, Python considers it a reference to the global variable `eggs`. This is why 42 is printed when the previous program is run.\n\n> If you want to modify the global variable, use the `global` keywords.\n\nYou can visulaize the execution [here](https://pythontutor.com/visualize.html#code=def%20spam%28%29%3A%0A%20%20%20%20global%20eggs%20%20%20%20%23%20If%20you%20want%20to%20modify%20the%20global%20eggs%20use%20global%20keyword%0A%20%20%20%20eggs%20%3D%20'spam%20local'%20%0A%20%20%20%20print%28eggs%29%20%20%20%20%23%20prints%20'spam%20local'%0A%0Aeggs%20%3D%20'global'%0Aspam%28%29%0Aprint%28eggs%29&cumulative=false&curInstr=8&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false).\n\n### Storing Your Functions in Modules\n\nOne advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, \nyour programs become much easier to follow. You can go a step further by storing your functions in a separate file called a ***module*** and then importing that module into your main program. An `import` statement tells Python to make the code in a module available in the currently running program file.\n\n> Storing your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.\n\n#### Importing a module\n\nTo start importing functions, we first need to create a module. **A module is a file ending in `.py` that contains the code you want to import into your program**. Let’s make a module that contains the function `make_pizza()`.\n\nWhen Python reads this file, the line import pizza tells Python to open the file `pizza.py` and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. To call a function from an imported module, enter the name of the module you imported, pizza, followed by the name of the function, `make_pizza()`, separated by a dot. \n\n#### Importing Specific Functions using `from`\n\nYou can also import a specific function from a module. \n\nWith this syntax, you don’t need to use the dot notation when you call a function.\n\n#### Importing All Functions in a Module\n\nYou can tell Python to import every function in a module by using the asterisk (*) operator:\n\nThe asterisk in the `import` statement tells Python to copy every function from the module pizza into this program file. Because every function is imported, you can call each function by name without using the dot notation. \n\n> However, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results!\n\n#### Using `as` to Give a Function an Alias\n\nIf the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique alias — an alternate name similar to a nickname for the function.\n\n#### Using `as` to Give a Module an Alias\n\nYou can also provide an alias for a module name. Giving a module a short alias, like p for pizza, allows you to call the module’s functions more quickly. \n\n> ###  Exercise 2: In this word game, the player is in a land full of dragons. Some dragons are friendly and share their treasure. Other dragons are hungry and eat anyone who enters their cave. The player approaches two caves, one with a friendly dragon and the other with a hungry dragon, but doesn’t know which dragon is in which cave. The player must choose between the two. Please completet the design of game by calling the function from the provided `game` module.\n\n<center><img src=\"https://cdn.discordapp.com/attachments/989268324884049960/1080334432004755536/phonchi_You_are_in_a_land_full_of_dragons._In_front_of_you_you__39c4daff-b24b-4dc4-bdfb-637f9e3ddcee.png\"></center>\n\n\nFunctions are the primary way to categorize your code into logical groups. Since the variables in functions exist in their local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when debugging your code.\n\nFunctions are a great tool to help you organize your code. You can think of them as black boxes: they have input in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"03_Function.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","theme":"cosmo","title":"Functions","author":"phonchi","date":"03/03/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}