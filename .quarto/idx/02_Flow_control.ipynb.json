{"title":"Flow Control","markdown":{"yaml":{"title":"Flow Control","author":"phonchi","date":"02/24/2023","format":{"html":{"toc":true,"code-line-numbers":true,"code-tools":true}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math105A/blob/master/static_files/presentations/01_Python.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math105A/blob/master/static_files/presentations/01_Python.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n\nLast week, we learned the basics of individual instructions and that a program is just a series of instructions. But programming’s real strength isn’t just running one instruction after another. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you rarely want your programs to start from the first line of code and simply execute every line straight to the end. **Flow control statements** can decide which Python instructions to execute under which conditions.\n\nThese flow control statements directly correspond to the symbols in a flowchart. A flowchart usually has more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps (states) are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000039.jpg\">\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div></center>\n</br>\n\nBut before you learn about flow control statements, you first need to learn how to represent those **yes** and **no** options and understand how to write those **branching** points as Python code. To that end, let’s explore Boolean values, comparison operators, and Boolean operators.\n\n### Boolean expressions\n\nA boolean expression is an expression that is either true or false. The following examples use the operator `==`, which compares two operands and produces `True` if they are equal and `False` otherwise:\n\n`True` and `False` are special values that belong to the class `bool`; they are not strings:\n\nThe `==` operator is one of the ***comparison operators*** or relational operators; the others are:\n\n|            | Meaning                         |\n|------------|---------------------------------|\n| x != y     | x is not equal to y             |\n| x > y      | x is greater than y             |\n| x < y      | x is less than y                |\n| x >= y     | x is greater than or equal to y |\n| x <= y     | x is less than or equal to y    |\n| x is y     | x is the same as y              |\n| x is not y | x is not the same as y          |\n\n> The `Python` symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign `=` instead of a double equal sign `==`. Remember that `=` is used in the assignment statement and `==` is a comparison operator. There is no such thing as `=<` or `=>`.\n\nThese operators evaluate to `True` or `False` depending on the values you give them and, therefore, can be used in the decision point as a condition statement.\n\n### Boolean (Logical) Operators\n\nThe three Boolean operators (`and`, `or`, and `not`) are used to operate on Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let’s explore these operators in detail.\n\n| Expression      | Evaluates to . . . |  \n|-----------------|--------------------|\n| True and True   | True               |\n| True and False  | False              |\n| False and True  | False              |\n| False and False | False              |\n\n| Expression     | Evaluates to . . . |\n|----------------|--------------------|\n| True or True   | True               |\n| True or False  | True               |\n| False or True  | True               |\n| False or False | False              |\n\n| Expression | Evaluates to . . . |\n|------------|--------------------|\n| not True   | False              |\n| not False  | True               |\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. The Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the `not` operators first, then the and operators, `and` then the `or` operators.\n\n## Elements of Flow Control\n\nIt can be shown that all programs could be written using three forms of control—namely, **sequential execution, the selection statement and the repetition statement**. This is the idea behind ***structured programming***.\n\nFlow control statements often start with a part called the ***condition*** and are always followed by a block of code called the ***clause*** or body. The Boolean expressions you’ve seen so far could all be considered conditions, which are the same thing as expressions; the condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, `True` or `False`. A flow control statement decides what to do based on whether its condition is `True` or `False`.\n\n### Blocks of Code\n\nLines of Python code can be grouped together in ***blocks***. You can tell when a block begins and ends from the *indentation* of the lines of code. There are three rules for blocks.\n\n1. Blocks begin when the indentation increases.\n2. Blocks can contain other blocks.\n3. Blocks end when the indentation decreases to zero or to a containing block’s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let’s find the blocks in part of a small game program, shown here:\n\nYou can view the execution of this program at [https://autbor.com/blocks/](https://autbor.com/howmanyguests/). The first block of code starts at the line `print('Hello, Mary')` and contains all the lines after it. Inside this block is another block, which has only a single line in it: `print('Access Granted.')`. The third block is also one line long: `print('Wrong password.')`.\n\nAn `IndentationError` occurs if you have more than one statement in a block and those statements do not have the same indentation:\n\n> It is recomend to use **four white spaces** as the indentation\n\n### Conditional execution\n\nThe control statement affords us a mechanism for jumping from one part of a program to another. In higher-level languages like Python, this enables what is called **control structures**, syntax patterns that allow us to express algorithms more succinctly. One example of this is the **if-statement**. An `if` statement’s body (that is, the block following the `if` statement) will execute if the statement’s condition is `True`. The body is skipped if the condition is `False`.\n\nIn Python, an `if` statement consists of the following:\n\n- The `if` keyword\n- A condition (that is, an expression that evaluates to `True` or `False`)\n- A colon\n- Starting on the next line, an indented block of code (called the `if` body)\n\nThe boolean expression after the `if` statement is called the condition. We end the `if` statement with a colon character (`:`) and the line(s) after the `if` statement are indented. If the logical condition is true, then the indented statement gets executed. If the logical condition is false, the indented statement is skipped.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000147.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\nA second form of the `if` statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:\n\nYou can also write the above code in one line using the ***ternary conditional operator***:\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000118.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\nSince the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called ***branches***, because they are branches in the flow of execution.\n\nSometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:\n\nYou can view the execution of this program at [https://autbor.com/littlekid/](https://autbor.com/howmanyguests/). In plain English, this type of flow control structure would be “If the first condition is true, do this. Else, if the second condition is true, do that.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000032.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\n> ### Exercise 1: Write a code that allows the user to input `row` and `column`. The program prints 'black' or 'white' depending on the color of the specified row and column of the chessboard. Chess boards are 8 x 8 spaces in size, and the rows and columns in this program begin at 0 and end at 7. If the inputs for a row or column are outside the 0 to 7 range, it should print 'out of board'!\n\n<center><img src=\"https://inventwithpython.com/pythongently/images/image011.png\" width=\"20%\"></center>\n<div align=\"center\"> source: https://inventwithpython.com/pythongently/images/image011.png </div>\n\n### Loops and Iterations\n\nYou can make a block of code execute over and over again using a `while` statement. The code in a `while` body will be executed as long as the `while` statement’s condition is `True`. In code, a `while` statement always consists of the following:\n\n- The `while` keyword\n- A condition (that is, an expression that evaluates to `True` or `False`)\n- A colon\n- Starting on the next line, an indented block of code (called the `while` body)\n\n> ***Augmented assignments*** abbreviate assignment expressions in which the same variable name appears on the left and right of the assignment’s `=` as above\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000112.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\nMore formally, here is the flow of execution for a `while` statement:\n\n1. Evaluate the condition, yielding `True` or `False`.\n\n2. If the condition is false, exit the `while` statement and continue execution at the next statement.\n\n3. If the condition is true, execute the body and then go back to step 1.\n\nIn the `while` ***loop***, the condition is always checked at the start of each ***iteration*** (that is, each time the loop is executed). If the condition is `True`, then the body is executed, and afterward, the condition is checked again. The first time the condition is found to be `False`, the while body is skipped.\n\nA common programming pattern is that we can run the program as long as the user wants by putting most of the program in a `while` loop. We’ll define a quit value and then keep the program running as long as the user has not entered the quit value:\n\nWe first set up a variable `message` to keep track of whatever value the user enters. We define `message` as an empty string, `\"\"`, so Python has something to check the first time it reaches the while line. The first time through the loop, the message is just an empty string, so Python enters the loop. At `message = input(prompt)`, Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to `message` and printed; then, Python reevaluates the condition in the `while` statement. As long as the user has not entered the word 'quit', the prompt is displayed again and Python waits for more input. When the user finally enters 'quit', Python stops executing the while loop and the program ends.\n\n> Note that Python considers `0`, `None`, empty string, and empty container as `False` and all other things are `True`!\n\n#### Using `break` to Exit a Loop\n\nThe above program works well, except that it prints the word 'quit' as if it were an actual message. In fact, there is a shortcut to getting the program execution to break out of a `while` loop’s body early. If the execution reaches a `break` statement, it immediately exits the while loop’s body. In code, a `break` statement simply contains the `break` keyword.\n\nThe fourth line creates an ***infinite loop***; it is a `while` loop whose condition is always `True`. After the program execution enters this loop, it will exit the loop only when a `break` statement is executed. (An infinite loop that never exits is a common programming bug.)\n\nJust like before, this program asks the user to for the input. Now, however, while the execution is still inside the `while` loop, an `if` statement checks whether the `message` is equal to 'quit'. If this condition is `True`, the `break` statement is run, and the execution moves out of the loop. Otherwise, the `if` statement’s body that contains the `break` statement is skipped, which again prints out the `message`. After that, the program execution jumps back to the start of the `while` statement to recheck the condition. Since this condition is merely the `True` Boolean value, the execution enters the loop to ask the user to type another message.\n\n#### `continue` Statemet\n\nRather than breaking out of a loop entirely without executing the rest of its code, you can use the `continue` statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop  that counts from 1 to 10 but prints only the odd numbers in that range:\n\nFirst, we set `current_number` to 0. Because it’s less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1, so  `current_number` is 1. The `if` statement then checks the modulo of `current_number` and 2. If the modulo is 0, the `continue` statement tells Python to ignore the rest of the loop and return to the beginning. If the `current_number` is not divisible by 2, the rest of the loop is executed and Python prints the `current_number`.\n\nNote that the built-in function `print()` displays its argument(s), then moves the cursor to the next line. You can change this behavior with the argument `end`. We used one space (' '), so each call to print displays the character’s value followed by one space.\n\n> If you ever run a program that has a bug causing it to get stuck in an infinite loop, press CTRL-C. This will send a `KeyboardInterrupt` error to your program and cause it to stop immediately.\n\n#### “TRUTHY” and “FALSY” Values\n\nLet us delve into the following program:\n\nYou can view the execution of this program at [https://autbor.com/howmanyguests/](https://autbor.com/howmanyguests/). If the user enters a blank string for name, then the `while` statement’s condition will be `True`, and the program continues to ask for a name. If the value for `numOfGuests` is not `0`, then the condition is considered to be `True`, and the program will print a reminder for the user. You could have entered `not name != ''` instead of `not name`, and `numOfGuests != 0` instead of `numOfGuests`, but using the truthy and falsy values can make your code easier to read.\n\n### `for` Loops and the `range()` Function\n\nThe `while` loop keeps looping `while` its condition is `True` (which is the reason for its name), but what if you want to execute a block of code **only a certain number of times**? You can do this with a `for` loop statement and the `range()` function.\n\nIn code, a `for` statement looks something like `for i in range(5)`: and includes the following:\n\n- The `for` keyword\n- A variable name\n- The `in` keyword\n- A call to the `range()` funtion with up to three integers passed to it (or an `iterable` object, which we will discuss later on)\n- A colon\n- Starting on the next line, an indented block of code (called the for body)\n\nLet’s create a new program to help you see a `for` loop in action.\n\nYou can view the execution of this program at [https://autbor.com/fivetimesfor/](https://autbor.com/howmanyguests/). The code in the `for` loop’s body is run five times. The first time it is run, the variable `i` is set to 0. The `print()` call in the body will print Jimmy Five Times (0). After Python finishes an iteration through all the code inside the `for` loop’s body, the execution goes back to the top of the loop, and the `for` statement increments `i` by one. This is why `range(5)` results in five iterations through the body, with `i` being set to 0, then 1, then 2, then 3, and then 4. The variable `i` will go up to, but will not include, the integer passed to `range()`. \n\nYou can actually use a `while` loop to do the same thing as a `for` loop; `for` loops are just more concise.\n\n#### The Starting, Stopping, and Stepping Arguments to `range()`\n\nSome functions can be called with multiple arguments separated by a comma, and `range()` is one of them. This lets you change the integer passed to `range()` to follow any sequence of integers, including starting at a number other than zero.\n\nThe `range()` function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.\n\nThe `range()` function is flexible in the sequence of numbers it produces for `for` loops. For example , you can even use a **negative number** for the step argument to make the `for` loop count down instead of up.\n\n> Note that Python introduce [switch](https://learnpython.com/blog/python-match-case-statement/) statement as another control statement in Python 3.10 \n\n> ### Exercise 2: Write a script that displays the following triangle patterns. Use `for` loops to generate the patterns. \n\n```\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n```\n\nHint: Try to use nested loops and use the outer loop to display each row while the inner loop to display each column\n\n## Importing Modules\n\nAll Python programs can call a basic set of functions called built-in functions, including the `print()`, `input()`, `len()` and `range()` functions you’ve seen before. Python also comes with a set of modules called the **standard library**. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the `math` module has mathematics-related functions. The `random` module has random number-related functions, and so on.\n\nBefore you can use the functions in a module, you must ***import*** the module with an `import` statement. In code, an `import` statement consists of the following:\n\n- The `import` keyword\n- The name of the module\n- Optionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let’s give it a try with the `random` module, which will give us access to the `random.randint()` function.\n\nYou can view the execution of this program at https://autbor.com/printrandom/. The `random.randint()` function call evaluates to a random integer value between the two integers that you pass it. Since `randint()` is in the `random` module, you must first type `random.` in front of the function name to tell Python to look for this function inside the `random` module. We will discuss it more in the following chapter.\n\n> Check out the Python standard library [here](https://docs.python.org/3/library/index.html#library-index) or [here](https://pymotw.com/3/index.html)\n\n### Ending a Program Early with the `sys.exit()` Function\n\nThe last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the `sys.exit()` function. Since this function is in the `sys` module, you have to `import sys` before your program can use it.\n\nBy using expressions that evaluate to `True` or `False` (also called conditions), you can write programs that make decisions on what code to execute and what code to skip. You can also execute code over and over again in a loop while a certain condition evaluates to `True`. The `break` and `continue` statements are useful if you need to exit a loop or jump back to the loop’s start. These flow control statements will let you write more intelligent programs. You can also use another type of flow control by **writing your own functions**, which is the topic of the next chapter.\n","srcMarkdownNoYaml":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math105A/blob/master/static_files/presentations/01_Python.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math105A/blob/master/static_files/presentations/01_Python.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n## Introduction\n\nLast week, we learned the basics of individual instructions and that a program is just a series of instructions. But programming’s real strength isn’t just running one instruction after another. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you rarely want your programs to start from the first line of code and simply execute every line straight to the end. **Flow control statements** can decide which Python instructions to execute under which conditions.\n\nThese flow control statements directly correspond to the symbols in a flowchart. A flowchart usually has more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps (states) are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000039.jpg\">\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div></center>\n</br>\n\nBut before you learn about flow control statements, you first need to learn how to represent those **yes** and **no** options and understand how to write those **branching** points as Python code. To that end, let’s explore Boolean values, comparison operators, and Boolean operators.\n\n### Boolean expressions\n\nA boolean expression is an expression that is either true or false. The following examples use the operator `==`, which compares two operands and produces `True` if they are equal and `False` otherwise:\n\n`True` and `False` are special values that belong to the class `bool`; they are not strings:\n\nThe `==` operator is one of the ***comparison operators*** or relational operators; the others are:\n\n|            | Meaning                         |\n|------------|---------------------------------|\n| x != y     | x is not equal to y             |\n| x > y      | x is greater than y             |\n| x < y      | x is less than y                |\n| x >= y     | x is greater than or equal to y |\n| x <= y     | x is less than or equal to y    |\n| x is y     | x is the same as y              |\n| x is not y | x is not the same as y          |\n\n> The `Python` symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign `=` instead of a double equal sign `==`. Remember that `=` is used in the assignment statement and `==` is a comparison operator. There is no such thing as `=<` or `=>`.\n\nThese operators evaluate to `True` or `False` depending on the values you give them and, therefore, can be used in the decision point as a condition statement.\n\n### Boolean (Logical) Operators\n\nThe three Boolean operators (`and`, `or`, and `not`) are used to operate on Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let’s explore these operators in detail.\n\n| Expression      | Evaluates to . . . |  \n|-----------------|--------------------|\n| True and True   | True               |\n| True and False  | False              |\n| False and True  | False              |\n| False and False | False              |\n\n| Expression     | Evaluates to . . . |\n|----------------|--------------------|\n| True or True   | True               |\n| True or False  | True               |\n| False or True  | True               |\n| False or False | False              |\n\n| Expression | Evaluates to . . . |\n|------------|--------------------|\n| not True   | False              |\n| not False  | True               |\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. The Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the `not` operators first, then the and operators, `and` then the `or` operators.\n\n## Elements of Flow Control\n\nIt can be shown that all programs could be written using three forms of control—namely, **sequential execution, the selection statement and the repetition statement**. This is the idea behind ***structured programming***.\n\nFlow control statements often start with a part called the ***condition*** and are always followed by a block of code called the ***clause*** or body. The Boolean expressions you’ve seen so far could all be considered conditions, which are the same thing as expressions; the condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, `True` or `False`. A flow control statement decides what to do based on whether its condition is `True` or `False`.\n\n### Blocks of Code\n\nLines of Python code can be grouped together in ***blocks***. You can tell when a block begins and ends from the *indentation* of the lines of code. There are three rules for blocks.\n\n1. Blocks begin when the indentation increases.\n2. Blocks can contain other blocks.\n3. Blocks end when the indentation decreases to zero or to a containing block’s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let’s find the blocks in part of a small game program, shown here:\n\nYou can view the execution of this program at [https://autbor.com/blocks/](https://autbor.com/howmanyguests/). The first block of code starts at the line `print('Hello, Mary')` and contains all the lines after it. Inside this block is another block, which has only a single line in it: `print('Access Granted.')`. The third block is also one line long: `print('Wrong password.')`.\n\nAn `IndentationError` occurs if you have more than one statement in a block and those statements do not have the same indentation:\n\n> It is recomend to use **four white spaces** as the indentation\n\n### Conditional execution\n\nThe control statement affords us a mechanism for jumping from one part of a program to another. In higher-level languages like Python, this enables what is called **control structures**, syntax patterns that allow us to express algorithms more succinctly. One example of this is the **if-statement**. An `if` statement’s body (that is, the block following the `if` statement) will execute if the statement’s condition is `True`. The body is skipped if the condition is `False`.\n\nIn Python, an `if` statement consists of the following:\n\n- The `if` keyword\n- A condition (that is, an expression that evaluates to `True` or `False`)\n- A colon\n- Starting on the next line, an indented block of code (called the `if` body)\n\nThe boolean expression after the `if` statement is called the condition. We end the `if` statement with a colon character (`:`) and the line(s) after the `if` statement are indented. If the logical condition is true, then the indented statement gets executed. If the logical condition is false, the indented statement is skipped.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000147.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\nA second form of the `if` statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:\n\nYou can also write the above code in one line using the ***ternary conditional operator***:\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000118.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\nSince the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called ***branches***, because they are branches in the flow of execution.\n\nSometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:\n\nYou can view the execution of this program at [https://autbor.com/littlekid/](https://autbor.com/howmanyguests/). In plain English, this type of flow control structure would be “If the first condition is true, do this. Else, if the second condition is true, do that.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000032.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\n> ### Exercise 1: Write a code that allows the user to input `row` and `column`. The program prints 'black' or 'white' depending on the color of the specified row and column of the chessboard. Chess boards are 8 x 8 spaces in size, and the rows and columns in this program begin at 0 and end at 7. If the inputs for a row or column are outside the 0 to 7 range, it should print 'out of board'!\n\n<center><img src=\"https://inventwithpython.com/pythongently/images/image011.png\" width=\"20%\"></center>\n<div align=\"center\"> source: https://inventwithpython.com/pythongently/images/image011.png </div>\n\n### Loops and Iterations\n\nYou can make a block of code execute over and over again using a `while` statement. The code in a `while` body will be executed as long as the `while` statement’s condition is `True`. In code, a `while` statement always consists of the following:\n\n- The `while` keyword\n- A condition (that is, an expression that evaluates to `True` or `False`)\n- A colon\n- Starting on the next line, an indented block of code (called the `while` body)\n\n> ***Augmented assignments*** abbreviate assignment expressions in which the same variable name appears on the left and right of the assignment’s `=` as above\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000112.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter2/ </div>\n\nMore formally, here is the flow of execution for a `while` statement:\n\n1. Evaluate the condition, yielding `True` or `False`.\n\n2. If the condition is false, exit the `while` statement and continue execution at the next statement.\n\n3. If the condition is true, execute the body and then go back to step 1.\n\nIn the `while` ***loop***, the condition is always checked at the start of each ***iteration*** (that is, each time the loop is executed). If the condition is `True`, then the body is executed, and afterward, the condition is checked again. The first time the condition is found to be `False`, the while body is skipped.\n\nA common programming pattern is that we can run the program as long as the user wants by putting most of the program in a `while` loop. We’ll define a quit value and then keep the program running as long as the user has not entered the quit value:\n\nWe first set up a variable `message` to keep track of whatever value the user enters. We define `message` as an empty string, `\"\"`, so Python has something to check the first time it reaches the while line. The first time through the loop, the message is just an empty string, so Python enters the loop. At `message = input(prompt)`, Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to `message` and printed; then, Python reevaluates the condition in the `while` statement. As long as the user has not entered the word 'quit', the prompt is displayed again and Python waits for more input. When the user finally enters 'quit', Python stops executing the while loop and the program ends.\n\n> Note that Python considers `0`, `None`, empty string, and empty container as `False` and all other things are `True`!\n\n#### Using `break` to Exit a Loop\n\nThe above program works well, except that it prints the word 'quit' as if it were an actual message. In fact, there is a shortcut to getting the program execution to break out of a `while` loop’s body early. If the execution reaches a `break` statement, it immediately exits the while loop’s body. In code, a `break` statement simply contains the `break` keyword.\n\nThe fourth line creates an ***infinite loop***; it is a `while` loop whose condition is always `True`. After the program execution enters this loop, it will exit the loop only when a `break` statement is executed. (An infinite loop that never exits is a common programming bug.)\n\nJust like before, this program asks the user to for the input. Now, however, while the execution is still inside the `while` loop, an `if` statement checks whether the `message` is equal to 'quit'. If this condition is `True`, the `break` statement is run, and the execution moves out of the loop. Otherwise, the `if` statement’s body that contains the `break` statement is skipped, which again prints out the `message`. After that, the program execution jumps back to the start of the `while` statement to recheck the condition. Since this condition is merely the `True` Boolean value, the execution enters the loop to ask the user to type another message.\n\n#### `continue` Statemet\n\nRather than breaking out of a loop entirely without executing the rest of its code, you can use the `continue` statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop  that counts from 1 to 10 but prints only the odd numbers in that range:\n\nFirst, we set `current_number` to 0. Because it’s less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1, so  `current_number` is 1. The `if` statement then checks the modulo of `current_number` and 2. If the modulo is 0, the `continue` statement tells Python to ignore the rest of the loop and return to the beginning. If the `current_number` is not divisible by 2, the rest of the loop is executed and Python prints the `current_number`.\n\nNote that the built-in function `print()` displays its argument(s), then moves the cursor to the next line. You can change this behavior with the argument `end`. We used one space (' '), so each call to print displays the character’s value followed by one space.\n\n> If you ever run a program that has a bug causing it to get stuck in an infinite loop, press CTRL-C. This will send a `KeyboardInterrupt` error to your program and cause it to stop immediately.\n\n#### “TRUTHY” and “FALSY” Values\n\nLet us delve into the following program:\n\nYou can view the execution of this program at [https://autbor.com/howmanyguests/](https://autbor.com/howmanyguests/). If the user enters a blank string for name, then the `while` statement’s condition will be `True`, and the program continues to ask for a name. If the value for `numOfGuests` is not `0`, then the condition is considered to be `True`, and the program will print a reminder for the user. You could have entered `not name != ''` instead of `not name`, and `numOfGuests != 0` instead of `numOfGuests`, but using the truthy and falsy values can make your code easier to read.\n\n### `for` Loops and the `range()` Function\n\nThe `while` loop keeps looping `while` its condition is `True` (which is the reason for its name), but what if you want to execute a block of code **only a certain number of times**? You can do this with a `for` loop statement and the `range()` function.\n\nIn code, a `for` statement looks something like `for i in range(5)`: and includes the following:\n\n- The `for` keyword\n- A variable name\n- The `in` keyword\n- A call to the `range()` funtion with up to three integers passed to it (or an `iterable` object, which we will discuss later on)\n- A colon\n- Starting on the next line, an indented block of code (called the for body)\n\nLet’s create a new program to help you see a `for` loop in action.\n\nYou can view the execution of this program at [https://autbor.com/fivetimesfor/](https://autbor.com/howmanyguests/). The code in the `for` loop’s body is run five times. The first time it is run, the variable `i` is set to 0. The `print()` call in the body will print Jimmy Five Times (0). After Python finishes an iteration through all the code inside the `for` loop’s body, the execution goes back to the top of the loop, and the `for` statement increments `i` by one. This is why `range(5)` results in five iterations through the body, with `i` being set to 0, then 1, then 2, then 3, and then 4. The variable `i` will go up to, but will not include, the integer passed to `range()`. \n\nYou can actually use a `while` loop to do the same thing as a `for` loop; `for` loops are just more concise.\n\n#### The Starting, Stopping, and Stepping Arguments to `range()`\n\nSome functions can be called with multiple arguments separated by a comma, and `range()` is one of them. This lets you change the integer passed to `range()` to follow any sequence of integers, including starting at a number other than zero.\n\nThe `range()` function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.\n\nThe `range()` function is flexible in the sequence of numbers it produces for `for` loops. For example , you can even use a **negative number** for the step argument to make the `for` loop count down instead of up.\n\n> Note that Python introduce [switch](https://learnpython.com/blog/python-match-case-statement/) statement as another control statement in Python 3.10 \n\n> ### Exercise 2: Write a script that displays the following triangle patterns. Use `for` loops to generate the patterns. \n\n```\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n```\n\nHint: Try to use nested loops and use the outer loop to display each row while the inner loop to display each column\n\n## Importing Modules\n\nAll Python programs can call a basic set of functions called built-in functions, including the `print()`, `input()`, `len()` and `range()` functions you’ve seen before. Python also comes with a set of modules called the **standard library**. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the `math` module has mathematics-related functions. The `random` module has random number-related functions, and so on.\n\nBefore you can use the functions in a module, you must ***import*** the module with an `import` statement. In code, an `import` statement consists of the following:\n\n- The `import` keyword\n- The name of the module\n- Optionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let’s give it a try with the `random` module, which will give us access to the `random.randint()` function.\n\nYou can view the execution of this program at https://autbor.com/printrandom/. The `random.randint()` function call evaluates to a random integer value between the two integers that you pass it. Since `randint()` is in the `random` module, you must first type `random.` in front of the function name to tell Python to look for this function inside the `random` module. We will discuss it more in the following chapter.\n\n> Check out the Python standard library [here](https://docs.python.org/3/library/index.html#library-index) or [here](https://pymotw.com/3/index.html)\n\n### Ending a Program Early with the `sys.exit()` Function\n\nThe last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the `sys.exit()` function. Since this function is in the `sys` module, you have to `import sys` before your program can use it.\n\nBy using expressions that evaluate to `True` or `False` (also called conditions), you can write programs that make decisions on what code to execute and what code to skip. You can also execute code over and over again in a loop while a certain condition evaluates to `True`. The `break` and `continue` statements are useful if you need to exit a loop or jump back to the loop’s start. These flow control statements will let you write more intelligent programs. You can also use another type of flow control by **writing your own functions**, which is the topic of the next chapter.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"02_Flow_control.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","theme":"cosmo","cover-image":"cover.jpg","title":"Flow Control","author":"phonchi","date":"02/24/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}