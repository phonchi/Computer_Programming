{"title":"Lists and Tuples","markdown":{"yaml":{"title":"Lists and Tuples","author":"phonchi","date":"03/10/2023","format":{"html":{"toc":true,"toc-depth":4,"code-line-numbers":true,"code-fold":true,"code-tools":true}}},"headingText":"List","containsRefs":false,"markdown":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/04_Lists_tuples.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/04_Lists_tuples.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n\nOne more topic you’ll need to understand before you can begin writing programs in earnest is the `list` data type and its cousin, the `tuple`. `Lists` and `tuples` can contain multiple values, which makes writing programs that handle large amounts of data easier. These data types are called ***containers***, meaning they are objects that “contain” other objects. They each have some important distinguishing properties and come with their own set of ***methods*** for interacting with objects of each type. `List` and `tuple` belong to ***sequence*** data types, which means they represent **ordered collections of items**. They share the same characteristic as `string` and the `range` object returned by `range()` function. Many of the capabilities shown in this chapter apply to all sequence types.\n\n> Checkout https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range for more details.\n\nIn a `string`, the values are characters; in a `list`, they can be any type. The values in a `list` are called ***elements*** or sometimes ***items***. Items are separated with commas.\n\n<center><img src=\"https://favtutor.com/resources/images/uploads/mceu_17814155811635490539182.png\" style=\"max-width: 75%;\"></center>\n<div align=\"center\"> source: https://favtutor.com/blogs/list-vs-dictionary </div>\n\nThere are several ways to create a new `list`; the simplest is to enclose the elements in square brackets (“[” and ”]”). A `list` that contains no elements is called an empty `list`; you can create one with empty brackets.\n\nThe first example is a list of four integers and the second is a list of four strings. \n\n### Getting Individual Values in a List with Indexes\n\nYou can reference a `list` item by writing the `list`’s name followed by the element’s ***index*** (that is, its position number) enclosed in square brackets (`[]`, known as the ***subscription operator*** or ***bracket operator***). Remember that the indices start at 0:\n\n**Note that the first index is 0**, the last index is one less than the size of the `list`; a `list` of four items has 3 as its last index.\n\nPython will give you an `IndexError` error message if you use an index that exceeds the number of values in your list value.\n\nThe elements of a `list` don’t have to be the same type. The following `list` contains a `string`, a `float`, an `integer`, and another `list`:\n\nThe values in these lists of lists can be accessed using multiple indexes:\n\nThe first index dictates which items in the outer `list` to use, and the second indicates the value within the inner `list`. If you only use one index like `spam[3]`, the program will print the entire list value at that index.\n\n#### Negative Indexes\n\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a `list`, the value -2 refers to the second-to-last index in a `list`, and so on.\n\n#### Getting a `List`’s Length with the `len()` Function\n\nThe `len()` function will return the number of values that are in a `list`, just like it can count the number of characters in a string.\n\n#### Getting a sublist from Another `List` with Slices\n\nJust as an index can get a single value from a `list`, a ***slice*** can get several values from a `list` as a **new list**. A slice is typed between square brackets, like an index, but has two integers separated by a colon. \n\n- `subjects[2]` is a list with an index.\n- `subjects[1:3]` is a list with a slice.\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new `list`.\n\nAs a shortcut, you can leave out one or both indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 or the beginning of the `list`. Leaving out the second index is the same as using the length of the `list`, which will slice to the end of the `list`.\n\nJust like `range()`, slicing has the optional third index that can be used to specify the step.  \n\n#### Changing Values in a `List` with Indexes\n\nUnlike `strings`, `lists` are ***mutable*** because you can reassign an item in a `list`. When the bracket operator appears on the left side of an assignment, it identifies the element of the `list` that will be assigned.\n\nThe first element of numbers, which used to be 123, is now 5.\n\nAll in all, you can think of a `list` as a relationship between indices and elements. This relationship is called a mapping; each index \"maps to\" one of the elements.\n\n### `List` Concatenation and `List` Replication\n\nLists can be concatenated and replicated just like strings. The `+` operator combines two lists to create a new `list` and the `*` operator can be used with a `list` and an integer value to replicate the `list`.\n\n#### Removing Values from Lists with `del` Statements\n\nThe `del` statement will delete values at an index in a `list`. All values in the `list` after the deleted value will be moved up one index.\n\n### `List` traversal\n\nIn Chapter 2, you have learned about using `for` loops to execute a block of code a certain number of times. Technically, a `for` loop repeats the code block once for each item in a sequence.\n\nThis is because the return value from `range(4)` is a sequence that Python considers similar to `[0, 1, 2, 3]`. The following program has the same output as the previous one:\n\nThis works well if you only need to read the elements of the `list`. But you need the indices that you want to write or update the elements. A common way to do that is to combine the functions `range()` and `len()`:\n\nA common `Python` technique is to use `range(len(someList))` with a `for` loop to iterate over the indexes of a list.\n\nThis loop traverses the list and prints each element. `len()` returns the number of elements in the list. `range()` returns a list of indices from `0` to `n − 1`, where `n` is the length of the list. Each time through the loop, `i` gets the index of the next element. This is handy since it will iterate through all the indexes, no matter how many items it contains.\n\n#### The `in` and `not in` Operators\n\nYou can determine whether an object is or isn’t in a `list` with the `in` and `not in` operators. These expressions will evaluate to a `Boolean` value.\n\n#### Using the `enumerate()` Function with Lists\n\nInstead of using the `range(len(someList))` technique with a `for` loop to obtain the integer index of the items in the `list`, you can call the `enumerate()` function instead. On each iteration of the loop, `enumerate()` will return two values: **the index of the item and the item itself.**\n\n#### Loop in Multiple `Lists` with `zip()`\n\nBuilt-in function `zip()` enables you to iterate over multiple sequences of data at the same time. The function receives as arguments any number of sequences and returns an iterator that produces `tuples` containing the elements at the same index in \neach.\n\nThe above snippet call `zip()` to produces the tuples `('Bob', 3.5)`, `('Sue', 4.0)` and `('Amanda', 3.75)` consisting of the elements at index 0, 1 and 2 of each `list`, respectively. Note that we unpack (which we will elaborate later on) each tuple into `name` and `gpa` and display them.\n\n### Methods of the `list`\n\nA ***method***, introduced in Chapter 1, is the same as a function, except it is \"called on\" an object. For example, if a `list` object were stored in `spam`, you would call the `index()` list method on that `list` like so: `spam.index('hello')`. The method part comes after the object, separated by a period.\n\nEach data type has its own set of methods. The `list` data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a `list`.\n\n#### Adding elements to `Lists` with the `append()` and `insert()` Methods\n\n`append()` adds a new element to the end of a `list`:\n\nThe previous `append()` method call adds the argument to the end of the `list`. The `insert()` method can insert an element at any index in the `list`. The first argument to `insert()` is the index for the new value, and the second argument is the new value to be inserted.\n\n> Notice that the code is `t.append('d')` and `t.insert(1, 'e')`, not `t = t.append('d')` and `t = t.insert(1, 'e')`. In fact, the return value of `append()` and `insert()` is `None`, so you definitely wouldn’t want to store this as the new variable value. Rather, the `list` is modified in-place. \n\nMethods belong to a single data type. The `append()` and `insert() `methods are `list` methods and can be called only on `list` object, not on other objects such as `strings` or `integers`. \n\n#### Adding all the elements of a `List` to the end of `List` with the `extend()` Methods\n\nUse `list` method `extend()` to add all the elements of another sequence to the end of a list:\n\n#### Removing elements from `Lists` with the `remove()` Method\n\nThe `remove()` method will pass the object to be removed from the `list` when it is called:\n\n> The `del` statement is good to use when you know the index of the element you want to remove from the `list`. The `remove()` method is useful when you know the element you want to remove from the list.\n\n#### Sorting the elements in a `List` with the `sort()` Method\n\nLists of numbers or lists of strings can be sorted with the `sort()` method:\n\nNote that `sort()` uses “ASCII order” rather than alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z.\n\nYou can also pass `True` for the `reverse` keyword argument to have `sort()` sort the values in reverse order.\n\n#### Searching an element in a `List` with the `index()` Method\n\n`List` objects have an `index()` method that accepts an argument, and if that argument exists in the list, the index of the argument is returned. If the argument isn’t in the `list`, then `Python` produces a `ValueError` error.\n\nWhen there are duplicates of the elements in the `list`, the index of its first appearance is returned.\n\n### Numerical functions for `list`\n\nThere are a number of built-in functions that can be used on `lists` that allow you to quickly look through a `list` without writing your own loops:\n\nCheck out [https://docs.python.org/3/tutorial/datastructures.html#more-on-lists](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) for more methods!\n\n### `List` Comprehensions\n\nConsider how you might make a `list` of the first 10 square numbers (that is, the square of each integer from 1 through 10).\n\nBut a ***list comprehension*** allows you to generate this same list in just one line of code. A list comprehension combines the `for` loop and the creation of new elements into one line, and automatically appends each new element!\n\nTo use this syntax\n\n- Begin with a descriptive name for the `list`, such as `squares`. \n- Next, open a set of square brackets and define the expression for the values you want to store in the new `list`. In this example, the expression is `value**2`\n- Then, write a `for` loop to generate the numbers you want to feed into the expression and close the square brackets. In this example, the `for` loop iterates value in `range(1, 11)`, which feeds the values 1 through 10 into the expression `value**2`. \n\nNote that no colon is used at the end of the `for` statement.\n\n> The syntax of list comprehension is similar to the set-builder notation. For instance, preivous example is similar to $\\{x^2 | x \\in \\{1,2,...,10\\}\\}$\n\nAnother common operation is filtering elements to select only those that match a condition. This typically produces a `list` with fewer elements than the data being filtered. To do this in a `list` comprehension, use the `if` clause. The following\nincludes in `list1` only the even values produced by the `for` clause:\n\n> ### Exercise 1: Bulls and Cows (or 1A2B) is a code-breaking game. The numerical version of the game is usually played with four digits. On a sheet of paper, the players each write a 4-digit secret number. The digits must all be different. Then, in turn, the players try to guess their opponent's number, which gives the number of matches. If the matching digits are in their right positions, they are \"bulls\" (A). If they are in different positions, they are \"cows\" (B). For example, if the secret number is 4271 and our guess is 1234, then we should get 1 bull and 2 cows. (The bull is \"2\", the cows are \"4\" and \"1\".). Please complete the following game design, that the computer will generate a 4-digit number, and we must write a function to read the user's 4-digit inputs and check the user's guess against the secret number. Finally, return the message XAXB to the user.\n\n<center><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d4/4digits_0.4_screenshot.png\"></center>\n<div align=\"center\"> source: https://en.wikipedia.org/wiki/Bulls_and_Cows </div>\n\n### Sequence Data Types\n\n`Lists` aren’t the only data types that represent ordered sequences of values. For example, `strings` and `lists` are similar if you consider a string to be a \"list\" of single text characters. The `Python` sequence data types include `lists`, `strings`, range objects returned by `range()`, and `tuples`. Many of the things you can do with `lists` can also be done with `strings` and other values of sequence types: indexing; slicing; and using them with for loops, with `len()`, and with the `in` and `not in` operators.\n\n### Mutable and Immutable Data Types\n\nBut `lists` and `strings` are different in an important way. A list object is a ***mutable*** data type: it can have elements added, removed, or changed. However, a string is ***immutable***: it cannot be changed. Trying to reassign a single character in a string results in a `TypeError` error:\n\n## Tuples\n\nA `tuple` is a sequence of values much like a `list`. The values stored in a `tuple` can be any type, and they are indexed by integers. The important difference is that `tuples` are ***immutable***.\n\n> It is similar to the tuple you encounter in math\n\nAlthough it is not necessary, it is common to enclose `tuples` in parentheses to help us quickly identify `tuples` when we look at `Python` code:\n\nTo create a `tuple` with a single element, you have to include the final comma or use the `tuple()` function:\n\nIf the argument of `tuple()` is a sequence (`string`, `list`, or `tuple`), the result is a `tuple` with the elements of the sequence:\n\nMost `list` operators also work on `tuples`. The bracket operator indexes an element:\n\nBut if you try to modify one of the elements of the `tuple`, you get an error:\n\nYou can use `tuples` to convey to anyone reading your code that you don’t intend for that sequence of values to change. Use a `tuple` if you need an ordered sequence of values that never changes.\n\n### Unpacking Sequences\n\nWe have seen the multiple assignment trick in the previous chapter (which is actually unpacking the `tuple`). In fact, you can unpack any sequence’s elements by assigning the sequence to a comma-separated list of variables.\n\nUnpacking is widely used to return multiple values in a function:\n\n## References\n\nTechnically, in `Python`, variables store ***references*** to the computer memory locations where the values are stored.\n\nWhen you assign 42 to the `spam` variable, you are actually creating the 42 value in the **computer’s memory and storing a reference (address)** to it in the `spam` variable. When you copy the value in `spam` and assign it to the variable `cheese`, you are actually copying the reference. Both the `spam` and `cheese` variables refer to the 42 value in the computer’s memory. When you later change the value in `spam` to 100, you’re creating a new 100 value and storing a reference to it in `spam`. This doesn’t affect the value in `cheese`. Integers are immutable values that don’t change; changing the `spam` variable is actually making it refer to a completely different value in memory. \n\nYou can use `id()` function to verify this behavior. In CPython (the most widely used implementation of Python), the identifier returned by `id()` is actually the memory address of the object, represented as a Python integer. All values in Python have a unique identity (address) that can be obtained with the `id()` function.\n\nBut `lists` don’t work this way, because `list` are mutable:\n\nUsing boxes as a metaphor for variables, the following shows what happens when a `list` is assigned to the `spam` variable.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000041.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\nThen, the reference in `spam` is copied to `cheese`. Only a new reference was created and stored in `cheese`, not a new `list`. Note how both references refer to the same `list`.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000132.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\nWhen you alter the `list` that `cheese` refers to, the `list` that `spam` refers to is also changed, because both `cheese` and `spam` refer to the same `list`.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000077.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\nYou may be wondering why the weird behavior with mutable `lists` in the previous section doesn’t happen with immutable values like `integers` or `strings`. Let us elaborate on this topics.\n\nLike `integer`, `'Hello'` is a `string` which is immutable and cannot be changed. If you \"change\" the `string` in a variable, a new `string` object is being made at a different place in memory, and the variable refers to this new `string`.\n\nHowever, `lists` can be modified because they are mutable objects. The `append()` method doesn’t create a new `list` object; it changes the existing `list` object. We call this **\"modifying the object in-place.\"**\n\nIf two variables refer to the same `list` (like `spam` and `cheese` in the previous section) and the `list` itself changes, both variables are affected because they both refer to the same `list`. The `append()`, `remove()`, `sort()`, `reverse()`, and other `list` methods modify their `lists` in place.\n\n> Python’s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don’t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\n### Passing References\n\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, **the values of the arguments are copied to the parameter variables**. For `lists` (and `dictionaries`, which we will describe in the next chapter), this means a **copy of the reference** is used for the parameter.\n\nNotice that when `eggs()` is called, a return value is not used to assign a new value to `spam`. Instead, it modifies the list in place directly. Even though `spam` and `someParameter` contain separate references, they both refer to the same `list`. This is why the `append('Hello')` method call inside the function affects the `list` even after the function call has returned.\n\nFor immutable types `string` and `integers`, we will create a new object in the function when we modify `someParameter`. Therefore, the original value will not be modified after the loop. \n\n### The `copy` Module’s `copy()` and `deepcopy()` Functions\n\n`Python` provides a module named `copy` that provides both the `copy()` and `deepcopy()` functions. `copy()`, can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference.\n\nNow the `spam` and `cheese` variables refer to separate `lists`, which is why only the list in `cheese` is modified when you assign 42 at index 1.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000025.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\n> If the list you need to copy contains another list, then use the `copy.deepcopy()` function instead of `copy.copy()`. The `deepcopy()` function will copy these inner lists as well.\n\n> ### Exercise 2: Here, we will simulate the process of a simple card game. The game is played with a standard deck of 52 cards, and we will randomly select 40 cards and divide them evenly between two players. Each player gets a hand of 20 cards. The goal of the game is to collect pairs of cards with the same rank (e.g., two aces, two kings, etc.). The player with the most pairs at the end of the game wins.\n\n<center><img src=\"https://media.discordapp.net/attachments/989268324884049960/1082974339126800424/phonchi_The_game_is_played_with_a_standard_deck_of_52_cards_whi_1833b828-f978-4a8d-adb7-a99ccee491be.png?width=630&height=630\"></center>\n\n`Lists` are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later on, you will see programs using `lists` to do things that would be difficult or impossible to do without them.\n\n`Lists` are a sequence data type that is mutable, meaning that their contents can change. `Tuples` and `strings`, though also sequence data types, are immutable and cannot be changed. A variable that contains a `tuple` or `string` value can be overwritten with a new `tuple` or `string` value, but this is not the same thing as modifying the existing value in place — like, say, the `append()` or `remove()` methods do on `lists`. Because `tuples` are immutable, they don’t provide methods like `sort()` and `reverse()`, which modify existing `lists`. However `Python` provides the built-in functions `sorted()` and `reversed()`, which take any sequence as a parameter and return a new sequence with the same elements in a different order.\n\nVariables do not store `list` objects directly; they store references to `lists`. This is an important distinction when you are copying variables or passing `lists` as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the `list` might impact another variable in your program. You can use `copy()` or `deepcopy()` if you want to make changes to a `list` in one variable without modifying the original `list`. It is noted that slicing also create a new `list` object.\n\n\n","srcMarkdownNoYaml":"\n\n<table align=\"left\">\n  <td>\n    <a href=\"https://colab.research.google.com/github/phonchi/nsysu-math106A/blob/master/static_files/presentations/04_Lists_tuples.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n  </td>\n  <td>\n    <a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://github.com/phonchi/nsysu-math106A/blob/master/static_files/presentations/04_Lists_tuples.ipynb\"><img src=\"https://kaggle.com/static/images/open-in-kaggle.svg\" /></a>\n  </td>\n</table>\n<br/>\n\n## List\n\nOne more topic you’ll need to understand before you can begin writing programs in earnest is the `list` data type and its cousin, the `tuple`. `Lists` and `tuples` can contain multiple values, which makes writing programs that handle large amounts of data easier. These data types are called ***containers***, meaning they are objects that “contain” other objects. They each have some important distinguishing properties and come with their own set of ***methods*** for interacting with objects of each type. `List` and `tuple` belong to ***sequence*** data types, which means they represent **ordered collections of items**. They share the same characteristic as `string` and the `range` object returned by `range()` function. Many of the capabilities shown in this chapter apply to all sequence types.\n\n> Checkout https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range for more details.\n\nIn a `string`, the values are characters; in a `list`, they can be any type. The values in a `list` are called ***elements*** or sometimes ***items***. Items are separated with commas.\n\n<center><img src=\"https://favtutor.com/resources/images/uploads/mceu_17814155811635490539182.png\" style=\"max-width: 75%;\"></center>\n<div align=\"center\"> source: https://favtutor.com/blogs/list-vs-dictionary </div>\n\nThere are several ways to create a new `list`; the simplest is to enclose the elements in square brackets (“[” and ”]”). A `list` that contains no elements is called an empty `list`; you can create one with empty brackets.\n\nThe first example is a list of four integers and the second is a list of four strings. \n\n### Getting Individual Values in a List with Indexes\n\nYou can reference a `list` item by writing the `list`’s name followed by the element’s ***index*** (that is, its position number) enclosed in square brackets (`[]`, known as the ***subscription operator*** or ***bracket operator***). Remember that the indices start at 0:\n\n**Note that the first index is 0**, the last index is one less than the size of the `list`; a `list` of four items has 3 as its last index.\n\nPython will give you an `IndexError` error message if you use an index that exceeds the number of values in your list value.\n\nThe elements of a `list` don’t have to be the same type. The following `list` contains a `string`, a `float`, an `integer`, and another `list`:\n\nThe values in these lists of lists can be accessed using multiple indexes:\n\nThe first index dictates which items in the outer `list` to use, and the second indicates the value within the inner `list`. If you only use one index like `spam[3]`, the program will print the entire list value at that index.\n\n#### Negative Indexes\n\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a `list`, the value -2 refers to the second-to-last index in a `list`, and so on.\n\n#### Getting a `List`’s Length with the `len()` Function\n\nThe `len()` function will return the number of values that are in a `list`, just like it can count the number of characters in a string.\n\n#### Getting a sublist from Another `List` with Slices\n\nJust as an index can get a single value from a `list`, a ***slice*** can get several values from a `list` as a **new list**. A slice is typed between square brackets, like an index, but has two integers separated by a colon. \n\n- `subjects[2]` is a list with an index.\n- `subjects[1:3]` is a list with a slice.\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new `list`.\n\nAs a shortcut, you can leave out one or both indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 or the beginning of the `list`. Leaving out the second index is the same as using the length of the `list`, which will slice to the end of the `list`.\n\nJust like `range()`, slicing has the optional third index that can be used to specify the step.  \n\n#### Changing Values in a `List` with Indexes\n\nUnlike `strings`, `lists` are ***mutable*** because you can reassign an item in a `list`. When the bracket operator appears on the left side of an assignment, it identifies the element of the `list` that will be assigned.\n\nThe first element of numbers, which used to be 123, is now 5.\n\nAll in all, you can think of a `list` as a relationship between indices and elements. This relationship is called a mapping; each index \"maps to\" one of the elements.\n\n### `List` Concatenation and `List` Replication\n\nLists can be concatenated and replicated just like strings. The `+` operator combines two lists to create a new `list` and the `*` operator can be used with a `list` and an integer value to replicate the `list`.\n\n#### Removing Values from Lists with `del` Statements\n\nThe `del` statement will delete values at an index in a `list`. All values in the `list` after the deleted value will be moved up one index.\n\n### `List` traversal\n\nIn Chapter 2, you have learned about using `for` loops to execute a block of code a certain number of times. Technically, a `for` loop repeats the code block once for each item in a sequence.\n\nThis is because the return value from `range(4)` is a sequence that Python considers similar to `[0, 1, 2, 3]`. The following program has the same output as the previous one:\n\nThis works well if you only need to read the elements of the `list`. But you need the indices that you want to write or update the elements. A common way to do that is to combine the functions `range()` and `len()`:\n\nA common `Python` technique is to use `range(len(someList))` with a `for` loop to iterate over the indexes of a list.\n\nThis loop traverses the list and prints each element. `len()` returns the number of elements in the list. `range()` returns a list of indices from `0` to `n − 1`, where `n` is the length of the list. Each time through the loop, `i` gets the index of the next element. This is handy since it will iterate through all the indexes, no matter how many items it contains.\n\n#### The `in` and `not in` Operators\n\nYou can determine whether an object is or isn’t in a `list` with the `in` and `not in` operators. These expressions will evaluate to a `Boolean` value.\n\n#### Using the `enumerate()` Function with Lists\n\nInstead of using the `range(len(someList))` technique with a `for` loop to obtain the integer index of the items in the `list`, you can call the `enumerate()` function instead. On each iteration of the loop, `enumerate()` will return two values: **the index of the item and the item itself.**\n\n#### Loop in Multiple `Lists` with `zip()`\n\nBuilt-in function `zip()` enables you to iterate over multiple sequences of data at the same time. The function receives as arguments any number of sequences and returns an iterator that produces `tuples` containing the elements at the same index in \neach.\n\nThe above snippet call `zip()` to produces the tuples `('Bob', 3.5)`, `('Sue', 4.0)` and `('Amanda', 3.75)` consisting of the elements at index 0, 1 and 2 of each `list`, respectively. Note that we unpack (which we will elaborate later on) each tuple into `name` and `gpa` and display them.\n\n### Methods of the `list`\n\nA ***method***, introduced in Chapter 1, is the same as a function, except it is \"called on\" an object. For example, if a `list` object were stored in `spam`, you would call the `index()` list method on that `list` like so: `spam.index('hello')`. The method part comes after the object, separated by a period.\n\nEach data type has its own set of methods. The `list` data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a `list`.\n\n#### Adding elements to `Lists` with the `append()` and `insert()` Methods\n\n`append()` adds a new element to the end of a `list`:\n\nThe previous `append()` method call adds the argument to the end of the `list`. The `insert()` method can insert an element at any index in the `list`. The first argument to `insert()` is the index for the new value, and the second argument is the new value to be inserted.\n\n> Notice that the code is `t.append('d')` and `t.insert(1, 'e')`, not `t = t.append('d')` and `t = t.insert(1, 'e')`. In fact, the return value of `append()` and `insert()` is `None`, so you definitely wouldn’t want to store this as the new variable value. Rather, the `list` is modified in-place. \n\nMethods belong to a single data type. The `append()` and `insert() `methods are `list` methods and can be called only on `list` object, not on other objects such as `strings` or `integers`. \n\n#### Adding all the elements of a `List` to the end of `List` with the `extend()` Methods\n\nUse `list` method `extend()` to add all the elements of another sequence to the end of a list:\n\n#### Removing elements from `Lists` with the `remove()` Method\n\nThe `remove()` method will pass the object to be removed from the `list` when it is called:\n\n> The `del` statement is good to use when you know the index of the element you want to remove from the `list`. The `remove()` method is useful when you know the element you want to remove from the list.\n\n#### Sorting the elements in a `List` with the `sort()` Method\n\nLists of numbers or lists of strings can be sorted with the `sort()` method:\n\nNote that `sort()` uses “ASCII order” rather than alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z.\n\nYou can also pass `True` for the `reverse` keyword argument to have `sort()` sort the values in reverse order.\n\n#### Searching an element in a `List` with the `index()` Method\n\n`List` objects have an `index()` method that accepts an argument, and if that argument exists in the list, the index of the argument is returned. If the argument isn’t in the `list`, then `Python` produces a `ValueError` error.\n\nWhen there are duplicates of the elements in the `list`, the index of its first appearance is returned.\n\n### Numerical functions for `list`\n\nThere are a number of built-in functions that can be used on `lists` that allow you to quickly look through a `list` without writing your own loops:\n\nCheck out [https://docs.python.org/3/tutorial/datastructures.html#more-on-lists](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) for more methods!\n\n### `List` Comprehensions\n\nConsider how you might make a `list` of the first 10 square numbers (that is, the square of each integer from 1 through 10).\n\nBut a ***list comprehension*** allows you to generate this same list in just one line of code. A list comprehension combines the `for` loop and the creation of new elements into one line, and automatically appends each new element!\n\nTo use this syntax\n\n- Begin with a descriptive name for the `list`, such as `squares`. \n- Next, open a set of square brackets and define the expression for the values you want to store in the new `list`. In this example, the expression is `value**2`\n- Then, write a `for` loop to generate the numbers you want to feed into the expression and close the square brackets. In this example, the `for` loop iterates value in `range(1, 11)`, which feeds the values 1 through 10 into the expression `value**2`. \n\nNote that no colon is used at the end of the `for` statement.\n\n> The syntax of list comprehension is similar to the set-builder notation. For instance, preivous example is similar to $\\{x^2 | x \\in \\{1,2,...,10\\}\\}$\n\nAnother common operation is filtering elements to select only those that match a condition. This typically produces a `list` with fewer elements than the data being filtered. To do this in a `list` comprehension, use the `if` clause. The following\nincludes in `list1` only the even values produced by the `for` clause:\n\n> ### Exercise 1: Bulls and Cows (or 1A2B) is a code-breaking game. The numerical version of the game is usually played with four digits. On a sheet of paper, the players each write a 4-digit secret number. The digits must all be different. Then, in turn, the players try to guess their opponent's number, which gives the number of matches. If the matching digits are in their right positions, they are \"bulls\" (A). If they are in different positions, they are \"cows\" (B). For example, if the secret number is 4271 and our guess is 1234, then we should get 1 bull and 2 cows. (The bull is \"2\", the cows are \"4\" and \"1\".). Please complete the following game design, that the computer will generate a 4-digit number, and we must write a function to read the user's 4-digit inputs and check the user's guess against the secret number. Finally, return the message XAXB to the user.\n\n<center><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d4/4digits_0.4_screenshot.png\"></center>\n<div align=\"center\"> source: https://en.wikipedia.org/wiki/Bulls_and_Cows </div>\n\n### Sequence Data Types\n\n`Lists` aren’t the only data types that represent ordered sequences of values. For example, `strings` and `lists` are similar if you consider a string to be a \"list\" of single text characters. The `Python` sequence data types include `lists`, `strings`, range objects returned by `range()`, and `tuples`. Many of the things you can do with `lists` can also be done with `strings` and other values of sequence types: indexing; slicing; and using them with for loops, with `len()`, and with the `in` and `not in` operators.\n\n### Mutable and Immutable Data Types\n\nBut `lists` and `strings` are different in an important way. A list object is a ***mutable*** data type: it can have elements added, removed, or changed. However, a string is ***immutable***: it cannot be changed. Trying to reassign a single character in a string results in a `TypeError` error:\n\n## Tuples\n\nA `tuple` is a sequence of values much like a `list`. The values stored in a `tuple` can be any type, and they are indexed by integers. The important difference is that `tuples` are ***immutable***.\n\n> It is similar to the tuple you encounter in math\n\nAlthough it is not necessary, it is common to enclose `tuples` in parentheses to help us quickly identify `tuples` when we look at `Python` code:\n\nTo create a `tuple` with a single element, you have to include the final comma or use the `tuple()` function:\n\nIf the argument of `tuple()` is a sequence (`string`, `list`, or `tuple`), the result is a `tuple` with the elements of the sequence:\n\nMost `list` operators also work on `tuples`. The bracket operator indexes an element:\n\nBut if you try to modify one of the elements of the `tuple`, you get an error:\n\nYou can use `tuples` to convey to anyone reading your code that you don’t intend for that sequence of values to change. Use a `tuple` if you need an ordered sequence of values that never changes.\n\n### Unpacking Sequences\n\nWe have seen the multiple assignment trick in the previous chapter (which is actually unpacking the `tuple`). In fact, you can unpack any sequence’s elements by assigning the sequence to a comma-separated list of variables.\n\nUnpacking is widely used to return multiple values in a function:\n\n## References\n\nTechnically, in `Python`, variables store ***references*** to the computer memory locations where the values are stored.\n\nWhen you assign 42 to the `spam` variable, you are actually creating the 42 value in the **computer’s memory and storing a reference (address)** to it in the `spam` variable. When you copy the value in `spam` and assign it to the variable `cheese`, you are actually copying the reference. Both the `spam` and `cheese` variables refer to the 42 value in the computer’s memory. When you later change the value in `spam` to 100, you’re creating a new 100 value and storing a reference to it in `spam`. This doesn’t affect the value in `cheese`. Integers are immutable values that don’t change; changing the `spam` variable is actually making it refer to a completely different value in memory. \n\nYou can use `id()` function to verify this behavior. In CPython (the most widely used implementation of Python), the identifier returned by `id()` is actually the memory address of the object, represented as a Python integer. All values in Python have a unique identity (address) that can be obtained with the `id()` function.\n\nBut `lists` don’t work this way, because `list` are mutable:\n\nUsing boxes as a metaphor for variables, the following shows what happens when a `list` is assigned to the `spam` variable.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000041.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\nThen, the reference in `spam` is copied to `cheese`. Only a new reference was created and stored in `cheese`, not a new `list`. Note how both references refer to the same `list`.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000132.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\nWhen you alter the `list` that `cheese` refers to, the `list` that `spam` refers to is also changed, because both `cheese` and `spam` refer to the same `list`.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000077.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\nYou may be wondering why the weird behavior with mutable `lists` in the previous section doesn’t happen with immutable values like `integers` or `strings`. Let us elaborate on this topics.\n\nLike `integer`, `'Hello'` is a `string` which is immutable and cannot be changed. If you \"change\" the `string` in a variable, a new `string` object is being made at a different place in memory, and the variable refers to this new `string`.\n\nHowever, `lists` can be modified because they are mutable objects. The `append()` method doesn’t create a new `list` object; it changes the existing `list` object. We call this **\"modifying the object in-place.\"**\n\nIf two variables refer to the same `list` (like `spam` and `cheese` in the previous section) and the `list` itself changes, both variables are affected because they both refer to the same `list`. The `append()`, `remove()`, `sort()`, `reverse()`, and other `list` methods modify their `lists` in place.\n\n> Python’s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don’t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\n### Passing References\n\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, **the values of the arguments are copied to the parameter variables**. For `lists` (and `dictionaries`, which we will describe in the next chapter), this means a **copy of the reference** is used for the parameter.\n\nNotice that when `eggs()` is called, a return value is not used to assign a new value to `spam`. Instead, it modifies the list in place directly. Even though `spam` and `someParameter` contain separate references, they both refer to the same `list`. This is why the `append('Hello')` method call inside the function affects the `list` even after the function call has returned.\n\nFor immutable types `string` and `integers`, we will create a new object in the function when we modify `someParameter`. Therefore, the original value will not be modified after the loop. \n\n### The `copy` Module’s `copy()` and `deepcopy()` Functions\n\n`Python` provides a module named `copy` that provides both the `copy()` and `deepcopy()` functions. `copy()`, can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference.\n\nNow the `spam` and `cheese` variables refer to separate `lists`, which is why only the list in `cheese` is modified when you assign 42 at index 1.\n\n<center><img src=\"https://automatetheboringstuff.com/2e/images/000025.jpg\"></center>\n<div align=\"center\"> source: https://automatetheboringstuff.com/2e/chapter4/ </div>\n\n> If the list you need to copy contains another list, then use the `copy.deepcopy()` function instead of `copy.copy()`. The `deepcopy()` function will copy these inner lists as well.\n\n> ### Exercise 2: Here, we will simulate the process of a simple card game. The game is played with a standard deck of 52 cards, and we will randomly select 40 cards and divide them evenly between two players. Each player gets a hand of 20 cards. The goal of the game is to collect pairs of cards with the same rank (e.g., two aces, two kings, etc.). The player with the most pairs at the end of the game wins.\n\n<center><img src=\"https://media.discordapp.net/attachments/989268324884049960/1082974339126800424/phonchi_The_game_is_played_with_a_standard_deck_of_52_cards_whi_1833b828-f978-4a8d-adb7-a99ccee491be.png?width=630&height=630\"></center>\n\n`Lists` are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later on, you will see programs using `lists` to do things that would be difficult or impossible to do without them.\n\n`Lists` are a sequence data type that is mutable, meaning that their contents can change. `Tuples` and `strings`, though also sequence data types, are immutable and cannot be changed. A variable that contains a `tuple` or `string` value can be overwritten with a new `tuple` or `string` value, but this is not the same thing as modifying the existing value in place — like, say, the `append()` or `remove()` methods do on `lists`. Because `tuples` are immutable, they don’t provide methods like `sort()` and `reverse()`, which modify existing `lists`. However `Python` provides the built-in functions `sorted()` and `reversed()`, which take any sequence as a parameter and return a new sequence with the same elements in a different order.\n\nVariables do not store `list` objects directly; they store references to `lists`. This is an important distinction when you are copying variables or passing `lists` as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the `list` might impact another variable in your program. You can use `copy()` or `deepcopy()` if you want to make changes to a `list` in one variable without modifying the original `list`. It is noted that slicing also create a new `list` object.\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"04_Lists_tuples.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","theme":"cosmo","title":"Lists and Tuples","author":"phonchi","date":"03/10/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}