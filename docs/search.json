[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer Programming",
    "section": "",
    "text": "Preface\nThis is the companion book for the course computer programming open in the Department of Applied Mathematics, National Sun Yat-sen University. It aims for students who need a basic understanding of procedural programming and object-oriented programming concepts using Python 3. We will have hands-on exercises and quizzes to help you get familiar with each topic, and students will exercise logical thinking and programming skills for dealing with scientific problems.\nThe book is based on several well-known books and resources, including:\n\nAutomate the Boring Stuff with Python, 2nd Edition\nBeyond the Basic Stuff with Python\nScipy Lecture Notes"
  },
  {
    "objectID": "01_Python.html#introduction",
    "href": "01_Python.html#introduction",
    "title": "1  Python Basics",
    "section": "1.1 Introduction",
    "text": "1.1 Introduction\nA programming language is a computer system created to allow humans to precisely express algorithms to the computer using a higher level of abstraction. Python is one of the top ten most-used languages, and remains popular in developing web applications, in scientific computation, and as an introductory language for students. Organizations that use Python range from Google to NASA, DropBox to Industrial Light & Magic, and across the spectrum of casual, scientific, and artistic computer users.\nPython emphasizes readability, and includes elements of the imperative, object-oriented, and functional programming paradigms, which will be explored later on. Python is an interpreted language, which for beginners means that Python instructions can be typed into an interactive prompt, or can be stored in a plain text file (called a “script”) and run later. These instructions are evaluated and the commands are executed by the Python interpreter in something called the shell.\n\n1.1.1 Hello, Python\nA command, often called a statement, instructs the interpreter to do something. The first program described in many programming Language introductions is “Hello, World”. This simple program outputs a nominal greeting, demonstrating how a particular language produces a result, and also how a language represents text.\n\nprint('Hello, World!')\n\nHello, World!\n\n\nThere are several aspects to note even in this simple Python statement. * First, print() is a built-in function, a pre-defined operation that Python can use to produce output, a result of the program that will be made visible to the user. The print is followed by opening and closing parentheses; what comes between those parentheses is the value or arguments to be printed.\n\nSecond, fixed values such as numbers, letters, and strings, are called constants or simple data type because their value does not change. String constants use single quotes ' or double quotes \" in Python. The quotation marks in front of the capital 'H' and after the exclamation point denotes the beginning and end of a string of characters that will be treated as a value in Python.\n\nProgramming languages carry out their instructions very precisely. If a user makes subtle changes to the message between the starting and finishing quotation marks within the print statement, the resultant printed text will change accordingly. Notice that it is possible for statements to span more than one line using \\ .\n\nprint('Hello,\\\n World')\n\nHello, World\n\n\n\nIn Jupyter Notebook, the print function can even be omitted if the statement you want to print is the last statement in the code.\n\n\n'hi python'\n'Hello, World!'\n\n'Hello, World!'\n\n\n\n1.1.1.1 Using string methods like a word processor\nOne of the simplest tasks you can do with strings is to change the case of the words in a string.\n\nprint('hi python'.title())\n\n'Hi Python'\n\n\nIn this example, we have the lowercase string ‘hi python’. The method title() appears after the string in the print() call. A method is an action that Python can perform on a piece of data. The dot (.) after the string tells Python to make the title() method act on the string. Every method is followed by a set of parentheses that can accept arguments just like a function.\nThere are also other useful methods for string\n\nprint('hi python'.upper())   # change a string to all uppercase \nprint('Hello World'.lower()) # change a string to all lowercase \nprint(' hi python '.strip()) # remove extra whitespace on the right and left sides of a string\n\nHI PYTHON\nhello world\nhi python\n\n\nThese example statements introduce another language feature. The # symbol denotes the beginning of a comment, a human-readable notation to the Python code that will be ignored by the computer when executed. A high-level description at the top of a script introduces a human reader to the overall purpose and methodology used in the script. All of the characters to the right of the # until the end of the line are ignored by Python.\n\n1.1.2 Exercise 1: Complete the following items to make sure you correctly set up the environment.\n\nOpen the explorer on the left-hand side\nConnect to the Python environment\nCreate a new code cell below and write a code snippet that prints out “finish”. Execute the cell.\nCreate a new script called “finish.py” and write a code snippet that prints out “finish”. Execute the script.\n\n\n\n\n\n1.1.3 Operators and Expressions\nBesides string, numbers are often used in programming. Python’s built-in operators allow numeric values to be manipulated and combined in a variety of familiar ways. Note that in Python, 2 + 3 is called an expression, which consists of values/operands (such as 2 or 3) and operators (such as +), and they are special statements! An expression is a combination of operators and operands that is interpreted to produce some other value.\n\n1.1.3.1 Using operand like a calculator\n\n# Integer\nprint(3+4)       # Prints “7”, which is 3 plus 4.\nprint(5-6)       # Prints “-1”, which is 5 minus 6\nprint(7*8)       # Prints “56”, which is 7 times 8\nprint(45/4)      # Prints “11.25”, which is 45 divided by 4, / is float(true) division\nprint(2**10)     # Prints “1024”, which is 2 to the 10th power\n\n7\n-1\n56\n11.25\n1024\n\n\n\nNote that we used ** to signify exponentiation, which can be somewhat surprising given that the caret symbol, ^, is often used for this purpose in some other programming languages. In Python, the caret operator belongs to XOR bitwise Boolean operations.\n\nWhen an operation such as forty-five divided by four produces a non-integer result, such as 11.25, Python implicitly switches to a floating-point representation. When purely integer answers are desired, a different set of operators can be used.\n\nprint(45//4)     # Prints “11”, which is 45 integer divided by 4, // is floor(integer) division\nprint(45%4)      # Prints “1”, because 4 * 11 + 1 = 45\n\n11\n1\n\n\nThe double slash signifies the integer floor division operator, while the percentage symbol signifies the modulus, or remainder operator. Taken together, we can read these calculations as, “Four goes into forty-five eleven times, with a remainder of one.”\nString values also can be combined and manipulated in some intuitive ways.\n\ns = 'hello' + 'world'\nt = s * 4\nprint(t)    # Prints “helloworldhelloworldhelloworldhelloworld”\n\nhelloworldhelloworldhelloworldhelloworld\n\n\nThe plus operator concatenates string values, while the multiplication operator replicates string values."
  },
  {
    "objectID": "01_Python.html#variables",
    "href": "01_Python.html#variables",
    "title": "1  Python Basics",
    "section": "1.2 Variables",
    "text": "1.2 Variables\nA variable is like a box in the computer’s memory where you can store value. If you want to use the result of an evaluated expression later in your program, you can save it inside a variable. You’ll store values in variables with an assignment statement. An assignment statement consists of a variable name, an equal sign, and the value to be stored. In Python, every single thing is stored as an object. A Python variable is actually a reference to an object!\n\n\n\n\nsource: https://runestone.academy/ns/books/published/cpp4python/AtomicData/AtomicData.html\n\n\nvarName = 100\n\nA variable is initialized (or created) the first time a value is stored in it. After that, you can use it in statements with other variables and values. When a variable is assigned a new value, the old value is forgotten. This is called overwriting the variable.\n\nspam = 'Hello'   # 'Hello' is a string object\nprint(spam)      # spam is a variable, it is just a reference or tag\nspam = 'Goodbye' # 'Goodbye' is another string object\nprint(spam)\n\nHello\nGoodbye\n\n\n\nIt’s much better to think of variables as labels that you can assign to values. You can also say that a variable references a certain value.\n\nThe naming of variables is largely up to the user in Python. Python’s simple rules are that variable names must begin with an alphabet letter or the underscore character, and may consist of an arbitrary number of letters, digits, and the underscore character (A-z, 0-9, and _ ). While a variable named m may be sufficient for a two line example script, experienced programmers strive to give meaningful, descriptive variable names in their scripts.\n\n\n\n\n\n\n\nValid variable names\nInvalid variable names\n\n\n\n\ncurrent_balance\ncurrent-balance (hyphens are not allowed)\n\n\ncurrentBalance\ncurrent balance (spaces are not allowed)\n\n\naccount4\n4account (can’t begin with a number)\n\n\n_42\n42 (can’t begin with a number)\n\n\nTOTAL_SUM\nTOTAL_$UM (special characters like $ are not allowed)\n\n\nhello\n‘hello’ (special characters like ’ are not allowed)\n\n\n\nPython variable names are case-sensitive, meaning that capitalization matters. A variable named size is treated as distinct from variables named Size or SIZE. A small number of keywords, names that are reserved for special meaning in Python, cannot be used as variable names. You can view this list by accessing the built-in Python help system.\n\nhelp('keywords')\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nVariables can be used to store all of the types of data values that Python is able to represent.\n\nmy_string = 'characters'\nmy_Boolean = True # True/False\nmy_integer = 5\nmy_floating_point = 26.2\nmy_complex = 2+1j # Note that 1 can not be omitted\n\n# You can condense the above statements into one line separated by ;\nmy_string = 'characters'; my_Boolean = True; my_integer = 5; my_floating_point = 26.2; my_complex = 2+1j\n\n\n### Multiple Assignment!\n# You can also assign values to more than one variable using just a single line of code!\nmy_string, my_Boolean, my_integer, my_floating_point, my_complex = 'characters',  True, 5, 26.2, 2+1j\n\n\nprint(10)\nprint(3.14)\nprint(2e10)   # scientific notation\nprint(12_000) # you can group digits using underscores to make large numbers more readable\nprint(3+2j)\n\n10\n3.14\n20000000000.0\n12000\n(3+2j)\n\n\nNote that when you’re writing long numbers, you can group digits using underscores to make large numbers more readable. In addition, print() can be used to print any numerical number including those in scientific notation.\n\n1.2.1 Data types\nIn Python variables and constants have a type. We can ask Python what type something is by using the type() function\n\ntype('Hello, World!'), type(False), type(4), type(3.2), type(3+5j)\n\n(str, bool, int, float, complex)\n\n\n\ntype(my_string),  type(my_Boolean), type(my_integer), type(my_floating_point), type(my_complex)\n\n(str, bool, int, float, complex)\n\n\nYou can convert object of one type to another using cast by str(), float(), int(), etc.\n\nfloat(3)\n\n3.0\n\n\n\nint(3.9)\n\n3\n\n\n\nint('3')\n\n3\n\n\n\nstr(3)\n\n'3'\n\n\nPython ord() and chr() are built-in functions. They are used to convert a character to an int and vice versa. Python ord() and chr() functions are exactly opposite of each other.\nPython ord() function takes string argument of a single Unicode character and return its integer Unicode code point value. Let’s look at some examples of using ord() function.\n\nx = ord('A')\nprint(x)\n\n65\n\n\nPython chr() function takes integer argument and return the string representing a character at that code point.\n\ny = chr(65)\nprint(y)\n\nA\n\n\n\n1.2.1.1 Conversion\nThere are two types of type conversion in Python.\n\nImplicit Conversion - automatic type conversion. Python always converts smaller data types to larger data types to avoid the loss of data.\nExplicit Conversion - manual type conversion\n\n\n5 + 4.2 # Implicit conversion\n\n9.2\n\n\nIn Python, complex &gt; float &gt; int &gt; bool\n\nint(4.7) + 3 # Explicit conversion\n\n7\n\n\n\n\n\n1.2.2 Debugging\nProgramming languages are not very forgiving for beginners, and a great deal of time learning to write software can be spent trying to find bugs, or errors in the code. Locating such bugs and correcting them is thus known as debugging. There are three major classes of bug that we create in software: syntax errors (mistakes in the symbols that have been typed), semantic errors (mistakes in the meaning of the program), and runtime errors (mistakes that occur when the program is executed.)\nSyntax errors are the most common for novices, and include simple errors such as forgetting one of the quote marks at the beginning or ending of a text string, failing to close open parentheses, or misspelling the function name print(). The Python interpreter will generally try to point these errors out when it encounters them, displaying an offending line number and a description of the problem. With some practice, a beginner can quickly learn to recognize and interpret common error cases. As examples:\n\nprint(5 + )\n\nSyntaxError: invalid syntax (Temp/ipykernel_24072/2298961889.py, line 1)\n\n\nThis expression is missing a value between the addition operator and the closing parenthesis.\n\nprint(mystring)\n\nNameError: name 'mystring' is not defined\n\n\nIn this case it found a name error and reports that the variable being printed has not been defined. Python can’t identify the variable name provided.\n\npront(5)\n\nNameError: name 'pront' is not defined\n\n\nLike calling someone by the wrong name, misspelling the name of a known function or variable can result in confusion and embarrassment.\nSemantic errors are flaws in the algorithm, or flaws in the way the algorithm is expressed in a language. Examples might include using the wrong variable name in a calculation, or getting the order of arithmetic operations wrong in a complex expression. Python follows the standard rules for operator precedence, so in an expression like total_pay = 40 + extra_hours * pay_rate, the multiplication will be performed before the addition, incorrectly calculating the total pay. (Unless your pay rate happens to be $1/hour.) Use parenthesis to properly specify the order of operations in complex expressions, thereby avoiding both semantic errors and code that may be harder to understand (e.g., total_pay = (40 + extra_hours) * pay_rate).\nFinally, runtime errors at this level might include unintentionally dividing by zero or using a variable before you have defined it. Python reads statements from top to bottom, and it must see an assignment statement to a variable before that variable is used in an expression.\n\n5/0\n\nZeroDivisionError: division by zero"
  },
  {
    "objectID": "01_Python.html#the-first-program",
    "href": "01_Python.html#the-first-program",
    "title": "1  Python Basics",
    "section": "1.3 The first program",
    "text": "1.3 The first program\nWhile the interactive shell is good for running Python instructions one at a time, sometimes you have to use a script, to write entire Python programs. In this case, you’ll type the instructions into the file editor.\n\n%%writefile hello.py\n\"\"\"\nThis program says hello and asks for your name.\nIt also ask the age of you.\n\"\"\"\n\nprint('Hello, world!')\nmyName = input('What is your name? ') # ask for their name\nprint('It is good to meet you, ' + myName)\nprint('The length of your name is:\\n' + str(len(myName)))\nmyAge = input('What is your age? ') # ask for their age\nprint('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nWriting hello.py\n\n\nOnce you’ve entered your source code, the ipython magic %%writefile will save it so that you won’t have to retype it each time you start. You can then use another magic %run to execute the python script.\n\n%run hello.py\n\nHello, world!\nIt is good to meet you, phonchi\nThe length of your name is:\n7\nYou will be 33 in a year.\n\n\n\n1.3.1 Dissecting Your Program\nWith your new program open in the file editor, let’s take a quick tour of the Python instructions it uses by looking at what each line of code does.\n\nThe first line is the comment that tells others your intention of this program or the authorship of the program. Here it uses the multiline comment by using the triple quotes. The line print('Hello, world!') means “Print out the text in the string ‘Hello, world!’.” When Python executes this line, you say that Python is calling the print() function and the string value is being passed to the function. A value that is passed to a function call is an argument. When you write a function name, the opening and closing parentheses at the end identify it as the name of a function.\nThe input() function waits for the user to type some text on the keyboard and press ENTER. The myName = input() function call evaluates to a string equal to the user’s text, and the line of code assigns the myName variable to this string value.\nThe following call to print('It is good to meet you, ' + myName) is an expression. 'It is good to meet you, ' and myName between the parentheses are concatenated together via the operand + and printed out.\nYou can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string. If you want to concatenate an integer such as 29 with a string to pass to print(), you’ll need to get the value ‘29’, which is the string form of 29. The str() function can be passed an integer value and will evaluate to a string value version of the integer. Besides, there is a \\n in the statement print('The length of your name is:\\n' + str(len(myName))). The string starts with the backslash has a special escape meaning and \\n means adding a newline.\nThe int() function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. The myAge variable contains the value returned from input(). You can use the int(myAge) code to return an integer value of the string in myAge. This integer value is then added to 1 in the expression int(myAge) + 1. The result of this addition is passed to the str() function: str(int(myAge) + 1). The string value returned is then concatenated with the strings 'You will be ' and ' in a year.' to evaluate one large string value. This large string is finally passed to print() to be displayed on the screen.\n\n\n1.3.2 Exercise 2: Write a script that inputs a five-digit integer from the user. Separate the number into its individual digits. Print them separated by three spaces each. For example, if the user types in the number 42339, the script should print 4 \\(~~\\) 2 \\(~~\\) 3 \\(~~\\) 3 \\(~~\\) 9\n\nHint: Use floor division (//) and remainder (%) to isolate the digits.\n\n# Your answer here\n# x=42339\n# Get the user's input from their keyboard and convert it to integer:\nx = _____('Enter a 5 digit integer')\n# Get the last digit by remainder\ndigits4 = \n# Perform floor division and get the remainig digits\nx = \n#....\n\n# Print out the results\n____(digits0,'   ',digits1,'   ',digits2,'   ',digits3,'   ',digits4)\n\n4     2     3     3     9"
  },
  {
    "objectID": "01_Python.html#the-zen-of-python",
    "href": "01_Python.html#the-zen-of-python",
    "title": "1  Python Basics",
    "section": "1.4 The zen of Python",
    "text": "1.4 The zen of Python\n\nimport this\n\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\n\nYou can compute expressions with a calculator or enter string concatenations with a word processor. You can even do string replication easily by copying and pasting text. But once you know how to handle the programing elements, you will be able to instruct Python to operate on large amounts of data automatically for you to replace these tasks.\nDon’t try to write perfect code; write code that works, and then decide whether to improve your code for that project or move on to something new. But as you continue to the next chapters and start digging into more involved topics, try to keep this philosophy of simplicity and clarity in mind.\n\nYou can also refer PEP8 which is a reference document that provides guidelines and best practices on how to write Python code."
  },
  {
    "objectID": "02_Flow_control.html#introduction",
    "href": "02_Flow_control.html#introduction",
    "title": "2  Flow Control",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nLast week, we learned the basics of individual instructions and that a program is just a series of instructions. But programming’s real strength isn’t just running one instruction after another. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you rarely want your programs to start from the first line of code and simply execute every line straight to the end. Flow control statements can decide which Python instructions to execute under which conditions.\nThese flow control statements directly correspond to the symbols in a flowchart. A flowchart usually has more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps (states) are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\n\n\nBut before you learn about flow control statements, you first need to learn how to represent those yes and no options and understand how to write those branching points as Python code. To that end, let’s explore Boolean values, comparison operators, and Boolean operators.\n\n2.1.1 Boolean expressions\nA boolean expression is an expression that is either true or false. The following examples use the operator ==, which compares two operands and produces True if they are equal and False otherwise:\n\n5 == 5, 5 == 6\n\nTrue and False are special values that belong to the class bool; they are not strings:\n\ntype(True), type(False)\n\nThe == operator is one of the comparison operators or relational operators; the others are:\n\n\n\n\nMeaning\n\n\n\n\nx != y\nx is not equal to y\n\n\nx &gt; y\nx is greater than y\n\n\nx &lt; y\nx is less than y\n\n\nx &gt;= y\nx is greater than or equal to y\n\n\nx &lt;= y\nx is less than or equal to y\n\n\nx is y\nx is the same as y\n\n\nx is not y\nx is not the same as y\n\n\n\n\nThe Python symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign = instead of a double equal sign ==. Remember that = is used in the assignment statement and == is a comparison operator. There is no such thing as =&lt; or =&gt;.\n\nThese operators evaluate to True or False depending on the values you give them and, therefore, can be used in the decision point as a condition statement.\n\nprint(42==42)\nprint(42==42.0)         # It will compare its value!\nprint(42=='42')         # int/float are always different from string\nprint(2!=3)\nprint('hello'=='Hello') # Python is case sensitive\nprint(42 &lt; 100)\nprint(42 &gt;= 100)\n\n\n\n2.1.2 Boolean (Logical) Operators\nThe three Boolean operators (and, or, and not) are used to operate on Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let’s explore these operators in detail.\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nTrue and True\nTrue\n\n\nTrue and False\nFalse\n\n\nFalse and True\nFalse\n\n\nFalse and False\nFalse\n\n\n\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nTrue or True\nTrue\n\n\nTrue or False\nTrue\n\n\nFalse or True\nTrue\n\n\nFalse or False\nFalse\n\n\n\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nnot True\nFalse\n\n\nnot False\nTrue\n\n\n\n\nprint((4 &lt; 5) and (5 &lt; 6))\nprint((6 &lt; 5) or (9 &lt; 6))\nprint((1 == 2) or (2 == 2))\nprint(not (1==3) and (3==4))\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. The Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the not operators first, then the and operators, and then the or operators."
  },
  {
    "objectID": "02_Flow_control.html#elements-of-flow-control",
    "href": "02_Flow_control.html#elements-of-flow-control",
    "title": "2  Flow Control",
    "section": "2.2 Elements of Flow Control",
    "text": "2.2 Elements of Flow Control\nIt can be shown that all programs could be written using three forms of control—namely, sequential execution, the selection statement and the repetition statement. This is the idea behind structured programming.\nFlow control statements often start with a part called the condition and are always followed by a block of code called the clause or body. The Boolean expressions you’ve seen so far could all be considered conditions, which are the same thing as expressions; the condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False. A flow control statement decides what to do based on whether its condition is True or False.\n\n2.2.1 Blocks of Code\nLines of Python code can be grouped together in blocks. You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.\n\nBlocks begin when the indentation increases.\nBlocks can contain other blocks.\nBlocks end when the indentation decreases to zero or to a containing block’s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let’s find the blocks in part of a small game program, shown here:\n\nname = 'Mary'\npassword = 'swordfish'\nif name == 'Mary':\n    print('Hello, Mary')\n    if password == 'swordfish':\n        print('Access granted.')\n    else:\n        print('Wrong password.')\n\nYou can view the execution of this program at https://autbor.com/blocks/. The first block of code starts at the line print('Hello, Mary') and contains all the lines after it. Inside this block is another block, which has only a single line in it: print('Access Granted.'). The third block is also one line long: print('Wrong password.').\nAn IndentationError occurs if you have more than one statement in a block and those statements do not have the same indentation:\n\nname = 'Mary'\npassword = 'swordfish'\nif name == 'Mary':\n  print('Hello, Mary')\n    if password == 'swordfish':\n        print('Access granted.')\n    else:\n        print('Wrong password.')\n\n\nIt is recomend to use four white spaces as the indentation\n\n\n\n2.2.2 Conditional execution\nThe control statement affords us a mechanism for jumping from one part of a program to another. In higher-level languages like Python, this enables what is called control structures, syntax patterns that allow us to express algorithms more succinctly. One example of this is the if-statement. An if statement’s body (that is, the block following the if statement) will execute if the statement’s condition is True. The body is skipped if the condition is False.\nIn Python, an if statement consists of the following:\n\nThe if keyword\nA condition (that is, an expression that evaluates to True or False)\nA colon\nStarting on the next line, an indented block of code (called the if body)\n\nThe boolean expression after the if statement is called the condition. We end the if statement with a colon character (:) and the line(s) after the if statement are indented. If the logical condition is true, then the indented statement gets executed. If the logical condition is false, the indented statement is skipped.\n\nname = 'Mary'\nif name == 'Alice':\n    print('Hi, Alice.')\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nA second form of the if statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:\n\nif name == 'Alice':\n    print('Hi, Alice.')\nelse:\n    print('Hello, stranger.')\n\nYou can also write the above code in one line using the ternary conditional operator:\n\nprint('Hi, Alice.') if name == 'Alice' else print('Hello, stranger.') # Note that we do not have colon in between!\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nSince the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution.\nSometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:\n\nname = 'Carol'\nage = 3000\nif name == 'Alice':\n    print('Hi, Alice.')\nelif age &lt; 12:\n    print('You are not Alice, kidd.')\nelse:\n    print('You are neither Alice nor a little kid.')\n\nYou can view the execution of this program at https://autbor.com/littlekid/. In plain English, this type of flow control structure would be “If the first condition is true, do this. Else, if the second condition is true, do that.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\n\n2.2.3 Exercise 1: Write a code that allows the user to input row and column. The program prints ‘black’ or ‘white’ depending on the color of the specified row and column of the chessboard. Chess boards are 8 x 8 spaces in size, and the rows and columns in this program begin at 0 and end at 7. If the inputs for a row or column are outside the 0 to 7 range, it should print ‘out of board’!\n\n\n\n\n\nsource: https://inventwithpython.com/pythongently/images/image011.png\n\n\nrow = int(input(\"Enter row\"))\ncolumn = int(input(\"Enter column\"))\n# If the column and row is out of bounds, print out of board:\nif column ____ or column ___ or row ___ or row ____:\n    print('out of board')\n# If the even/oddness of the column and row match, print 'white':\n____ column % _ == row % _:\n    print('white')\n# If they don't match, then print 'black':\n____:\n    print('black')\n\n\n\n2.2.4 Loops and Iterations\nYou can make a block of code execute over and over again using a while statement. The code in a while body will be executed as long as the while statement’s condition is True. In code, a while statement always consists of the following:\n\nThe while keyword\nA condition (that is, an expression that evaluates to True or False)\nA colon\nStarting on the next line, an indented block of code (called the while body)\n\n\nspam = 0\nwhile spam &lt; 5:\n    print('Hello, world.')\n    spam += 1 # equivalent to spam = spam + 1\n\n\nAugmented assignments abbreviate assignment expressions in which the same variable name appears on the left and right of the assignment’s = as above\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nMore formally, here is the flow of execution for a while statement:\n\nEvaluate the condition, yielding True or False.\nIf the condition is false, exit the while statement and continue execution at the next statement.\nIf the condition is true, execute the body and then go back to step 1.\n\nIn the while loop, the condition is always checked at the start of each iteration (that is, each time the loop is executed). If the condition is True, then the body is executed, and afterward, the condition is checked again. The first time the condition is found to be False, the while body is skipped.\nA common programming pattern is that we can run the program as long as the user wants by putting most of the program in a while loop. We’ll define a quit value and then keep the program running as long as the user has not entered the quit value:\n\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile message != 'quit':\n    message = input(prompt)\n    print(message)\n\nWe first set up a variable message to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time through the loop, the message is just an empty string, so Python enters the loop. At message = input(prompt), Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word ‘quit’, the prompt is displayed again and Python waits for more input. When the user finally enters ‘quit’, Python stops executing the while loop and the program ends.\n\nNote that Python considers 0, None, empty string, and empty container as False and all other things are True!\n\n\nbool(\"\"), bool(0), bool(None), bool(prompt), bool(12)\n\n\n2.2.4.1 Using break to Exit a Loop\nThe above program works well, except that it prints the word ‘quit’ as if it were an actual message. In fact, there is a shortcut to getting the program execution to break out of a while loop’s body early. If the execution reaches a break statement, it immediately exits the while loop’s body. In code, a break statement simply contains the break keyword.\n\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile True:\n    message = input(prompt)\n    if message == 'quit':\n        break\n    else:\n        print(message)\n\nThe fourth line creates an infinite loop; it is a while loop whose condition is always True. After the program execution enters this loop, it will exit the loop only when a break statement is executed. (An infinite loop that never exits is a common programming bug.)\nJust like before, this program asks the user to for the input. Now, however, while the execution is still inside the while loop, an if statement checks whether the message is equal to ‘quit’. If this condition is True, the break statement is run, and the execution moves out of the loop. Otherwise, the if statement’s body that contains the break statement is skipped, which again prints out the message. After that, the program execution jumps back to the start of the while statement to recheck the condition. Since this condition is merely the True Boolean value, the execution enters the loop to ask the user to type another message.\n\n\n2.2.4.2 continue Statemet\nRather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in that range:\n\ncurrent_number = 0\nwhile current_number &lt; 10:\n    current_number += 1\n    if current_number % 2 == 0:\n        continue\n    else:\n        print(current_number, end=' ')\n\nFirst, we set current_number to 0. Because it’s less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1, so current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0, the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current_number is not divisible by 2, the rest of the loop is executed and Python prints the current_number.\nNote that the built-in function print() displays its argument(s), then moves the cursor to the next line. You can change this behavior with the argument end. We used one space (’ ’), so each call to print displays the character’s value followed by one space.\n\nIf you ever run a program that has a bug causing it to get stuck in an infinite loop, press CTRL-C. This will send a KeyboardInterrupt error to your program and cause it to stop immediately.\n\n\n\n2.2.4.3 “TRUTHY” and “FALSY” Values\nLet us delve into the following program:\n\nname = ''\nwhile not name:\n    print('Enter your name:')\n    name = input()\n\nprint('How many guests will you have?')\nnumOfGuests = int(input())\n\nif numOfGuests:\n    print('Be sure to have enough room for all your guests.')\nprint('Done')\n\nYou can view the execution of this program at https://autbor.com/howmanyguests/. If the user enters a blank string for name, then the while statement’s condition will be True, and the program continues to ask for a name. If the value for numOfGuests is not 0, then the condition is considered to be True, and the program will print a reminder for the user. You could have entered not name != '' instead of not name, and numOfGuests != 0 instead of numOfGuests, but using the truthy and falsy values can make your code easier to read.\n\n\n\n2.2.5 for Loops and the range() Function\nThe while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function.\nIn code, a for statement looks something like for i in range(5): and includes the following:\n\nThe for keyword\nA variable name\nThe in keyword\nA call to the range() funtion with up to three integers passed to it (or an iterable object, which we will discuss later on)\nA colon\nStarting on the next line, an indented block of code (called the for body)\n\nLet’s create a new program to help you see a for loop in action.\n\nprint('My name is')\nfor i in range(5):\n    print('Jimmy Five Times (' + str(i) + ')')\n\nYou can view the execution of this program at https://autbor.com/fivetimesfor/. The code in the for loop’s body is run five times. The first time it is run, the variable i is set to 0. The print() call in the body will print Jimmy Five Times (0). After Python finishes an iteration through all the code inside the for loop’s body, the execution goes back to the top of the loop, and the for statement increments i by one. This is why range(5) results in five iterations through the body, with i being set to 0, then 1, then 2, then 3, and then 4. The variable i will go up to, but will not include, the integer passed to range().\nYou can actually use a while loop to do the same thing as a for loop; for loops are just more concise.\n\nprint('My name is')\ni = 0\nwhile i &lt; 5:\n    print('Jimmy Five Times (' + str(i) + ')')\n    i = i + 1\n\n\n2.2.5.1 The Starting, Stopping, and Stepping Arguments to range()\nSome functions can be called with multiple arguments separated by a comma, and range() is one of them. This lets you change the integer passed to range() to follow any sequence of integers, including starting at a number other than zero.\n\nfor i in range(12, 16):\n    print(i)\n\nThe range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.\n\nfor i in range(0, 10, 2):\n    print(i)\n\nThe range() function is flexible in the sequence of numbers it produces for for loops. For example , you can even use a negative number for the step argument to make the for loop count down instead of up.\n\nfor i in range(5, -1, -1):\n    print(i)\n\n\nNote that Python introduce switch statement as another control statement in Python 3.10\n\n\n2.2.6 Exercise 2: Write a script that displays the following triangle patterns. Use for loops to generate the patterns.\n\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\nHint: Try to use nested loops and use the outer loop to display each row while the inner loop to display each column\n\nfor row in range(__,__):\n    for column in range(__,__):\n        print('*', end='')\n    print()"
  },
  {
    "objectID": "02_Flow_control.html#importing-modules",
    "href": "02_Flow_control.html#importing-modules",
    "title": "2  Flow Control",
    "section": "2.3 Importing Modules",
    "text": "2.3 Importing Modules\nAll Python programs can call a basic set of functions called built-in functions, including the print(), input(), len() and range() functions you’ve seen before. Python also comes with a set of modules called the standard library. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematics-related functions. The random module has random number-related functions, and so on.\nBefore you can use the functions in a module, you must import the module with an import statement. In code, an import statement consists of the following:\n\nThe import keyword\nThe name of the module\nOptionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let’s give it a try with the random module, which will give us access to the random.randint() function.\n\nimport random\nfor i in range(5):\n    print(random.randint(1, 10))\n\nYou can view the execution of this program at https://autbor.com/printrandom/. The random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell Python to look for this function inside the random module. We will discuss it more in the following chapter.\n\nCheck out the Python standard library here or here\n\n\n2.3.1 Ending a Program Early with the sys.exit() Function\nThe last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.\n\n%%writefile exit.py\n\nimport sys\n\nwhile True:\n    print('Type exit to exit.')\n    response = input()\n    if response == 'exit':\n        sys.exit()\n    print('You typed ' + response + '.')\nprint('This line will not be printed')\n\n\n%run exit.py\n\nBy using expressions that evaluate to True or False (also called conditions), you can write programs that make decisions on what code to execute and what code to skip. You can also execute code over and over again in a loop while a certain condition evaluates to True. The break and continue statements are useful if you need to exit a loop or jump back to the loop’s start. These flow control statements will let you write more intelligent programs. You can also use another type of flow control by writing your own functions, which is the topic of the next chapter."
  },
  {
    "objectID": "03_Function.html#introductions",
    "href": "03_Function.html#introductions",
    "title": "3  Functions",
    "section": "3.1 Introductions",
    "text": "3.1 Introductions\nExperience has shown that the best way to develop and maintain a large program is to con struct it from smaller, more manageable pieces. This technique is called divide and conquer. We have already seen operations like print(), str() and len(), which involve parentheses wrapped around their operands. These are examples of Python’s built-in functions. Programming language allows us to use a name for a series of operations that should be performed on the given parameters. The appearance of a function in an expression or statement is known as a function call, or sometimes calling a function.\n\nIt allows you to execute a block of codes from various locations in your program by calling the function, rather than duplicating the code.\nIt also makes programs easier to modify. When you change a function’s code, all calls to the function execute the updated version.\n\n\nA function is a block of organized code that is used to perform a task. They provide better modularity and reusability."
  },
  {
    "objectID": "03_Function.html#def-statements-with-parameters",
    "href": "03_Function.html#def-statements-with-parameters",
    "title": "3  Functions",
    "section": "3.2 def Statements with Parameters",
    "text": "3.2 def Statements with Parameters\nWhen you call the print() or len() function, you pass them values, called arguments, by typing them between the parentheses. You can also define your own functions that accept arguments.\n\ndef hello(name):\n    print('Hello,', name)\n\nhello('Alice')\nhello('Bob')\n\nHello, Alice\nHello, Bob\n\n\nThe def statement defines the hello() function. Any indented lines that follow def hello(): make up the function’s body. The hello('Alice') line calls the now-created function. This function call is also known as passing the string value ‘Alice’ to the function.\n\n\n\nimage.png\n\n\nYou can view the execution of this program at https://autbor.com/hellofunc2/. The definition of the hello() function in this program has a parameter called name. When a function is called with arguments, the arguments are stored in the parameters. The first time the hello() function is called, it is passed the argument ‘Alice’. The program execution enters the function, and the parameter name is automatically set to ‘Alice’, which is what gets printed by the print() statement. One thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added print(name) after hello('Bob') in the previous program, the program would give you a NameError because there is no variable named name.\n\nprint(name)\n\nNameError: name 'name' is not defined\n\n\n\n3.2.1 Positional Arguments\nWhen you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is based on the order of the arguments provided. Values matched up this way are called positional arguments.\n\ndef describe_pet(animal_type, pet_name):\n    \"\"\"\n    Display information about a pet.\n    we can write multiple lines here!    \n    \"\"\"\n    print(\"\\nI have a\", animal_type, \".\")\n    print(\"My\", animal_type + \"'s name is\", pet_name.title() + \".\")\n\ndescribe_pet('hamster', 'harry')\n\n\nI have a hamster .\nMy hamster's name is Harry.\n\n\nWhen we call describe_pet(), we need to provide an animal_type and a name, in that order. For example, in the function call, the argument ‘hamster’ is assigned to the parameter animal_type and the argument ‘harry’ is assigned to the parameter pet_name. In the function body, these two parameters are used to display information about the pet being described.\nNote that the text on the second line is a comment called a docstring (multi-line comments introduced in Chapter 1), which describes what the function does. When Python generates documentation for the functions in your programs, it looks for a string immediately after the function’s definition. These strings are usually enclosed in triple quotes, which lets you write multiple lines. If you use the help() function, it will also be printed out as well as the function name and parameters.\n\nhelp(describe_pet)\n\nHelp on function describe_pet in module __main__:\n\ndescribe_pet(animal_type, pet_name)\n    Display information about a pet.\n    we can write multiple lines here!\n\n\n\n\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n\n\n\n\nNote that if there is more than one argument in print(), the default separation value is a white space. But you can change this behavior by specifying the sep keyword.\n\n\nprint(\"8\", \"9\", sep=\"*\")\n\n8*9\n\n\n\n\n3.2.2 Return Values and return Statements\nWhen you call the len() function and pass it an argument such as ‘Hello’, the function call evaluates to the integer value. The value that a function call evaluates to is called the return value of the function.\nWhen creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:\n\nThe return keyword\nThe value or expression that the function should return\n\nWhen an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on the number passed as an argument.\n\nimport random\n\ndef getAnswer(answerNumber):\n    if answerNumber == 1:\n        return 'It is certain'\n    elif answerNumber == 2:\n        return 'It is decidedly so'\n    elif answerNumber == 3:\n        return 'Yes'\n    elif answerNumber == 4:\n        return 'Reply hazy try again'\n    elif answerNumber == 5:\n        return 'Ask again later'\n    elif answerNumber == 6:\n        return 'Concentrate and ask again'\n    elif answerNumber == 7:\n        return 'My reply is no'\n    elif answerNumber == 8:\n        return 'Outlook not so good'\n    elif answerNumber == 9:\n        return 'Very doubtful'\n\nr = random.randint(1, 9)\nfortune = getAnswer(r)\nprint(fortune)\n\nYes\n\n\nYou can view the execution of this program at https://autbor.com/magic8ball/. When this program starts, Python first imports the random module. Then the getAnswer() function is defined. Because the function is being defined (and not called), the execution skips over the code in it. Next, the random.randint() function is called with two arguments: 1 and 9. It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named r.\nThe getAnswer() function is called with r as the argument. The program execution moves to the top of the getAnswer() function, and the value r is stored in a parameter named answerNumber. Then, depending on the value in answerNumber, the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that was originally called getAnswer(). The returned string is assigned to a variable named fortune, which then gets passed to a print() call and is printed to the screen. The functions that return values are sometimes called fruitful functions.\n\n\n3.2.3 The None Value\nIn Python, there is a value called None, which represents the absence of a value. The None value is the only value of the NoneType data type. This can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where None is used is as the return value of print(). The print() function displays text on the screen, but it doesn’t need to return anything. But since all function calls need to evaluate to a return value, print() returns None. A function does not return a value is called a void function\n\nspam = print('Hello!')\nprint(spam)\ntype(spam)\n\nHello!\nNone\n\n\nNoneType\n\n\n\nBehind the scenes, Python adds return None in the end of any function definition with no return statement. Also, if you use a return statement without a value (that is, just the return keyword by itself), then None is returned.\n\n\n\n3.2.4 Keyword Arguments\nA keyword argument is a name-value pair you pass to a function. You directly associate the name and the value within the argument, so when you pass the argument to the function, there’s no confusion. Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call.\n\ndescribe_pet(animal_type='hamster', pet_name='harry')\n\n\nI have a hamster .\nMy hamster's name is Harry.\n\n\nThe function describe_pet() hasn’t changed. But when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument ‘hamster’ to the parameter animal_type and the argument ‘harry’ to pet_name. The output correctly shows that we have a hamster named Harry.\n\n\n3.2.5 Default parameter values\nWhen writing a function, you can define a default value for each parameter. If an argument for a parameter is provided in the function call, Python uses the argument value. If not, it uses the parameter’s default value. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to ‘dog’:\n\ndef describe_pet(pet_name, animal_type='dog'):\n    \"\"\"\n    Display information about a pet.\n    Here we have default value for the animal type    \n    \"\"\"\n    print(\"\\nI have a \" + animal_type + \".\")\n    print(\"My\" + animal_type +\"'s name is \" + pet_name.title() + \".\")\n    \ndescribe_pet('willie')\n\n\nI have a dog.\nMydog's name is Willie.\n\n\nNow when the function is called with no animal_type specified, Python knows to use the value ‘dog’ for this parameter. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet’s name. Python still interprets this as a positional argument, so if the function is called with just a pet’s name, that argument will match up with the first parameter listed in the function’s definition.\n\nWhen you use default values, any parameter with a default value needs to be listed after all the parameters that don’t have default values. This allows Python to continue interpreting positional arguments correctly. Otherwise error occurs.\n\n\ndef describe_pet(animal_type='dog', pet_name):\n    \"\"\"\n    Display information about a pet.\n    Here we have default value for the animal type    \n    \"\"\"\n    print(\"\\nI have a \" + animal_type + \".\")\n    print(\"My\" + animal_type +\"'s name is \" + pet_name.title() + \".\")\n    \ndescribe_pet('willie')\n\nSyntaxError: non-default argument follows default argument (Temp/ipykernel_24512/574269134.py, line 1)"
  },
  {
    "objectID": "03_Function.html#advance-usage",
    "href": "03_Function.html#advance-usage",
    "title": "3  Functions",
    "section": "3.3 Advance usage",
    "text": "3.3 Advance usage\n\n3.3.1 Passing an Arbitrary Number of Arguments\nSometimes you won’t know how many arguments a function needs to accept ahead of time. Fortunately, Python allows a function to collect arbitrary arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings, but this parameter collects as many arguments as the calling line provides:\n\ndef make_pizza(size, *toppings):\n    \"\"\"Print the list of toppings that have been requested.\"\"\"\n    print(\"The size of the pizza is\", size, \"inch with the following toppings:\")\n    print(toppings)\n\nmake_pizza(6, 'pepperoni')\nmake_pizza(8, 'mushrooms', 'green peppers', 'extra cheese')\n\nThe size of the pizza is 6 inch with the following toppings:\n('pepperoni',)\nThe size of the pizza is 8 inch with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nIn the function definition, Python assigns the first value it receives to the parameter size. All other values that come after are stored in the tuple (which we will discuss in later chapters) with the name toppings. The function calls include an argument for the size first, followed by as many toppings as needed.\n\nYou’ll often see the generic parameter name *args, which collects arbitrary positional arguments like this. The *arg must be the rightmost parameter (except for parameter with default value and the **kwargs).\n\n\n\n3.3.2 Using Arbitrary Keyword Arguments\nSometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:\n\ndef build_profile(first, last, **user_info):\n    \"\"\"Build a dictionary containing everything we know about a user.\"\"\"\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nuser_profile = build_profile('albert', 'einstein',\n                             location='princeton',\n                             field='physics')\nprint(user_profile)\n\n{'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'}\n\n\nThe definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs (Keyword arguments) as they want. The double asterisks before the parameter **user_info cause Python to create a dictionary (Which we will discuss in later chapters) called user_info containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary.\nIn the body of build_profile(), we add the first and last names to the user_info dictionary because we’ll always receive these two pieces of information from the user, and they haven’t been placed into the dictionary yet. Then we return the user_info dictionary to the function call line.\n\nYou’ll often see the parameter name **kwargs used to collect nonspecific keyword arguments. The **kwargs must be the rightmost paramter.\n\n\n3.3.3 Exercise 1: Please write a function implementing the “guess the number” game. The function accepts two arguments for the maximum number of tries and the maximum number. The function returns a boolean value indicating whether the player guessed the number correctly or not. If the player doesn’t guess the number correctly after the maximum number of tries, the function returns False; otherwise, it should return True. You can set the default value of the max number to an arbitrary number.\n\n\n\n\n\nCurrently, there exists a delay for the input() function in vscode. Therefore, it is recommended to play the game using the script!\n\n\n%%writefile guess_number.py\n\nimport random\n\ndef guess_number(max_tries, max_number=_____):\n    \"\"\"\n    Function that allows the player to guess a number between 1 and max_number\n    If the player can guess the correct number within max_tries times, return True\n    Otherwise, return False\n    \"\"\"\n    # Generate a random number between 1 and max_number\n    number = _____ \n\n    # Allow the player to guess up to max_tries times\n    for i in range(max_tries):\n        # Prompt the player to guess the number\n        guess = int(input(\"Guess the number (between 1 and \"+ str(max_number) +\"): \"))\n\n        # Check if the guess is correct\n        if ______:\n            print(\"Congratulations, you guessed the number!\")\n            ______\n        elif ______:\n            print(\"The number is higher than your guess.\")\n        else:\n            print(\"The number is lower than your guess.\")\n\n    # If the player couldn't guess the number in max_tries tries, reveal the answer\n    print(\"Sorry, you didn't guess the number. The number was \" + str(number) + \".\")\n    _______\n\n# Call the function to start the game with a maximum of 5 tries\ngame_result = guess_number(5)\n\n# Print the result of the game\nif game_result:\n    print(\"You won!\")\nelse:\n    print(\"You lost!\")"
  },
  {
    "objectID": "03_Function.html#local-and-global-scope",
    "href": "03_Function.html#local-and-global-scope",
    "title": "3  Functions",
    "section": "3.4 Local and Global Scope",
    "text": "3.4 Local and Global Scope\nParameters and variables assigned in a called function are said to exist in that function’s local scope. Variables assigned outside all functions are said to exist in the global scope. A variable in a local scope is called a local variable, while a variable in the global scope is called a global variable. A variable must be one or the other; it cannot be both local and global.\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. There is only one global scope, and it is created when your program begins. A local scope is created whenever a function is called. Any variables assigned in the function exist within the function’s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The next time you call the function, the local variables will not remember the values stored in them from the last time it was called.\n\n3.4.1 Local Variables Cannot Be Used in the Global Scope\nConsider this program, which will cause an error when you run it:\n\ndef spam():\n    eggs = 31337\n\nspam()\nprint(eggs)\n\nNameError: name 'eggs' is not defined\n\n\nThe error happens because the eggs variable exists only in the local scope created when spam() is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs.\n\n\n3.4.2 Local Scopes Cannot Use Variables in Other Local Scopes\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\ndef spam():\n    eggs = 99\n    bacon()\n    print(eggs)\n\ndef bacon():\n    ham = 101\n    eggs = 0\n\nspam()\n\n99\n\n\nYou can view the execution of this program at https://autbor.com/otherlocalscopes/. When the program starts, the spam() function is called, and a local scope is created. The local variable eggs is set to 99. Then the bacon() function is called, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101, and a local variable eggs — which is different from the one in spam()’s local scope—is also created and set to 0. When bacon() returns, the local scope for that call is destroyed, including its eggs variable. The program execution continues in the spam() function to print the value of eggs. Since the local scope for the call to spam() still exists, the only eggs variable is the spam() function’s eggs variable, which was set to 99.\n\n\n3.4.3 Global Variables Can Be Read from a Local Scope\n\ndef spam():\n    print(eggs)\n    \neggs = 42\nspam()\nprint(eggs)\n\n42\n42\n\n\nYou can view the execution of this program at https://autbor.com/readglobal/. Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam(), Python considers it a reference to the global variable eggs. This is why 42 is printed when the previous program is run.\n\ndef spam():\n    eggs = 'spam local'\n    print(eggs)    # prints 'spam local'\n\ndef bacon():\n    eggs = 'bacon local'\n    print(eggs)    # prints 'bacon local'\n    spam()\n    print(eggs)    # prints 'bacon local'\n\neggs = 'global'\nbacon()\nprint(eggs)        # prints 'global'\n\nbacon local\nspam local\nbacon local\nglobal\n\n\n\nIf you want to modify the global variable, use the global keywords.\n\n\ndef spam():\n    global eggs    # If you want to modify the global eggs use global keyword\n    eggs = 'spam local' \n    print(eggs)    # prints 'spam local'\n\neggs = 'global'\nspam()\nprint(eggs)\n\nspam local\nspam local\n\n\nYou can visulaize the execution here."
  },
  {
    "objectID": "03_Function.html#storing-your-functions-in-modules",
    "href": "03_Function.html#storing-your-functions-in-modules",
    "title": "3  Functions",
    "section": "3.5 Storing Your Functions in Modules",
    "text": "3.5 Storing Your Functions in Modules\nOne advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, your programs become much easier to follow. You can go a step further by storing your functions in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file.\n\nStoring your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.\n\n\n3.5.1 Importing a module\nTo start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let’s make a module that contains the function make_pizza().\n\n%load_ext autoreload\n%autoreload 2\n\n\n%%writefile pizza.py\ndef make_pizza(size, *toppings):\n    \"\"\"Summarize the pizza we are about to make.\"\"\"\n    print(\"\\nMaking a \"+ str(size) + \"-inch pizza with the following toppings:\")\n    print(toppings)\n\nOverwriting pizza.py\n\n\n\nimport pizza\n\npizza.make_pizza(16, 'pepperoni')\npizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nWhen Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. To call a function from an imported module, enter the name of the module you imported, pizza, followed by the name of the function, make_pizza(), separated by a dot.\n\n\n3.5.2 Importing Specific Functions using from\nYou can also import a specific function from a module.\n\nfrom pizza import make_pizza\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nWith this syntax, you don’t need to use the dot notation when you call a function.\n\n\n3.5.3 Importing All Functions in a Module\nYou can tell Python to import every function in a module by using the asterisk (*) operator:\n\nfrom pizza import *\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nThe asterisk in the import statement tells Python to copy every function from the module pizza into this program file. Because every function is imported, you can call each function by name without using the dot notation.\n\nHowever, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results!\n\n\n\n3.5.4 Using as to Give a Function an Alias\nIf the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique alias — an alternate name similar to a nickname for the function.\n\nfrom pizza import make_pizza as mp\n\nmp(16, 'pepperoni')\nmp(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\n\n\n3.5.5 Using as to Give a Module an Alias\nYou can also provide an alias for a module name. Giving a module a short alias, like p for pizza, allows you to call the module’s functions more quickly.\n\nimport pizza as p\n\np.make_pizza(16, 'pepperoni')\np.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\n\n3.5.6 Exercise 2: In this word game, the player is in a land full of dragons. Some dragons are friendly and share their treasure. Other dragons are hungry and eat anyone who enters their cave. The player approaches two caves, one with a friendly dragon and the other with a hungry dragon, but doesn’t know which dragon is in which cave. The player must choose between the two. Please completet the design of game by calling the function from the provided game module.\n\n\n\n\n\n%%writefile word_game.py\nimport random\nimport time\n_____________\n\nplayAgain = 'yes'\n\nwhile playAgain == 'yes':\n    # Display the information of game using the displayIntro() in game module\n    ______________\n    # Read the user input and return the cave number by calling the function chooseCave() in game module\n    caveNumber = ________________\n    # Check whether the cave is safe or not by calling the checkCave() in game module with appropriate arguments\n    ______(_____)\n\n    print('Do you want to play again? (yes or no)')\n    playAgain = input()\n\nFunctions are the primary way to categorize your code into logical groups. Since the variables in functions exist in their local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when debugging your code.\nFunctions are a great tool to help you organize your code. You can think of them as black boxes: they have input in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions."
  },
  {
    "objectID": "04_Lists_tuples.html#list",
    "href": "04_Lists_tuples.html#list",
    "title": "4  Lists and Tuples",
    "section": "4.1 List",
    "text": "4.1 List\nOne more topic you’ll need to understand before you can begin writing programs in earnest is the list data type and its cousin, the tuple. Lists and tuples can contain multiple values, which makes writing programs that handle large amounts of data easier. These data types are called containers, meaning they are objects that “contain” other objects. They each have some important distinguishing properties and come with their own set of methods for interacting with objects of each type. List and tuple belong to sequence data types, which means they represent ordered collections of items. They share the same characteristic as string and the range object returned by range() function. Many of the capabilities shown in this chapter apply to all sequence types.\n\nCheckout https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range for more details.\n\nIn a string, the values are characters; in a list, they can be any type. The values in a list are called elements or sometimes items. Items are separated with commas.\n\n\n\n\nsource: https://favtutor.com/blogs/list-vs-dictionary\n\nThere are several ways to create a new list; the simplest is to enclose the elements in square brackets (“[” and ”]”). A list that contains no elements is called an empty list; you can create one with empty brackets.\n\ntype([])\n\nlist\n\n\n\ntype([10, 20, 30, 40]), type(['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra'])\n\n(list, list)\n\n\nThe first example is a list of four integers and the second is a list of four strings.\n\n4.1.1 Getting Individual Values in a List with Indexes\nYou can reference a list item by writing the list’s name followed by the element’s index (that is, its position number) enclosed in square brackets ([], known as the subscription operator or bracket operator). Remember that the indices start at 0:\n\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[0])\nprint(subjects[3])\n\ncalculus\nlinear algebra\n\n\nNote that the first index is 0, the last index is one less than the size of the list; a list of four items has 3 as its last index.\nPython will give you an IndexError error message if you use an index that exceeds the number of values in your list value.\n\nprint(subjects[4])\n\nIndexError: list index out of range\n\n\nThe elements of a list don’t have to be the same type. The following list contains a string, a float, an integer, and another list:\n\nspam = ['spam', 2.0, 5, [10, 20]]\n\nThe values in these lists of lists can be accessed using multiple indexes:\n\nspam[3][1]\n\n20\n\n\n\nspam = [1,3,5,7,9]\nspam[3:]\n\n[7, 9]\n\n\nThe first index dictates which items in the outer list to use, and the second indicates the value within the inner list. If you only use one index like spam[3], the program will print the entire list value at that index.\n\nspam[3]\n\n7\n\n\n\n4.1.1.1 Negative Indexes\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on.\n\nprint(subjects[-1]) # subjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[-2])\n\nlinear algebra\ncomputer programming\n\n\n\n\n4.1.1.2 Getting a List’s Length with the len() Function\nThe len() function will return the number of values that are in a list, just like it can count the number of characters in a string.\n\nlen(subjects)\n\n4\n\n\n\n\n4.1.1.3 Getting a sublist from Another List with Slices\nJust as an index can get a single value from a list, a slice can get several values from a list as a new list. A slice is typed between square brackets, like an index, but has two integers separated by a colon.\n\nsubjects[2] is a list with an index.\nsubjects[1:3] is a list with a slice.\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list.\n\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[0:3])\nprint(subjects[1:-1])\n\n['calculus', 'introduction to mathematics', 'computer programming']\n['introduction to mathematics', 'computer programming']\n\n\nAs a shortcut, you can leave out one or both indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list.\n\nprint(subjects[:3]) # same as subjects[0:3] \nprint(subjects[1:]) # same as subjects[1:len(s)] \nprint(subjects[:]) # same as s[0:len(s)]\n\n['calculus', 'introduction to mathematics', 'computer programming']\n['introduction to mathematics', 'computer programming', 'linear algebra']\n['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n\n\nJust like range(), slicing has the optional third index that can be used to specify the step.\n\nprint(subjects[::2]) # Note the default step is 1\nprint(subjects[::-1]) # Reverse the order of the list\n\n['calculus', 'computer programming']\n['linear algebra', 'computer programming', 'introduction to mathematics', 'calculus']\n\n\n\n\n4.1.1.4 Changing Values in a List with Indexes\nUnlike strings, lists are mutable because you can reassign an item in a list. When the bracket operator appears on the left side of an assignment, it identifies the element of the list that will be assigned.\n\nnumbers = [17, 123, 42, 7]\nnumbers[1] = 5\nnumbers\n\n[17, 5, 42, 7]\n\n\nThe first element of numbers, which used to be 123, is now 5.\nAll in all, you can think of a list as a relationship between indices and elements. This relationship is called a mapping; each index “maps to” one of the elements.\n\n\n\n4.1.2 List Concatenation and List Replication\nLists can be concatenated and replicated just like strings. The + operator combines two lists to create a new list and the * operator can be used with a list and an integer value to replicate the list.\n\n[1, 2, 3] + ['A', 'B', 'C']\n\n[1, 2, 3, 'A', 'B', 'C']\n\n\n\n['X', 'Y', 'Z'] * 3\n\n['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']\n\n\n\n4.1.2.1 Removing Values from Lists with del Statements\nThe del statement will delete values at an index in a list. All values in the list after the deleted value will be moved up one index.\n\nt = ['a', 'b', 'c']\ndel t[1] # using index\nprint(t)\n\n['a', 'c']\n\n\n\n\n\n4.1.3 List traversal\nIn Chapter 2, you have learned about using for loops to execute a block of code a certain number of times. Technically, a for loop repeats the code block once for each item in a sequence.\n\nfor i in range(4):\n    print(i)\n\n0\n1\n2\n3\n\n\n\nprint(range(4))\nlist(range(4))\n\nrange(0, 4)\n\n\n[0, 1, 2, 3]\n\n\nThis is because the return value from range(4) is a sequence that Python considers similar to [0, 1, 2, 3]. The following program has the same output as the previous one:\n\nfor i in [0, 1, 2, 3]:\n    print(i)\n\n0\n1\n2\n3\n\n\n\nfor subject in subjects: # subjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n  print(subject)\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\nThis works well if you only need to read the elements of the list. But you need the indices that you want to write or update the elements. A common way to do that is to combine the functions range() and len():\nA common Python technique is to use range(len(someList)) with a for loop to iterate over the indexes of a list.\n\nfor i in range(len(numbers)): # numbers = [17, 5, 42, 7]\n  print(i, numbers[i])\n  numbers[i] = numbers[i]**2\n\nprint(numbers)\n\n0 17\n1 5\n2 42\n3 7\n[289, 25, 1764, 49]\n\n\nThis loop traverses the list and prints each element. len() returns the number of elements in the list. range() returns a list of indices from 0 to n − 1, where n is the length of the list. Each time through the loop, i gets the index of the next element. This is handy since it will iterate through all the indexes, no matter how many items it contains.\n\n4.1.3.1 The in and not in Operators\nYou can determine whether an object is or isn’t in a list with the in and not in operators. These expressions will evaluate to a Boolean value.\n\nprint('howdy' in ['hello', 'hi', 'howdy', 'heyas'])\nprint('English' not in subjects)\n\nTrue\nTrue\n\n\n\n\n4.1.3.2 Using the enumerate() Function with Lists\nInstead of using the range(len(someList)) technique with a for loop to obtain the integer index of the items in the list, you can call the enumerate() function instead. On each iteration of the loop, enumerate() will return two values: the index of the item and the item itself.\n\nnumbers = [17, 5, 42, 7]\n\nfor i, number in enumerate(numbers): \n  print(i, number)\n  numbers[i] = number**2\n\nprint(numbers)\n\n0 17\n1 5\n2 42\n3 7\n[289, 25, 1764, 49]\n\n\n\n\n4.1.3.3 Loop in Multiple Lists with zip()\nBuilt-in function zip() enables you to iterate over multiple sequences of data at the same time. The function receives as arguments any number of sequences and returns an iterator that produces tuples containing the elements at the same index in each.\n\nnames = ['Bob', 'Sue', 'Amanda']\ngrade_point_averages = [3.5, 4.0, 3.75] \n\nfor name, gpa in zip(names, grade_point_averages):\n    print('Name=', name, 'GPA=', gpa)\n\nName= Bob GPA= 3.5\nName= Sue GPA= 4.0\nName= Amanda GPA= 3.75\n\n\nThe above snippet call zip() to produces the tuples ('Bob', 3.5), ('Sue', 4.0) and ('Amanda', 3.75) consisting of the elements at index 0, 1 and 2 of each list, respectively. Note that we unpack (which we will elaborate later on) each tuple into name and gpa and display them.\n\nlist(zip(names, grade_point_averages))\n\n[('Bob', 3.5), ('Sue', 4.0), ('Amanda', 3.75)]\n\n\n\n\n\n4.1.4 Methods of the list\nA method, introduced in Chapter 1, is the same as a function, except it is “called on” an object. For example, if a list object were stored in spam, you would call the index() list method on that list like so: spam.index('hello'). The method part comes after the object, separated by a period.\nEach data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a list.\n\n4.1.4.1 Adding elements to Lists with the append() and insert() Methods\nappend() adds a new element to the end of a list:\n\nt = ['a', 'b', 'c']\nt.append('d')\nt # in-place operation!\n\n['a', 'b', 'c', 'd']\n\n\nThe previous append() method call adds the argument to the end of the list. The insert() method can insert an element at any index in the list. The first argument to insert() is the index for the new value, and the second argument is the new value to be inserted.\n\nt = ['a', 'b', 'c']\nt.insert(1,'e')\nt # in-place operation!\n\n['a', 'e', 'b', 'c']\n\n\n\nNotice that the code is t.append('d') and t.insert(1, 'e'), not t = t.append('d') and t = t.insert(1, 'e'). In fact, the return value of append() and insert() is None, so you definitely wouldn’t want to store this as the new variable value. Rather, the list is modified in-place.\n\nMethods belong to a single data type. The append() and insert()methods are list methods and can be called only on list object, not on other objects such as strings or integers.\n\neggs = 'hello'\neggs.append('world')\n\nAttributeError: 'str' object has no attribute 'append'\n\n\n\n\n4.1.4.2 Adding all the elements of a List to the end of List with the extend() Methods\nUse list method extend() to add all the elements of another sequence to the end of a list:\n\ncolor_names = ['orange', 'yellow', 'green']\ncolor_names.extend(['indigo', 'violet']) # equivalent to color_names += ['indigo', 'violet']\n\n\ncolor_names\n\n['orange', 'yellow', 'green', 'indigo', 'violet']\n\n\n\n\n4.1.4.3 Removing elements from Lists with the remove() Method\nThe remove() method will pass the object to be removed from the list when it is called:\n\nspam = ['cat', 'bat', 'rat', 'elephant']\nspam.remove('bat')\nprint(spam)\n\n['cat', 'rat', 'elephant']\n\n\n\nThe del statement is good to use when you know the index of the element you want to remove from the list. The remove() method is useful when you know the element you want to remove from the list.\n\n\n\n4.1.4.4 Sorting the elements in a List with the sort() Method\nLists of numbers or lists of strings can be sorted with the sort() method:\n\nspam = [2, 5, 3.14, 1, -7]\nspam.sort() # The default behavior is sorting in ascending order\nprint(spam)\n\nspam = ['ants', 'cats', 'dogs', 'badgers', 'Elephants']\nspam.sort()\nprint(spam)\n\n[-7, 1, 2, 3.14, 5]\n['Elephants', 'ants', 'badgers', 'cats', 'dogs']\n\n\nNote that sort() uses “ASCII order” rather than alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z.\nYou can also pass True for the reverse keyword argument to have sort() sort the values in reverse order.\n\nspam.sort(reverse=True) # Sort in descending order\nprint(spam)\n\n['dogs', 'cats', 'badgers', 'ants', 'Elephants']\n\n\n\n\n4.1.4.5 Searching an element in a List with the index() Method\nList objects have an index() method that accepts an argument, and if that argument exists in the list, the index of the argument is returned. If the argument isn’t in the list, then Python produces a ValueError error.\n\nspam = ['hello', 'hi', 'howdy', 'heyas']\nspam.index('hi')\n\n1\n\n\n\nspam = ['hello', 'hi', 'howdy', 'heyas']\nspam.index('world')\n\nValueError: 'world' is not in list\n\n\nWhen there are duplicates of the elements in the list, the index of its first appearance is returned.\n\nspam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka']\nspam.index('Pooka')\n\n1\n\n\n\n\n\n4.1.5 Numerical functions for list\nThere are a number of built-in functions that can be used on lists that allow you to quickly look through a list without writing your own loops:\n\nnums = [3, 41, 12, 9, 74, 15]\nprint(len(nums))\n\n6\n\n\n\nprint(max(nums))\nprint(min(nums))\nprint(sum(nums))\n\n74\n3\n154\n\n\nCheck out https://docs.python.org/3/tutorial/datastructures.html#more-on-lists for more methods!\n\n\n4.1.6 List Comprehensions\nConsider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10).\n\nsquares = []\nfor value in range(1,11):\n    squares.append(value**2)\nprint(squares)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nBut a list comprehension allows you to generate this same list in just one line of code. A list comprehension combines the for loop and the creation of new elements into one line, and automatically appends each new element!\n\nsquares = [value**2 for value in range(1, 11)]\nprint(squares)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nTo use this syntax\n\nBegin with a descriptive name for the list, such as squares.\nNext, open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression is value**2\nThen, write a for loop to generate the numbers you want to feed into the expression and close the square brackets. In this example, the for loop iterates value in range(1, 11), which feeds the values 1 through 10 into the expression value**2.\n\nNote that no colon is used at the end of the for statement.\n\nThe syntax of list comprehension is similar to the set-builder notation. For instance, preivous example is similar to \\(\\{x^2 | x \\in \\{1,2,...,10\\}\\}\\)\n\nAnother common operation is filtering elements to select only those that match a condition. This typically produces a list with fewer elements than the data being filtered. To do this in a list comprehension, use the if clause. The following includes in list1 only the even values produced by the for clause:\n\nlist1 = [item for item in range(1, 11) if item % 2 == 0]\nlist1\n\n[2, 4, 6, 8, 10]\n\n\n\n4.1.7 Exercise 1: Bulls and Cows (or 1A2B) is a code-breaking game. The numerical version of the game is usually played with four digits. On a sheet of paper, the players each write a 4-digit secret number. The digits must all be different. Then, in turn, the players try to guess their opponent’s number, which gives the number of matches. If the matching digits are in their right positions, they are “bulls” (A). If they are in different positions, they are “cows” (B). For example, if the secret number is 4271 and our guess is 1234, then we should get 1 bull and 2 cows. (The bull is “2”, the cows are “4” and “1”.). Please complete the following game design, that the computer will generate a 4-digit number, and we must write a function to read the user’s 4-digit inputs and check the user’s guess against the secret number. Finally, return the message XAXB to the user.\n\n\n\n\n\nsource: https://en.wikipedia.org/wiki/Bulls_and_Cows\n\n\n%%writefile 1A2B.py\n\nimport random\n\n# Generate a random four-digit number\ndef generate_number():\n    digits = list(range(10))\n    random.shuffle(digits) # randomly shuffle the list!\n    return digits[:4]\n\n# Check the user's guess against the secret number\ndef check_guess(guess, secret):\n    # Note that both guess and secret are lists!\n    a = 0 # number of correct digits in the correct position\n    b = 0 # number of correct digits in the wrong position\n    for i,j in zip(__,__): # Iterate over two lists\n        if i == j:\n            a += 1\n        elif __________: # Use operator to determine whether the digit is in secret number or not\n            b += 1\n    return a, b\n\n# Play the game\nprint(\"Welcome to 1A2B!\")\nprint(\"I'm thinking of a four-digit number. Can you guess it?\")\nsecret = generate_number()\nguesses = 0\nwhile True:\n    guess = input(\"Enter your guess, enter 'quit' to give up: \")\n    if guess == 'quit':\n        print(\"The secret number is\", secret)\n        break\n    elif len(guess) != 4 or not guess.isdigit():\n        print(\"Invalid guess. Please enter a four-digit number.\")\n        continue\n    guess = _______ # Use list comprehension to get the 4-digit guess list\n    guesses += 1\n    result = check_guess(guess, secret)\n    print(result[0],'A', result[1], 'B', sep=\"\")\n    if result[0] == 4:\n        print(\"Congratulations, you guessed the number in\", guesses, \"guesses!\")\n        break\n\nOverwriting 1A2B.py\n\n\n\n\n4.1.8 Sequence Data Types\nLists aren’t the only data types that represent ordered sequences of values. For example, strings and lists are similar if you consider a string to be a “list” of single text characters. The Python sequence data types include lists, strings, range objects returned by range(), and tuples. Many of the things you can do with lists can also be done with strings and other values of sequence types: indexing; slicing; and using them with for loops, with len(), and with the in and not in operators.\n\n'a' in 'apple'\n\nTrue\n\n\n\n\n4.1.9 Mutable and Immutable Data Types\nBut lists and strings are different in an important way. A list object is a mutable data type: it can have elements added, removed, or changed. However, a string is immutable: it cannot be changed. Trying to reassign a single character in a string results in a TypeError error:\n\nname = 'Zophie a cat'\nname[7] = 't'\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "04_Lists_tuples.html#tuples",
    "href": "04_Lists_tuples.html#tuples",
    "title": "4  Lists and Tuples",
    "section": "4.2 Tuples",
    "text": "4.2 Tuples\nA tuple is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers. The important difference is that tuples are immutable.\n\nIt is similar to the tuple you encounter in math\n\nAlthough it is not necessary, it is common to enclose tuples in parentheses to help us quickly identify tuples when we look at Python code:\n\ntype(())\n\ntuple\n\n\n\nt = ('a', 'b', 'c', 'd', 'e')\ntype(t)\n\ntuple\n\n\nTo create a tuple with a single element, you have to include the final comma or use the tuple() function:\n\nt1 = ('a',)\nprint(type(t1))\nt2 = ('a')\nprint(type(t2))\n\n&lt;class 'tuple'&gt;\n&lt;class 'str'&gt;\n\n\nIf the argument of tuple() is a sequence (string, list, or tuple), the result is a tuple with the elements of the sequence:\n\nt = tuple('nsysu')\nt\n\n('n', 's', 'y', 's', 'u')\n\n\nMost list operators also work on tuples. The bracket operator indexes an element:\n\nprint(t[0])\nprint(t[1:3])\n\nn\n('s', 'y')\n\n\nBut if you try to modify one of the elements of the tuple, you get an error:\n\nt[0] = 'A'\n\nTypeError: 'tuple' object does not support item assignment\n\n\nYou can use tuples to convey to anyone reading your code that you don’t intend for that sequence of values to change. Use a tuple if you need an ordered sequence of values that never changes.\n\n4.2.1 Unpacking Sequences\nWe have seen the multiple assignment trick in the previous chapter (which is actually unpacking the tuple). In fact, you can unpack any sequence’s elements by assigning the sequence to a comma-separated list of variables.\n\nstudent_tuple = ('Amanda', [98, 85, 87])\n\n\nfirst_name, grades = student_tuple\nprint(first_name, grades)\n\nAmanda [98, 85, 87]\n\n\nUnpacking is widely used to return multiple values in a function:\n\ndef total_ave(grade):\n    total = sum(grade)\n    ave = total/len(grade)\n    return total, ave\n\ngrades = [85, 70, 100, 90]\ntotal, ave = total_ave(grades)\n\nprint(total, ave)\n\n345 86.25"
  },
  {
    "objectID": "04_Lists_tuples.html#references",
    "href": "04_Lists_tuples.html#references",
    "title": "4  Lists and Tuples",
    "section": "4.3 References",
    "text": "4.3 References\nTechnically, in Python, variables store references to the computer memory locations where the values are stored.\n\nspam = 42\ncheese = spam\nprint(id(cheese), id(spam))\nspam = 100\nprint(id(cheese), id(spam))\n\nspam, cheese\n\n140731993439296 140731993439296\n140731993439296 140731993441152\n\n\n(100, 42)\n\n\nWhen you assign 42 to the spam variable, you are actually creating the 42 value in the computer’s memory and storing a reference (address) to it in the spam variable. When you copy the value in spam and assign it to the variable cheese, you are actually copying the reference. Both the spam and cheese variables refer to the 42 value in the computer’s memory. When you later change the value in spam to 100, you’re creating a new 100 value and storing a reference to it in spam. This doesn’t affect the value in cheese. Integers are immutable values that don’t change; changing the spam variable is actually making it refer to a completely different value in memory.\nYou can use id() function to verify this behavior. In CPython (the most widely used implementation of Python), the identifier returned by id() is actually the memory address of the object, represented as a Python integer. All values in Python have a unique identity (address) that can be obtained with the id() function.\nBut lists don’t work this way, because list are mutable:\n\nspam = [0, 1, 2, 3, 4, 5]\ncheese = spam        # The reference is being copied, not the list.\nprint(id(cheese), id(spam))\ncheese[1] = 'Hello!' # This changes the list value.\nprint(id(cheese), id(spam))\n\nspam, cheese\n\n2790646437440 2790646437440\n2790646437440 2790646437440\n\n\n([0, 'Hello!', 2, 3, 4, 5], [0, 'Hello!', 2, 3, 4, 5])\n\n\nUsing boxes as a metaphor for variables, the following shows what happens when a list is assigned to the spam variable.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nThen, the reference in spam is copied to cheese. Only a new reference was created and stored in cheese, not a new list. Note how both references refer to the same list.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nWhen you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nYou may be wondering why the weird behavior with mutable lists in the previous section doesn’t happen with immutable values like integers or strings. Let us elaborate on this topics.\nLike integer, 'Hello' is a string which is immutable and cannot be changed. If you “change” the string in a variable, a new string object is being made at a different place in memory, and the variable refers to this new string.\n\nbacon = 'Hello'\nprint(id(bacon))\nbacon = bacon + 'World'\nprint(id(bacon))\n\n2790646417200\n2790646416176\n\n\nHowever, lists can be modified because they are mutable objects. The append() method doesn’t create a new list object; it changes the existing list object. We call this “modifying the object in-place.”\n\neggs = ['Hello'] # This creates a new list.\nprint(id(eggs))\neggs.append('World')  # append() modifies the list \"in place\".\nprint(id(eggs))       # eggs still refers to the same list as before.\n\n2790646499648\n2790646499648\n\n\nIf two variables refer to the same list (like spam and cheese in the previous section) and the list itself changes, both variables are affected because they both refer to the same list. The append(), remove(), sort(), reverse(), and other list methods modify their lists in place.\n\nPython’s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don’t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\n\n4.3.1 Passing References\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries, which we will describe in the next chapter), this means a copy of the reference is used for the parameter.\n\ndef eggs(someParameter):\n    someParameter.append('Hello')\n\nspam = [1, 2, 3]\neggs(spam)\nprint(spam)\n\n[1, 2, 3, 'Hello']\n\n\nNotice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place directly. Even though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.\nFor immutable types string and integers, we will create a new object in the function when we modify someParameter. Therefore, the original value will not be modified after the loop.\n\ndef eggs(someParameter):\n    print(id(someParameter))\n    someParameter = someParameter + \"world\" # This will create a new object and assign the new reference to someParameter\n    print(id(someParameter))\n\nspam = \"hello\"\nprint(id(spam))\neggs(spam)\nprint(spam)\n\n2790636340272\n2790636340272\n2790646431216\nhello\n\n\n\n\n4.3.2 The copy Module’s copy() and deepcopy() Functions\nPython provides a module named copy that provides both the copy() and deepcopy() functions. copy(), can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference.\n\nimport copy\n\nspam = ['A', 'B', 'C', 'D']\nprint(id(spam))\ncheese = copy.copy(spam)\nprint(id(cheese)) # cheese is a different list with different identity.\ncheese[1] = 42\n\nspam, cheese\n\n2790645442048\n2790645869632\n\n\n(['A', 'B', 'C', 'D'], ['A', 42, 'C', 'D'])\n\n\nNow the spam and cheese variables refer to separate lists, which is why only the list in cheese is modified when you assign 42 at index 1.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\n\nIf the list you need to copy contains another list, then use the copy.deepcopy() function instead of copy.copy(). The deepcopy() function will copy these inner lists as well.\n\n\n4.3.3 Exercise 2: Here, we will simulate the process of a simple card game. The game is played with a standard deck of 52 cards, and we will randomly select 40 cards and divide them evenly between two players. Each player gets a hand of 20 cards. The goal of the game is to collect pairs of cards with the same rank (e.g., two aces, two kings, etc.). The player with the most pairs at the end of the game wins.\n\n\n\n\n\nimport random\n\n# Write a function create_deck that creates a list of tuples representing a standard deck of 52 cards. \n# Each tuple should contain two elements: the rank (e.g., \"ace\", \"king\", etc.) \n# and the suit (e.g., \"hearts\", \"spades\", etc.). \ndef create_deck():\n    ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n    suits = ['♣', '♦', '♥', '♠']\n    deck = [(rank, suit) ______] # Use list comprehension to create the deck.\n    return deck\n\n# A function that takes the deck as a parameter and returns two lists, each containing 26 randomly-selected \n# cards from the deck. Use list slicing and the random module to implement this function.\ndef deal_cards(deck):\n    deck = deck[:40]\n    random.shuffle(deck)\n    hand1 = _____  # Split it into 20 cards in each using slice\n    hand2 = _____\n    return hand1, hand2\n\n# Write a function find_pairs that takes a list of cards as a parameter and returns a list of tuples \n# representing the pairs of cards in the list. A pair is defined as two cards with the same rank. \ndef find_pairs(cards):\n    pairs = []\n    for i, card1 in enumerate(cards):\n        for j, card2 in enumerate(cards):\n            if i != j and card1[0] == card2[0] and card1 not in [pair[0] for pair in pairs]\\\n                and card1 not in [pair[1] for pair in pairs] and card2 not in [pair[0] for pair in pairs]\\\n                and card2 not in [pair[1] for pair in pairs]:\n                pairs._____((card1, card2)) # Use a method from the list to add it into the pairs\n    return pairs\n\ndeck = create_deck()\nhand1, hand2 = deal_cards(deck)\npairs1 = find_pairs(hand1)\npairs2 = find_pairs(hand2)\n\nprint(pairs1)\nprint(pairs2)\nif ___________: # Compare the length of the two lists\n    print(\"Player 1 wins!\")\nelif _____________:\n    print(\"Player 2 wins!\")\nelse:\n    print(\"It's a tie!\")\n\nLists are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later on, you will see programs using lists to do things that would be difficult or impossible to do without them.\nLists are a sequence data type that is mutable, meaning that their contents can change. Tuples and strings, though also sequence data types, are immutable and cannot be changed. A variable that contains a tuple or string value can be overwritten with a new tuple or string value, but this is not the same thing as modifying the existing value in place — like, say, the append() or remove() methods do on lists. Because tuples are immutable, they don’t provide methods like sort() and reverse(), which modify existing lists. However Python provides the built-in functions sorted() and reversed(), which take any sequence as a parameter and return a new sequence with the same elements in a different order.\nVariables do not store list objects directly; they store references to lists. This is an important distinction when you are copying variables or passing lists as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the list might impact another variable in your program. You can use copy() or deepcopy() if you want to make changes to a list in one variable without modifying the original list. It is noted that slicing also create a new list object."
  },
  {
    "objectID": "05_Dictionaries_sets.html#dictionaries",
    "href": "05_Dictionaries_sets.html#dictionaries",
    "title": "5  Other collections - Dictionaries and Sets",
    "section": "5.1 Dictionaries",
    "text": "5.1 Dictionaries\nWe’ve discussed three built-in sequence collections — strings, lists and tuples. Now, we consider the built-in non-sequence collections — dictionaries and sets. A dictionary is an unordered collection which stores key–value pairs that map immutable keys to values, just as a conventional dictionary maps words to definitions. A set is an unordered collection of unique immutable elements.\nLike a list, a dictionary is a mutable collection of many values, but more general. In a list, the index positions have to be integers; in a dictionary, the indices can be any immutable data type. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. Each key maps to a value. The association of a key and a value is called a key-value pair or sometimes an item.\nA dictionary’s keys must be immutable (such as strings, integers or tuples) and unique (that is, no duplicates). However, multiple keys can have the same value.\n\n\n\n\nsource: https://pynative.com/python-dictionaries/\n\n\nIt is noted that as of Python 3.7, dictionary items maintain the order in which they are inserted into the dictionary. However, dictionaries are considered unordered collections and do not write code that depends on the order of the key–value pairs.\n\nAs an example, we’ll build a dictionary that maps from subjects to grades, so the keys are string while the values are integers. The function dict creates a new dictionary with no items.\n\ntype({}) # {} also treated as dict in Python\n\ndict\n\n\n\ngrade = dict()\ntype(grade), grade\n\n(dict, {})\n\n\nTo add/update items to the dictionary, you can again use subscript operator (square brackets):\n\ngrade['calculus'] = 85 # Key:'calculus', value: 85\nprint(grade) # Note that key and value are separate by colon\n\n{'calculus': 85}\n\n\nYou can create a dictionary that contains multiple items by enclosing in curly braces, {}, a comma-separated list of key–value pairs, each of the form key:value.\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'computer programming':90, 'linear algebra':95}\ngrade\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95}\n\n\nYou can store them using separate lists for subjects and scores, but the following update and maintenance will become tedious:\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nscore = [85, 80, 90, 95]\nYou can now use the keys to look up the corresponding values:\n\nprint(grade['computer programming'])\n\n90\n\n\nYou can obtain the number of items using len()\n\nlen(grade)\n\n4\n\n\n\nNote that you can’t access items in them using integer indexes like grade[0] because it is unordered collections. (Consider the case when you use 4, 2, 1, 0 as the keys). Therefore, you can’t use slice syntax for dictionaries.\n\nTrying to access a key that does not exist in a dictionary will result in a KeyError error message, much like a list’s “out-of-range” IndexError error message.\n\ngrade['English']\n\nKeyError: 'English'\n\n\nTo add or delete an entry, it is similar to list\n\ngrade['English'] = 100\ngrade\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95,\n 'English': 100}\n\n\nYou can delete a key–value pair from a dictionary with the del statement:\n\ndel grade['English']\ngrade\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95}\n\n\n\n5.1.1 The keys(), values(), and items() Methods\nThere are three dictionary methods that will return list-like values of the dictionary’s keys, values, or both keys and values: keys(), values(), and items(). The values returned by these methods are not true lists, but these data types (dict_keys, dict_values, and dict_items, respectively) can be used in for loops (Just like range object)!\nIf you want a true list from one of these methods, pass its list-like return value to the list() function\n\nsubject = list(grade.keys())\nscore = list(grade.values())\nprint(subject)\nprint(score)\n\n['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n[85, 80, 90, 95]\n\n\n\nfor v in grade.values():\n    print(v)\n\n85\n80\n90\n95\n\n\nHere, a for loop iterates over each of the values in the grade dictionary. A for loop can also iterate over the keys:\n\nfor k in grade.keys():\n    print(k)\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\n\nfor k in grade:\n    print(k)\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\n\nNote that by default, it will traverse over the keys!\n\nDictionaries have a method called items() that returns a list of tuples, where each tuple is a key-value pair:\n\nlist(grade.items())\n\n[('calculus', 85),\n ('introduction to mathematics', 80),\n ('computer programming', 90),\n ('linear algebra', 95)]\n\n\nCombining items(), multiple assignment, and for, you can see a nice code pattern for traversing the keys and values of a dictionary in a single loop:\n\nfor key, val in grade.items():\n    print(key,val)\n\ncalculus 85\nintroduction to mathematics 80\ncomputer programming 90\nlinear algebra 95\n\n\n\n5.1.1.1 Checking Whether a Key or Value Exists in a Dictionary\nRecall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary\n\n'calculus' in grade, 'English' in grade.keys(), 85 in grade.values() \n\n(True, False, True)\n\n\n\nAgain, it will check keys by default. Therefore, in the previous example, 'calculus' in grade is essentially a shorter version of writing 'calculus' in grade.keys(). This is always the case: if you ever want to check whether a value is (or isn’t) a key in the dictionary, you can simply use the in (or not in) keyword with the dictionary itself.\n\n\n\n5.1.1.2 Retrieve value uisng get() Method\n\nif 'English' in grade:\n    e_score= grade['English']\n\nIt’s tedious to check whether a key exists in a dictionary before accessing that key’s value. Fortunately, dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\npicnicItems = {'apples': 5, 'cups': 2}\nprint('I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.') \nprint('I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.')\n\nI am bringing 2 cups.\nI am bringing 0 eggs.\n\n\nBecause there is no ‘eggs’ key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get(), the code would have caused a KeyError message\n\npicnicItems = {'apples': 5, 'cups': 2}\n'I am bringing ' + str(picnicItems['eggs']) + ' eggs.'\n\nKeyError: 'eggs'\n\n\n\n\n5.1.1.3 Update value using setdefault() Method\nYou’ll often have to set a value in a dictionary for a certain key only if that key does not already have a value. The code looks something like this:\n\nspam = {'name': 'Pooka', 'age': 5}\nif 'color' not in spam:\n    spam['color'] = 'black'\n\nThe setdefault() method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist.\nThe setdefault() method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a string.\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    if character not in count:\n        count[character] = 0\n    count[character] = count[character] + 1\n\nprint(count)    \n\n{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}\n\n\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    count.setdefault(character, 0)\n    count[character] = count[character] + 1\n\nprint(count)    \n\n{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}\n\n\nYou can view the execution of this program at https://autbor.com/setdefault. The program loops over each character in the message variable’s string, counting how often each character appears. The setdefault() method ensures that the key is in the count dictionary (with a default value of 0) so the program doesn’t throw a KeyError error when count[character] = count[character] + 1 is executed!\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time.\n\n\n\n5.1.2 Pretty Printing\nIf you import the pprint module into your programs, you’ll have access to the pprint() function that will “pretty print” a dictionary’s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides.\n\nimport pprint\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    count.setdefault(character, 0)\n    count[character] = count[character] + 1\n\npprint.pprint(count)\n\n{' ': 13,\n ',': 1,\n '.': 1,\n 'A': 1,\n 'I': 1,\n 'a': 4,\n 'b': 1,\n 'c': 3,\n 'd': 3,\n 'e': 5,\n 'g': 2,\n 'h': 3,\n 'i': 6,\n 'k': 2,\n 'l': 3,\n 'n': 4,\n 'o': 2,\n 'p': 1,\n 'r': 5,\n 's': 3,\n 't': 6,\n 'w': 2,\n 'y': 1}\n\n\nYou can view the execution of this program at https://autbor.com/pprint/. This time, when the program is run, the output looks much cleaner, with the keys sorted. The pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries.\n\n5.1.2.1 Dictionary Comprehensions\nDictionary comprehensions provide a convenient notation for quickly generating dictionaries, often by mapping one dictionary to another. For example, in a dictionary with unique values, you can reverse the key–value pairs:\n\nmonths = {'January': 1, 'February': 2, 'March': 3}\n\n\nmonths2 = {number:name for name, number in months.items()}\nmonths2\n\n{1: 'January', 2: 'February', 3: 'March'}\n\n\nCurly braces delimit a dictionary comprehension, and the expression to the left of the for specifies a key–value pair of the form key:value. The comprehension iterates through months.items(), unpacking each key–value pair tuple into the variables name and number. The expression number:name reverses the key and value, so the new dictionary maps the month numbers to the month names.\nA dictionary comprehension also can map a dictionary’s values to new values. The following comprehension converts a dictionary of names and lists of grades into a dictionary of names and grade-point averages. The variables k and v commonly mean key and value:\n\ngrades = {'Sue': [98, 87, 94], 'Bob': [84, 95, 91]}\n\n{'Bob': [84, 95, 91], 'Sue': [98, 87, 94]}\n\n\n\ngrades2 = {k:sum(v)/len(v) for k, v in grades.items()}\ngrades2\n\n{'Sue': 93.0, 'Bob': 90.0}\n\n\n\nNote the above is nested structure, with a list in a dictionary!\n\n\n\n\n5.1.3 Using Data Structures to Model Real-World Things\nA tic-tac-toe board looks like a large hash symbol (#) with nine slots that can each contain an X, an O, or a blank. To represent the board with a dictionary, you can assign each slot a key, as shown in below:\n\n\n\n\n1\n2\n3\n\n\n\n\n4\n5\n6\n\n\n7\n8\n9\n\n\n\n\nYou can use string values to represent what’s in each slot on the board: ‘X’, ‘O’, or ’ ’ (a space). Thus, you’ll need to store nine strings. You can use a dictionary of values for this. The string value with the key ‘3’ can represent the top-right corner, the string value with the key ‘7’ can represent the bottom-left corner, the string value with the key ‘5’ can represent the middle, and so on. This dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named board.\n\nboard = {'1': ' ', '2': ' ', '3': ' ',\n         '4': ' ', '5': ' ', '6': ' ',\n         '7': ' ', '8': ' ', '9': ' '}\n\nA board where player O has won by placing Os across the top might look like this:\n\nboard = {'1': 'O', '2': 'O', '3': 'O',\n         '4': 'X', '5': 'X', '6': ' ',\n         '7': ' ', '8': ' ', '9': 'X'}\nprint(board)\n\n{'1': 'O', '2': 'O', '3': 'O', '4': 'X', '5': 'X', '6': ' ', '7': ' ', '8': ' ', '9': 'X'}\n\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter5/\n\nOf course, the player should see only what is printed to the screen, not the contents of variables. Let’s create a function to print the board dictionary onto the screen:\n\ndef printBoard(board):\n    \"\"\"\n    The function that prints out the board in a square shape\n    \"\"\"\n    print(board['1'] + '|' + board['2'] + '|' + board['3'])\n    print('-+-+-')\n    print(board['4'] + '|' + board['5'] + '|' + board['6'])\n    print('-+-+-')\n    print(board['7'] + '|' + board['8'] + '|' + board['9'])\n\nprintBoard(board)\n\nO|O|O\n-+-+-\nX|X| \n-+-+-\n | |X\n\n\nThe printBoard() function can handle any tic-tac-toe data structure you pass it!\nNow let’s add code that allows the players to enter their moves.\n\nboard = {'1': ' ', '2': ' ', '3': ' ',\n         '4': ' ', '5': ' ', '6': ' ',\n         '7': ' ', '8': ' ', '9': ' '}\n\nboard['1'] = 'O'  # Update the board\nprintBoard(board)\nboard['5'] = 'X' \nprintBoard(board)\n\nO| | \n-+-+-\n | | \n-+-+-\n | | \nO| | \n-+-+-\n |X| \n-+-+-\n | | \n\n\nWe can also check whether player has won the game or not using the following code:\n\np = 'O' # Check whether 'O' has won the game or not\n\n((board['1'] == board['2'] == board['3'] == p) or  # Across top\n(board['4'] == board['5'] == board['6'] == p) or  # Across middle\n(board['7'] == board['8'] == board['9'] == p) or  # Across boardottom\n(board['1'] == board['4'] == board['7'] == p) or  # Down left\n(board['2'] == board['5'] == board['8'] == p) or  # Down middle\n(board['3'] == board['6'] == board['9'] == p) or  # Down right\n(board['3'] == board['5'] == board['7'] == p) or  # Diagonal\n(board['1'] == board['5'] == board['9'] == p))  # Diagonal\n\nFalse\n\n\n\nNote that by enclosing the condiations with (), we do not have to add \\ for multipline commands.\n\n\n5.1.4 Exercise 1: Tic-tac-toe is a classic pencil-and-paper game played on a 3 × 3 grid. Players take turns placing their ‘X’ or ‘O’ marks, trying to get three in a row. Try to complete the following game design by complete three functions getBlankBoard(), isValidSpace() and isBoardFull().\n\n\n%%writefile ttt.py\n\ndef printBoard(board):\n    \"\"\"\n    The function that prints out the board in a square shape\n    \"\"\"\n    print(board['1'] + '|' + board['2'] + '|' + board['3'])\n    print('-+-+-')\n    print(board['4'] + '|' + board['5'] + '|' + board['6'])\n    print('-+-+-')\n    print(board['7'] + '|' + board['8'] + '|' + board['9'])\n\n\ndef updateBoard(board, space, mark):\n    \"\"\"Sets the space on the board to mark.\"\"\"\n    board[space] = mark\n\ndef isWinner(board, player):\n    \"\"\"Return True if player is a winner on this TTTBoard.\"\"\"\n    # Shorter variable names used here for readablility:\n    b, p = board, player\n    # Check for 3 marks across 3 rows, 3 columns, and 2 diagonals.\n    return ((b['1'] == b['2'] == b['3'] == p) or  # Across top\n            (b['4'] == b['5'] == b['6'] == p) or  # Across middle\n            (b['7'] == b['8'] == b['9'] == p) or  # Across bottom\n            (b['1'] == b['4'] == b['7'] == p) or  # Down left\n            (b['2'] == b['5'] == b['8'] == p) or  # Down middle\n            (b['3'] == b['6'] == b['9'] == p) or  # Down right\n            (b['3'] == b['5'] == b['7'] == p) or  # Diagonal\n            (b['1'] == b['5'] == b['9'] == p))    # Diagonal\n\ndef getBlankBoard():\n    \"\"\"Create a new, blank tic-tac-toe board.\"\"\"\n    # Map of space numbers: 1|2|3\n    #                       -+-+-\n    #                       4|5|6\n    #                       -+-+-\n    #                       7|8|9\n    # Keys are '1' through '9', the values are 'X', 'O', or ' ':\n    # Initialize all spaces of the board as blank string ' ' using loop or dictionary complehention\n    ALL_SPACES = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    ______________________________\n    return board\n\ndef isValidSpace(board, space):\n    \"\"\"Returns True if the space on the board is a valid space number (1-9)\n    and the space is blank.\"\"\"\n    ALL_SPACES = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    return ____________ and ________________\n\ndef isBoardFull(board):\n    \"\"\"Return True if every space on the board has been taken.\"\"\"\n    for v in ________:  # Traverse over the board to see if there is blank space\n        if v == ' ':\n            return False  # If any space is blank, return False.\n    return True  # No spaces are blank, so return True\n\n\n\n# The logic of the game\nprint('Welcome to Tic-Tac-Toe!')\ngameBoard = getBlankBoard()  # Create a TTT board dictionary.\ncurrentPlayer, nextPlayer = 'X', 'O'  # X goes first, O goes next.\n\nwhile True:  # Main game loop.\n    # 1. Display the board on the screen:\n    printBoard(gameBoard)\n\n    # 2. Keep asking the player until they enter a number 1-9:\n    move = None\n    while not isValidSpace(gameBoard, move):\n        print('What is ' + currentPlayer + '\\'s move? (1-9)')\n        move = input('&gt; ')\n    updateBoard(gameBoard, move, currentPlayer)  # Make the move.\n\n    # 3. Check if the game is over:\n    if isWinner(gameBoard, currentPlayer):  # Check for a winner.\n        printBoard(gameBoard)\n        print(currentPlayer + ' has won the game!')\n        break\n    elif isBoardFull(gameBoard):  # Check for a tie.\n        print(printBoard(gameBoard))\n        print('The game is a tie!')\n        break\n    # 4. Switch turns to the next player using multiple assignment:\n    currentPlayer, nextPlayer = nextPlayer, currentPlayer\nprint('Thanks for playing!')\n\nOverwriting ttt.py\n\n\n\n\n5.1.5 Nested Dictionaries and Lists\n\n5.1.5.1 A List of Dictionaries\nConsider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien:\n\nalien_0 = {'color': 'green', 'points': 5}\n\nThe alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a screen full of aliens. How can you manage a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien.\n\naliens = []\n# Make 30 green aliens.\nfor alien_number in range(30):\n    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}\n    aliens.append(new_alien)\n# Show the first 5 aliens.\nfor alien in aliens[:5]:\n    print(alien)\nprint(\"...\")\n# Show how many aliens have been created.\nprint(f\"Total number of aliens: {len(aliens)}\")\n\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n...\nTotal number of aliens: 30\n\n\nThese aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progresses. When it’s time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this:\n\nfor alien in aliens[:3]:\n    if alien['color'] == 'green':\n        alien['color'] = 'yellow'\n        alien['speed'] = 'medium'\n        alien['points'] = 10\n\naliens[:10]\n\n[{'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'}]"
  },
  {
    "objectID": "05_Dictionaries_sets.html#sets",
    "href": "05_Dictionaries_sets.html#sets",
    "title": "5  Other collections - Dictionaries and Sets",
    "section": "5.2 Sets",
    "text": "5.2 Sets\nA set is an unordered collection of unique values. Sets may contain only immutable objects, like strings, ints, floats and tuples that contain only immutable elements.\nThe following code creates a set of strings named colors:\n\ncolors = {'red', 'orange', 'yellow', 'green', 'red', 'blue'} # Similar to set in math\ncolors\n\n{'blue', 'green', 'orange', 'red', 'yellow'}\n\n\nNotice that the duplicate string 'red' was ignored (without causing an error). An important use of sets is duplicate elimination, which is automatic when creating a set. Also, the resulting set’s values may not be displayed in the same order as they were listed! Though the color names are displayed in sorted order, sets are unordered. You should not write code that depends on the order of their elements!\n\nNote that we also use curly bracket to create a set!\n\nThough sets are iterable, they are not sequences and do not support indexing and slicing with square brackets, [].\n\ncolors[0]\n\nTypeError: 'set' object is not subscriptable\n\n\nYou can determine the number of items in a set with the built-in len() function:\n\nlen(colors)\n\n5\n\n\nYou can check whether a set contains a particular value using the in and not in operators:\n\n'red' in colors, 'purple' not in colors\n\n(True, True)\n\n\nSets are iterable, so you can process each set element with a for loop:\n\nfor color in colors: # {'blue', 'green', 'orange', 'red', 'yellow'}\n    print(color, end=' ')\n\ngreen blue red yellow orange \n\n\nSets are unordered, so there’s no significance to the iteration order!\n\n5.2.1 Creating a Set with the Built-In set() Function\nYou can create a set from another collection of values by using the built-in set() function — here we create a list that contains several duplicate integer values and use that list as set’s argument:\n\nnumbers = list(range(10)) + list(range(5))\nnumbers\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4]\n\n\n\nset(numbers)\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nIf you need to create an empty set, you must use the set() function with empty parentheses, rather than empty braces, {}, which represent an empty dictionary:\n\nset()\n\nset()\n\n\n\nPython displays an empty set as set() to avoid confusion with Python’s string representation of an empty dictionary ({}).\n\n\n\n5.2.2 Set Operators and Methods\nSets are mutable — you can add and remove elements, but set elements must be immutable. Therefore, a set cannot have other sets as elements.\n\n{6,5,'a'}\n\n{5, 6, 'a'}\n\n\n\n{7,3,{3,5,7}}\n\nTypeError: unhashable type: 'set'\n\n\n\n{7,3,[3,5,7]}\n\nTypeError: unhashable type: 'list'\n\n\n\n5.2.2.1 Methods for Adding and Removing Elements\nHere we first discuss operators and methods that modify an existing set.\nSet method update() performs a union operation modifying the set in-place — the argument can be any iterable:\n\nnumbers = {1, 3, 5}     \nnumbers.update(range(10)) \nnumbers\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nSet method add() inserts its argument if the argument is not already in the set; otherwise, the set remains unchanged:\n\nnumbers.add(17)\nnumbers.add(3)\nnumbers\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 17}\n\n\nSet method remove() removes its argument from the set — a KeyError occurs if the value is not in the set:\n\nnumbers.remove(3)\nnumbers\n\n{0, 1, 2, 4, 5, 6, 7, 8, 9, 17}\n\n\n\nnumbers.remove(11)\n\nKeyError: 11\n\n\nMethod discard() also removes its argument from the set but does not cause an exception if the value is not in the set.\n\nnumbers.discard(1)\nnumbers\n\n{2, 4, 5, 6, 7, 8, 9, 17}\n\n\n\nnumbers.discard(0)\n\n\n\n\n5.2.3 Mathematical Set Operations\nThe operators and methods presented in this section each result in a new set!\n\n5.2.3.1 Union\nThe union of two sets is a set consisting of all the unique elements from both sets. You can calculate the union with the | operator or with the set union() method:\n\n{1, 3, 5} | {2, 3, 4}\n\n{1, 2, 3, 4, 5}\n\n\n\n{1, 3, 5}.union([20, 20, 3, 40, 40])\n\n{1, 3, 5, 20, 40}\n\n\nThe operands of the binary set operators, like |, must both be sets. The corresponding set methods may receive any iterable object as an argument — we passed a list. When a mathematical set method receives a non-set iterable argument, it first converts the iterable to a set, then applies the mathematical operation.\n\n\n5.2.3.2 Intersection\nThe intersection of two sets is a set consisting of all the unique elements that the two sets have in common. You can calculate the intersection with the & operator or with the set intersection() method:\n\n{1, 3, 5} & {2, 3, 4}\n\n{3}\n\n\n\n{1, 3, 5}.intersection([1, 2, 2, 3, 3, 4, 4])\n\n{1, 3}\n\n\n\n\n5.2.3.3 Difference\nThe difference between two sets is a set consisting of the elements in the left operand that are not in the right operand. You can calculate the difference with the - operator or with the set difference() method:\n\n{1, 3, 5} - {2, 3, 4}\n\n{1, 5}\n\n\n\n{1, 3, 5, 7}.difference([2, 2, 3, 3, 4, 4])\n\n{1, 5, 7}\n\n\n\n\n5.2.3.4 Symmetric Difference\nThe symmetric difference between two sets is a set consisting of the elements of both sets that are not in common with one another. You can calculate the symmetric difference with the ^ operator or with the set symmetric_difference method:\n\n{1, 3, 5} ^ {2, 3, 4}\n\n{1, 2, 4, 5}\n\n\n\n{1, 3, 5, 7}.symmetric_difference([2, 2, 3, 3, 4, 4])\n\n{1, 2, 4, 5, 7}\n\n\n\n\n5.2.3.5 Disjoint\nTwo sets are disjoint if they do not have any common elements. You can determine this with the set isdisjoint() method:\n\n{1, 3, 5}.isdisjoint({2, 4, 6})\n\nTrue\n\n\n\n{1, 3, 5}.isdisjoint({4, 6, 1})\n\nFalse\n\n\n\n\n\n5.2.4 Set Comprehensions\nLike dictionary comprehensions, you define set comprehensions in curly braces. Let’s create a new set containing only the unique even values in the list numbers:\n\nnumbers = [1, 2, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 10]\nevens = {item for item in numbers if item % 2 == 0}\n\nevens\n\n{2, 4, 6, 8, 10}\n\n\n\n\n5.2.5 Sorting the set and dictionary\nAs we mentioned last week, data types like tuples don’t provide methods like sort(). However Python provides the built-in function sorted(), which takes any sequence as a parameter and returns a new container with the same elements in a different order. You can also apply sorted to the set, but the returning container will be list.\n\nhelp(sorted)\n\nHelp on built-in function sorted in module builtins:\n\nsorted(iterable, /, *, key=None, reverse=False)\n    Return a new list containing all items from the iterable in ascending order.\n    \n    A custom key function can be supplied to customize the sort order, and the\n    reverse flag can be set to request the result in descending order.\n\n\n\n\nRANKS = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n\ndef rank_key(card):\n    return RANKS.index(card)\n\nori_set = {\"A\", \"2\", \"7\", \"4\", \"Q\"}\nprint(sorted(ori_set))\nsorted_list = sorted(ori_set, key=rank_key) \n# Each element will be replaced by the output of rank_key() and sorts!\nprint(sorted_list)\n\n['2', '4', '7', 'A', 'Q']\n['A', '2', '4', '7', 'Q']\n\n\nNote that we have changed the behavior of the sorted() function by providing the custom key that allows us to sort the data in a specific order using the predefined list and the index() function.\nIf you would like to sort the dictionary, you need to use the items() method (Otherwise, it will only return keys). The returning container will again be a list:\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'introduction to computer science':90, 'linear algebra':95}\nsorted_list = sorted(grade.items())\nprint(sorted_list)\n\n[('calculus', 85), ('introduction to computer science', 90), ('introduction to mathematics', 80), ('linear algebra', 95)]\n\n\nIf you would like to sort by the value, use the following code:\n\ndef value_key(x):\n    return x[1]\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'computer programming':90, 'linear algebra':95}\nsorted_dict = sorted(grade.items(), key=value_key)\nprint(sorted_dict)\n\n[('introduction to mathematics', 80), ('calculus', 85), ('computer programming', 90), ('linear algebra', 95)]\n\n\n\n5.2.6 Exercise 2: Try to design a program that counts the number of unique characters in a string. Be sure to exclude the punctuation and white space and the character with upper and lower cases are treated as different characters.\n\n\n\n\n\nsource: https://realpython.com/python-encodings-guide/\n\n\nimport string\n\n# You can obtain all the punctuations using the following attribute\nstring.punctuation\n\n'!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'\n\n\n\n# Sample text\ntext = \"The quick brown fox jumped over the lazy dog. The dog didn't seem to mind!\"\n\n# Create a set of punctuation characters\npunctuation = set(string.punctuation)\n    \n# Create a set of all characters included in the text\nall_chars = _____________\n    \n# Find the difference between the two sets to get the non-punctuation characters\nnon_punctuation_chars = ____________________________\n# Also remove the whitespace\n_____________________________\n    \n# Count the number of non-punctuation characters\nnum_unique_chars = len(non_punctuation_chars)\n\nprint(\"Number of unique characters:\", num_unique_chars)\n\n# Sanity check\nassert num_unique_chars == 27\n\nNumber of unique characters: 27\n\n\nIn this chapter, we discussed Python’s dictionary and set collections. They are both unorder, mutable and do not allow duplicates.\nWe said what a dictionary is and presented several examples. We showed the syntax of key–value pairs and showed how to use them to create dictionaries with comma-separated lists of key–value pairs in curly braces, {}. You also created dictionaries with dictionary comprehensions. You used square brackets, [], to retrieve the value corresponding to a key, and to insert and update key–value pairs. You also used the dictionary method update to change a key’s associated value. You iterated through a dictionary’s keys, values and items.\nYou created sets of unique immutable values. You combined sets with set operators and methods, changed sets’ values with the mutable set operations and created sets with set comprehensions. You saw that sets are mutable.\nA short comparison of the containers is shown below:\n\n\n\n\n\n\n\n\n\n\nFeature\nList\nTuple\nDictionary\nSet\n\n\n\n\nMutable (Can be modified in place)\nYes\nNo\nYes (keys are immutable)\nYes\n\n\nIterable (Can be use in for loop)\nYes\nYes\nYes\nYes\n\n\nOrdered (Can access by index, slicing)\nYes\nYes\nNo\nNo\n\n\nDuplicate Values\nAllowed\nAllowed\nNot in keys\nNot allowed"
  },
  {
    "objectID": "06_Manipulating_string.html#string",
    "href": "06_Manipulating_string.html#string",
    "title": "6  Manipulating Strings",
    "section": "6.1 String",
    "text": "6.1 String\nText is one of the most common forms of data your programs will handle. You already know how to concatenate two string together with the + operator, but you can do much more than that! You can extract partial strings from string just like sequence, add or remove spacing, convert letters to lowercase or uppercase, and check that strings are formatted correctly!\nThere are several ways to create a new string; the simplest is to enclose the elements in single or double quotes:\n\ntype(''), type(\"\")\n\n(str, str)\n\n\n\nOne benefit of using double quotes is that the string can have a single quote character in it.\n\n\nprint(\"I'am fine\")\n\nI'am fine\n\n\nA string is a sequence that maps index to case sensitive characters and thus belongs to sequence data type. Anything that we can apply to the sequence can also be applied to string. For instance, you can access the items (characters) one at a time with the bracket operator:\n\nfruit = 'banana'\nfruit[1]\n\n'a'\n\n\nSo “b” is the 0th letter (“zero-th”) of “banana”, “a” is the 1th letter (“one-th”), and “n” is the 2th (“two-th”) letter.\n\n\n\n\nsource: https://www.py4e.com/html3/06-strings\n\nlen() can be used to return the number of characters in a string:\n\nlen(fruit)\n\n6\n\n\nWe can use negative indices, which count backward from the end of the string.\n\nfruit[-1], fruit[-2]\n\n('a', 'n')\n\n\nSlicing also works on string to extract a substring from the original string. Remember that we can slice sequences using [start:stop:step]. The operator [start:stop] returns the part of the string from the “start-th” character to the “stop-th” character, including the first but excluding the last with step=1. If we omit the first index (before the colon), the slice starts at the beginning of the string. If we omit the second index, the slice goes to the end of the string:\n\ns = 'Cool-Python'\n\nprint(s[:5]) #same as s[0:5] \nprint(s[5:]) #same as s[5:len(s)] \nprint(s[::2]) #same as s[0:len(s):2]\nprint(s[::]) #same as s[:] and s[0:len(s):1] =&gt; copy the string\nprint(s[::-1]) #same as s[-1:-(len(s)+1):-1] =&gt; reverse the string\n\nCool-\nPython\nCo-yhn\nCool-Python\nnohtyP-looC\n\n\nStrings are “immutable”, which means that it cannot be modified:\n\ns = \"hello\"\ns[0] = 'y' \n\nTypeError: 'str' object does not support item assignment\n\n\nThe “object” in this case, is the string and the “item” is the character you tried to assign. The best you can do is create a new string that is a variation on the original:\n\nprint(id(s))\ns = 'y' + s[1:len(s)]\nprint(id(s))\nprint(s)\n\n1956771186608\n1956805647664\nyello\n\n\nA lot of computations involve processing a string one character at a time. Often they start at the beginning, select each character in turn, do something to it, and continue until the end. The traversal of string is just like we see before:\n\ns\n\n'yello'\n\n\n\n# Test if s contains 'o'\nfor char in s: # Retrieve item (character) one by one\n    if char == 'o':\n        print(\"There is an o\")\n        break\n\nThere is an o\n\n\nThe in and not in operators can be used with strings just like with list. An expression with two strings joined using in or not in will evaluate to a Boolean True or False:\n\nprint('Hello' in 'Hello, World')\nprint('cats' not in 'cats and dogs')\n\nTrue\nFalse"
  },
  {
    "objectID": "06_Manipulating_string.html#escape-characters",
    "href": "06_Manipulating_string.html#escape-characters",
    "title": "6  Manipulating Strings",
    "section": "6.2 Escape Characters",
    "text": "6.2 Escape Characters\nAn escape character lets you use characters that are otherwise impossible to put into a string. An escape character consists of a backslash (\\) followed by the character you want to add to the string. (Despite consisting of two characters, it is commonly referred to as a singular escape character.) For example, the escape character for a single quote is \\'. You can use this inside a string that begins and ends with single quotes\n\nspam = 'Say hi to Bob\\'s mother.'\nspam\n\n\"Say hi to Bob's mother.\"\n\n\nPython knows that since the single quote in Bob\\'s has a backslash, it is not a single quote meant to end the string. The escape characters \\' and \\\" let you put single quotes and double quotes inside your strings, respectively.\n\n\n\n\nEscape character\nPrints as\n\n\n\n\n\\'\nSingle quote\n\n\n\\\"\nDouble quote\n\n\n\\\\\nBackslash\n\n\n\\t\nTab\n\n\n\\n\nNewline (line break)\n\n\n\n\n\nprint(\"Hello there!\\nHow are you?\\n\\tI\\'m doing fine.\")\n\nHello there!\nHow are you?\n    I'm doing fine.\n\n\nWhile you can use the \\n escape character to put a newline into a string, it is often easier to use multiline strings. A multiline string in Python begins and ends with either three single quotes or three double quotes. Any quotes, tabs, or newlines in between the “triple quotes” are considered part of the string.\n\nprint('''Hello there,\nHow are you?\n        I'm doing fine\n''')\n\nHello there,\nHow are you?\n        I'm doing fine\n\n\n\nNotice that the single quote character in I'm does not need to be escaped. Escaping single and double quotes is optional in multiline strings.\n\n6.2.1 Raw Strings\nYou can place an r before the beginning quotation mark of a string to make it a raw string. A raw string completely ignores all escape characters and prints any backslash that appears in the string.\n\nprint(r'That is Carol\\'s cat.')\n\nThat is Carol\\'s cat.\n\n\nBecause this is a raw string, Python considers the backslash as part of the string and not as the start of an escape character. Raw strings are helpful if you are typing strings that contain many backslashes, such as the strings used for Windows file paths like r'C:\\Users\\Al\\Desktop'."
  },
  {
    "objectID": "06_Manipulating_string.html#putting-strings-inside-other-strings",
    "href": "06_Manipulating_string.html#putting-strings-inside-other-strings",
    "title": "6  Manipulating Strings",
    "section": "6.3 Putting Strings Inside Other Strings",
    "text": "6.3 Putting Strings Inside Other Strings\nPutting strings inside other strings is a common operation in programming. So far, we’ve been using the + operator and string concatenation to do this:\n\nname = 'Al'\nage = 33\nlanguage = 'Python'\nprint(\"\\nHey! I'm \" + name + \", \" + str(age)+ \" old and I love \" + language + \" Programing\")\n\n\nHey! I'm Al, 33 old and I love Python Programing\n\n\nHowever, this requires a lot of tedious typing. A simpler approach is to use string interpolation. The format operator, % allows us to construct strings, replacing parts of the strings with the data stored in variables. When applied to integers, % is the modulus operator. But when the first operand is a string, % is the format operator.\nThe first operand is the format string, which contains one or more format specifiers that specify how the second operand is formatted. The result is a string. For example, the format specifiers %d means that the second operand should be formatted as an integer (“d” stands for “decimal”). One benefit is that str() doesn’t have to be called to convert values to strings:\n\n\n\n\nsource: https://towardsdatascience.com/python-string-interpolation-829e14e1fc75\n\n\nprint(\"\\nHey! I'm %s, %d years old and I love %s Programing\"%(name,age,language))   # Like the printf in C\n\nWe can have more control over the formatting, for instance:\n\n\n\n\nsource: https://refactored.ai/microcourse/notebook?path=content%2F02-Python_for_Data_Scientists%2F03-Data_Structures_in_python%2F01-Basic_data_types_and_operators.ipynb\n\n\na = 32\nb = 32.145\nprint('a=%4d, b=%6.2f' % (a,b))\n\n\na = 32\nb = 32.145\nprint(f'{a:4d},{b:6.2f}')\n\n  32, 32.15\n\n\nBy default, Python right-aligns numbers and left-aligns other values such as strings. The numbers after % is the total field width and the field width for the decimal part (separated by .). For values with fewer characters than the field width, the remaining character positions are filled with spaces. The %f is used to format floating points and note that variable b has been rounded.\nPython 3.6 introduced f-strings (The f is for format), which is similar to string interpolation except that braces are used instead of %s, with the expressions placed directly inside the braces. Like raw strings, f-strings have an f prefix before the starting quotation mark. (Note that it is even possible to do inline arithmetic)\n\nprint(f\"\\nHey! I'm {name}, {age+2} years old and I love {language} Programing\") \n\nWe can have more control with the f-string besides the field width, like specifying left, right and center alignment with &lt;, &gt; and ^. Note now the format specifiers are placed after the variable separated by a colon:\n\nprint(f'[{a:&lt;15d}]')\nprint(f'[{b:^9.2f}]')\n\nIn addition, you can use + before the field width specifies that a positive number should be preceded by a +. A negative number always starts with a -. To fill the remaining characters of the field with 0s rather than spaces, place a 0 before the field width (and after the + if there is one):\n\nprint(f'[{a:+10d}]')\nprint(f'[{a:+010d}]')\n\nSee https://docs.python.org/3/library/string.html#formatspec for more details.\n\nYet another is the format() method, see https://realpython.com/python-string-formatting/#toc for more details.\n\n\n6.3.1 Exercise 1: Assuming we are designing a word game called “The Mysterious Island” and we need to print the statistics of the player each time the game begins. Try to complete the following function that receives the variables from the game and displays the information that right aligns with each other using the f-string:\n\nPlayer1 Stats:\nHealth:     100/100\nExperience:   0/150\nGold:   50.00/60.00\n\n\nPlayer2 Stats:\nHealth:      60/100\nExperience: 120/150\nGold:   40.00/60.00\nHint: You can first calculate the maximal width required for each row.\n\n\n\n\ndef print_stats(player_name, health, experience, gold):\n    print(f\"{player_name} Stats:\")\n    print(f\"Health:____/100\")\n    print(f\"Experience:______/150\")\n    print(f\"Gold:_____/60.00\")\n\n\ngame_title = \"The Mysterious Island\"\n\nwelcome_message = f'Welcome to \"{game_title}\" adventure!\\n\\n'\n# 1. Print the welcome_message\nprint(welcome_message)\n\n# 2. Use string and number formatting to print out the statistics\nplayer_name = \"Player1\"\nhealth = 100\nexperience = 0\ngold = 50.000\n\nprint_stats(player_name, health, experience, gold)\n\nprint(\"\\n\")\n\nplayer_name = \"Player2\"\nhealth = 60\nexperience = 120\ngold = 40.0\n\nprint_stats(player_name, health, experience, gold)"
  },
  {
    "objectID": "06_Manipulating_string.html#string-method",
    "href": "06_Manipulating_string.html#string-method",
    "title": "6  Manipulating Strings",
    "section": "6.4 String method",
    "text": "6.4 String method\nStrings are an example of Python objects. An object contains both data (the actual string itself) and methods, which are effective functions that are built into the object and are available to any instance of the object.\nPython has a function called dir(), which lists the methods available for an object.\n\ndir(s)\n\nWhile the dir() function lists the methods, and you can use help() to get some simple documentation on a method, a better source of documentation for string methods would be https://docs.python.org/library/stdtypes.html#string-methods.\n\n6.4.1 The upper(), lower() Methods\nThe upper() and lower() string methods return a new string where all the letters in the original string have been converted to uppercase or lowercase:\n\nspam = 'Hello, world!'\nspam = spam.upper()\nprint(spam)\nspam = spam.lower()\nprint(spam)\n\nNote that these methods do not change the string itself but return new string values. If you want to change the original string, you have to call upper() or lower() on the string and then assign the new string to the variable where the original was stored. This is why you must use spam = spam.upper() to change the string in spam instead of simply spam.upper(). (This is just like if a variable eggs contains the value 10. Writing eggs + 3 does not change the value of eggs, but eggs = eggs + 3 does.). These data types are immutable and can not be modified in-place.\nThe upper() and lower() methods are helpful if you need to make a case-insensitive comparison. For example, the strings 'great' and 'GREat' are not equal to each other. But in the following small program, it does not matter whether the user types Great, GREAT, or grEAT, because the string is first converted to lowercase.\n\nprint('How are you?')\nfeeling = input()\nif feeling.lower() == 'great':\n    print('I feel great too.')\nelse:\n    print('I hope the rest of your day is good.')\n\n\n\n6.4.2 The isX() Methods\nThere are several other string methods that have names beginning with the word is. These methods return a Boolean value that describes the nature of the string. Here are some common isX() string methods:\n\nisupper()/islower() Returns True if the string has at least one letter and all the letters are uppercase or lowercase\nisalpha() Returns True if the string consists only of letters and isn’t blank\nisalnum() Returns True if the string consists only of letters and numbers and is not blank\nisdecimal() Returns True if the string consists only of numeric characters and is not blank\nisspace() Returns True if the string consists only of spaces, tabs, and newlines and is not blank\nistitle() Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters\n\n\nprint('Hello, world!'.islower()) \nprint('hello, world!'.islower())\nprint('hello'.isalpha())\nprint('hello123'.isalnum())\nprint('hello123'.isdecimal())\nprint(' '.isspace())\nprint('This Is Title Case'.istitle())\n\nThe isX() string methods are helpful when you need to validate user input. For example, the following program repeatedly asks users for their age and a password until they provide valid input:\n\nwhile True:\n    print('Enter your age:')\n    age = input()\n    if age.isdecimal():\n        break\n    print('Please enter a number for your age.')\n\nwhile True:\n    print('Select a new password (letters and numbers only):')\n    password = input()\n    if password.isalnum():\n        break\n    print('Passwords can only have letters and numbers.')\n\nIn the first while loop, we ask the user for their age and store their input in age. If age is a valid (decimal) value, we break out of this first while loop and move on to the second, which asks for a password. Otherwise, we inform the user that they need to enter a number and again ask them to enter their age. In the second while loop, we ask for a password, store the user’s input in password, and break out of the loop if the input is alpha­numeric. If it wasn’t, we’re not satisfied, so we tell the user the password needs to be alphanumeric and again ask them to enter a password.\n\n\n6.4.3 The startswith() and endswith() Methods\nThe startswith() and endswith() methods return True if the string they are called on begins or ends (respectively) with the string passed to the method; otherwise, they return False:\n\nprint('Hello, world!'.startswith('Hello'))\nprint('abc123'.endswith('12'))\n\n\n\n6.4.4 The replace() methods\nThe replace() function is like a “search and replace” operation in a word processor:\n\ngreet = 'Hello Bob'\nnstr = greet.replace('Bob','Jane')\nprint(nstr)\n\n\n\n6.4.5 The join() and split() Methods\nThe join() method is useful when you have a list of strings that need to be joined together into a single string. The join() method is called on a string, gets passed a list of strings, and returns a string. The returned string is the concatenation of each string in the passed-in list.\n\nprint(', '.join(['cats', 'rats', 'bats']))     #Separated by comma\nprint(' '.join(['My', 'name', 'is', 'Simon'])) #Separated by white space\n\n\n' and '.join(['cats', 'rats', 'bats'])\n\n'cats and rats and bats'\n\n\nNotice that the string join() calls on is inserted between each string of the list argument. For example, when join(['cats', 'rats', 'bats']) is called on the ', ' string, the returned string is 'cats, rats, bats'.\nThe split() method does the opposite: It’s called on a string and returns a list of strings.\n\n'My name is Simon'.split()\n\nBy default, the string ‘My name is Simon’ is split wherever whitespace characters such as the space, tab, or newline characters are found. These whitespace characters are not included in the strings in the returned list. You can pass a delimiter string to the split() method to specify a different string to split upon:\n\n'cats, rats, bats'.split(',')\n\nA common use of split() is to split a multiline string along the newline characters:\n\nspam = '''Dear Alice,\nHow have you been? I am fine.\nThere is a container in the fridge\nthat is labeled \"Milk Experiment.\"\n\nPlease do not drink it.\nSincerely,\nBob'''\n\nspam.split('\\n')\n\nPassing split() the argument '\\n' lets us split the multiline string stored in spam along the newlines and return a list in which each item corresponds to one line of the string.\n\n\n6.4.6 Removing Whitespace with the strip(), lstrip() and rstrip() Methods\nSometimes you may want to strip off whitespace characters (space, tab, and newline) from the left side, right side, or both sides of a string. The strip() string method will return a new string without any whitespace characters at the beginning or end. The lstrip() and rstrip() methods will remove whitespace characters from the left and right ends, respectively.\n\nspam = '    Hello, World    \\n'\nspam.strip()\n\n'Hello, World'\n\n\n\nspam.lstrip()\n\n\nspam.rstrip()\n\n\n6.4.7 Exercise 2: When editing the markdown document, you can create a bulleted list by putting each list item on its own line and placing a - in front. But say you have a really large list to which you want to add bullet points. You could just type those - at the beginning of each line, one by one. Or you could automate this task with a short Python program! For example, if I have following text:\n\nLists of resources\nLists of books\nLists of videos\nLists of blogs\nAfter running the program, the text should contain the following:\n- Lists of resources\n- Lists of books\n- Lists of videos\n- Lists of blogs\n\n\n\n\ntext = \"\"\"Lists of resources\nLists of books\nLists of videos\nLists of blogs\"\"\"\n\n# 1. Separate lines into list using string method.\nlines = text.________\n\n# 2. Add -\nfor i, line in enumerate(lines):    # loop through all indexes for \"lines\" list\n    lines[i] = ________             # add - to each string in \"lines\" list\n\n# 3. Use string method to conctenate list of strings back to string\ntext = _____________\nprint(text)\n\nText is a common form of data, and Python comes with many helpful string methods to process the text stored in string. You will make use of indexing, slicing, and string methods in almost every Python program you write. The programs you are writing now don’t seem too sophisticated—they don’t have graphical user interfaces with images and colorful text. So far, you’re displaying text with print() and letting the user enter text with input(). However, another way to manipulate large amounts of text is by reading and writing files directly off the hard drive. You’ll learn how to do this with Python later on.\nThat just about covers all the basic concepts of Python programming! You’ll continue to learn new concepts throughout the rest of this course, but you now know enough to start writing some useful programs that can automate tasks. If you’d like to see a collection of short, simple Python programs built from the basic concepts you’ve learned so far, check out https://github.com/asweigart/pythonstdiogames/. Try copying the source code for each program by hand and then make modifications to see how they affect the behavior of the program. Once you have an understanding of how the program works, try re-creating the program yourself from scratch. You don’t need to re-create the source code exactly; just focus on what the program does rather than how it does it."
  },
  {
    "objectID": "07_Files.html#reading-from-a-file",
    "href": "07_Files.html#reading-from-a-file",
    "title": "7  Files and Exceptions",
    "section": "7.1 Reading from a File",
    "text": "7.1 Reading from a File\nNow that you’ve mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable.\nAn incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file.\n\n7.1.1 Reading the Contents of a File\nTo begin, we need a file with a few lines of text in it. Let’s start with a file that contains pi to 30 decimal places:\n\n%%writefile pi_digits.txt\n3.1415926535\n  8979323846\n  2643383279\n\nHere’s a program that opens this file, reads it, and prints the contents of the file to the screen:\n\nfile_object = open('pi_digits.txt')\nprint(file_object.read())\nfile_object.close()\n\n3.1415926535\n  8979323846\n  2643383279\n\n\n\nTo do any work with a file, even just printing its contents, you first need to open the file to access it. The open() function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that’s currently being executed is stored. The open() function returns an object representing the file. Here, open('pi_digits.txt') returns an object representing pi_digits.txt. Python assigns this object to file_object, which we’ll work with later in the program.\n\n# A recommended way:\nwith open('pi_digits.txt') as file_object: #  file_object = open('pi_digits.txt')\n    contents = file_object.read()          #  We do not have to call file_object.close()\nprint(contents.strip())\n\n3.1415926535\n  8979323846\n  2643383279\n\n\nThe keyword with closes the file once access to it is no longer needed. Notice how we call open() in this program but not close(). You could open and close the file by calling open() and close(), but if a bug in your program prevents the close() method from being executed, the file may never close! This may seem trivial, but improperly closed files can cause data to be lost or corrupted.\nOnce we have a file object representing pi_digits.txt, we use the read() method in the second line of our program to read the entire contents of the file and store it as one long string in contents. Since read() returns an empty string when it reaches the end of the file; this empty string shows up as a blank line. If you want to remove the extra blank line, you can use strip() in the call to print().\n\nIt’s not always easy to know exactly when you should close a file, but with the structure shown here, Python will figure that out for you. All you have to do is open the file and work with it as desired, trusting that Python will close it automatically when the with block finishes execution.\n\n\n\n7.1.2 File Paths\nSometimes, depending on how you organize your work, the file you want to open won’t be in the same directory as your program file. To get Python to open files from a directory other than the one where your program file is stored, you need to provide a file path , which tells Python to look in a specific location on your system. A relative file path will tell Python to look for a given location relative to the directory where the currently running program file is stored. For example, you’d write:\nwith open('text_files/filename.txt') as file_object:\nThis line tells Python to look for the desired .txt file in the folder text_files and assumes that text_files is located in the current directory.\n\nWindows systems use a backslash (\\) instead of a forward slash (/) when displaying file paths, but you can still use forward slashes in your code.\n\n\n!mkdir text_files\n\n\n%%writefile text_files/pi_digits2.txt\n3.1415926535\n  8979323846\n  2643383279\n\nWriting text_files/pi_digits2.txt\n\n\n\nwith open('text_files/pi_digits2.txt') as file_object:\n    contents = file_object.read()\nprint(contents.strip())\n\n3.1415926535\n  8979323846\n  2643383279\n\n\nYou can also tell Python exactly where the file is on your computer regardless of where the program that’s being executed is stored. This is called an absolute file path. Absolute paths are usually longer than relative paths, so it’s helpful to assign them to a variable and then pass that variable to open():\nfile_path = '/home/phonchi/other_files/text_files/filename.txt'\nwith open(file_path) as file_object:\n\n\n7.1.3 Reading Line by Line\nWhen you’re reading a file, you’ll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. You can use a for loop on the file object to examine each line from a file one at a time:\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object: # file_object is also iterable!\n    for line in file_object:\n        print(line.strip())\n\n3.1415926535\n8979323846\n2643383279\n\n\nTo examine the file’s contents, we work through each line in the file by looping over the file object. Since there is a newline in each line of file and the print function adds its own newline each time we call it, so we will end up with two newline characters at the end of each line: one from the file and one from print(). Using strip() on each line in the print() call eliminates these extra blank lines.\n\n\n7.1.4 Making a List of Lines from a File\nWhen you use with, the file object returned by open() is only available inside the with block that contains it. If you want to retain access to a file’s contents outside the with block, you can store the file’s lines in a list inside the block and then work with that list!\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n    lines = file_object.readlines()\n\nprint(lines) # List of strings\npi_string = ''\nfor line in lines:\n    pi_string += line.strip()\n    \nprint(pi_string)\nprint(len(pi_string)) # The string is 32 characters long because it also includes the leading 3 and a decimal point\n\n['3.1415926535\\n', '  8979323846\\n', '  2643383279\\n']\n3.141592653589793238462643383279\n32\n\n\nThe readlines() method takes each line from the file and stores it in a list. This list is then assigned to lines, which we can continue to work with after the with block ends. Here, we create a variable, pi_string, to hold the digits of pi. We then create a loop that adds each line of digits to pi_string and removes the newline character from each line.\n\nWhen Python reads from a text file, it interprets all text in the file as a string. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the int() function or convert it to a float using the float() function.\n\n\n\n7.1.5 Writing to a File\nOne of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program finishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later!\n\n7.1.5.1 Writing to an Empty File\nTo write text to a file, you need to call open() with a second argument telling Python that you want to write to the file\n\nfilename = 'programming.txt'\n\nwith open(filename, 'w') as file_object:\n    file_object.write(\"We love programming!\")\n\nThe call to open() in this example has two arguments. The first argument is still the name of the file we want to open. The second argument, ‘w’, tells Python that we want to open the file in write mode. You can open a file in read mode (‘r’), write mode (‘w’), append mode (‘a’), or a mode that allows you to read and write to the file ( ‘r+’). If you omit the mode argument, Python opens the file in read-only mode by default. Here, we use the write() method on the file object to write a string to the file.\n\nPython can only write strings to a text file. If you want to store numerical data in a text file, you’ll have to convert the data to string format first using the str() function.\n\n\nThe open() function automatically creates the file you’re writing to if it doesn’t already exist. However, be careful opening a file in write mode (‘w’) because if the file does exist, Python will erase the contents of the file before returning the file object.\n\n\nwith open(filename, 'w') as file_object:\n    print(\"12\")\n\n12\n\n\nWhile reading through a file, the system maintains a file-position pointer(index) representing the location of the next character to read. Therefore, the following code snippet will allow you to append it to the end of the file.\n\nyear = 2023\n\nwith open(filename, 'r+') as file_object:\n    spam = file_object.readlines()\n    print(file_object.tell())\n    print(len(\"We love programming!\"))\n    file_object.write(str(year))\n\n20\n20\n\n\nThe tell() function will return the current position of the file-position pointer. We can also use seek() to change the position. Checkout more details about file-position pointer here.\n\n\n\n7.1.6 Appending to a File\nIf you want to add content to a file instead of writing over existing content, you can also open the file in append mode. When you open a file in append mode, Python doesn’t erase the contents of the file before returning the file object. Any lines you write to the file will be added at the end of the file. If the file doesn’t exist yet, Python will create an empty file for you.\n\nfilename = 'programming.txt'\n\nwith open(filename, 'a') as file_object:\n    file_object.write(\"\\nWe also love finding meaning in large datasets.\\n\")\n    file_object.write(\"We love creating apps that can run in a browser.\\n\")\n\nThe write() function doesn’t add any newlines to the text you write. So we need to add newline characters if we would like to. There is also a writelines() function that can write list of strings into files."
  },
  {
    "objectID": "07_Files.html#storing-data",
    "href": "07_Files.html#storing-data",
    "title": "7  Files and Exceptions",
    "section": "7.2 Storing Data",
    "text": "7.2 Storing Data\nMany of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for visualization. Whatever the focus of your program is, you’ll store the information users provide in data structures such as lists and dictionaries. When users close a program, you’ll almost always want to save the information they entered. A simple way to do this involves storing your data using the json module.\nThe json module allows you to dump simple Python data structures into a file and load the data from that file the next time the program runs. You can also use json to share data between different programming languages. It’s a useful and portable format.\n\n7.2.0.1 Using json.dump() and json.load()\nThe json.dump() function takes two arguments: a piece of data to store and a file object it can use to store the data.\n\nimport json\n\nnumbers = [2, 3, 5, 7, 11, 13]\nfilename = 'numbers.json'\n\nwith open(filename, 'w') as f:\n    json.dump(numbers, f)\n\nNow we’ll write a program that uses json.load() to read the list back into memory\n\nfilename = 'numbers.json'\nwith open(filename) as f:\n    numbers = json.load(f)\n    \nprint(numbers)\n\n[2, 3, 5, 7, 11, 13]"
  },
  {
    "objectID": "07_Files.html#exceptions",
    "href": "07_Files.html#exceptions",
    "title": "7  Files and Exceptions",
    "section": "7.3 Exceptions",
    "text": "7.3 Exceptions\nPython uses special objects called exceptions to manage errors that arise during a program’s execution. Whenever an error makes Python unsure of what to do next, it creates an exception object. If we write code that handles the exception, the program will continue running. If you don’t handle the exception, the program will halt and show a traceback, which includes a report of the exception that was raised.\nExceptions are handled with try-except blocks. A try-except block tells Python what to do if an exception is raised. When we use try-except blocks, our programs will continue running even if things go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that we write!\n\n7.3.1 Handling the ZeroDivisionError Exception\n\nprint(5/0)\n\nZeroDivisionError: division by zero\n\n\nThe error reported at the first line in the traceback, ZeroDivisionError, is an exception object. Python creates this kind of object in response to a situation where it can’t do what we ask. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program.\nWhen we think an error may occur, you can write a try-except block to handle the exception that might be raised. We tell Python to try running some code and tell it what to do if the code results in a particular kind of exception.\n\ntry:\n    print(5/0)\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\n\nYou can't divide by zero!\n\n\nWe put print(5/0), the line that caused the error, inside a try block. If the code in a try block works, Python skips over the except block. If the code in the try block causes an error, Python looks for an except block whose error matches the one that was raised and ran the code in that block. In this example, the user sees a friendly error message instead of a traceback.\n\ntry:\n    print(5/0)\nexcept:\n    print(\"Exceptions occur!\")\n\nExceptions occur!\n\n\nIf you do not add any exception type, it will capture all exceptions!\n\n\n7.3.2 Using Exceptions to Prevent Crashes\nHandling errors correctly is especially important when the program has more work to do after the error occurs. Let’s create a simple calculator that does only division:\n\n%%writefile division_calculator.py\nprint(\"Give me two numbers, and I'll divide them.\")\nprint(\"Enter 'q' to quit.\")\n\nwhile True:\n    first_number = input(\"\\nFirst number: \")\n    if first_number == 'q':\n        break\n    second_number = input(\"Second number: \")\n    if second_number == 'q':\n        break\n    try:\n        answer = int(first_number) / int(second_number)\n    except ZeroDivisionError:\n        print(\"You can't divide by 0!\")\n    else: # Only executed if try block is succeed\n        print(answer)\n    finally: # Always executed\n        print(\"\\nGive me two numbers, and I'll divide them.\")\n        print(\"Enter 'q' to quit.\")\n\nOverwriting division_calculator.py\n\n\nHere, the error may occur on the line that performs the division, so that’s where we’ll put the try-except block. This example also includes an else block. Any code that depends on the try block executing successfully goes into the else block. In addition, the finally clause is guaranteed to execute, regardless of whether its try suite executes successfully or an exception occurs.\nWe ask Python to try to complete the division operation in a try block, which includes only the code that might cause an error. The program continues to run, and the user never sees a traceback.\n\n\n7.3.3 Handling the FileNotFoundError Exception\nOne common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename may be misspelled, or the file may not exist at all\n\nfilename = 'alice.txt'\nwith open(filename) as f: # Note it is in read mode\n    contents = f.read()\n\nFileNotFoundError: [Errno 2] No such file or directory: 'alice.txt'\n\n\n\nfilename = 'alice.txt'\ntry:\n    with open(filename) as f:\n        contents = f.read()\nexcept FileNotFoundError:\n    print(f\"Sorry, the file {filename} does not exist.\")\n\nSorry, the file alice.txt does not exist.\n\n\nIn this example, the code in the try block produces a FileNotFoundError, so Python looks for an except block that matches that error. Python then runs the code in that block, and the result is a friendly error message instead of a traceback.\n\n7.3.4 Exercise 1: Assuming we are designing a word game called “The Mysterious Island” and we need to load the statistics of the player and enemies each time the game begins. Try to complete the following functions load_data() and save_data() so that you can load the JSON file if it does not exist using the exception handling techniques you just learned.\n\n\n\n\n\nimport random\nimport time\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\ndef battle(player, enemy):\n    slow_print(f\"You encounter a {enemy['name']} with {enemy['hp']} HP!\")\n    while player['hp'] &gt; 0 and enemy['hp'] &gt; 0:\n        choice = input(\"Do you want to attack or escape? (a/e): \")\n        if choice.lower() == 'a':\n            player_damage = max(random.randint(player['attack']//2, player['attack']), 1)\n            enemy_damage = max(random.randint(enemy['attack']//2, enemy['attack']), 1)\n            slow_print(f\"You deal {player_damage} damage to the {enemy['name']}!\")\n            enemy['hp'] -= player_damage\n            if enemy['hp'] &lt;= 0:\n                break\n            slow_print(f\"The {enemy['name']} deals {enemy_damage} damage to you!\")\n            player['hp'] -= enemy_damage\n        elif choice.lower() == 'e':\n            escape_chance = random.randint(1, 10)\n            if escape_chance &lt;= 2:\n                slow_print(\"You successfully escape from the battle!\")\n                return\n            else:\n                slow_print(\"You failed to escape!\")\n                enemy_damage = max(random.randint(enemy['attack']//2, enemy['attack']), 1)\n                slow_print(f\"The {enemy['name']} deals {enemy_damage} damage to you!\")\n                player['hp'] -= enemy_damage\n        else:\n            slow_print(\"Invalid choice! Try again.\")\n    if player['hp'] &lt;= 0:\n        slow_print(\"You were defeated!\")\n        print(\"Game over!\")\n        return False\n    else:\n        slow_print(f\"You defeated the {enemy['name']}!\")\n\ndef load_data():\n    # Perform exception handling, if this is the first time you load the game\n    _____:\n        with open('game_data.json', 'r') as f:\n            data = ____________________ # Read the data here using load()\n    __________________________:\n        data = {\n            \"player\": {\n                \"name\": \"Player\",\n                \"hp\": 50,\n                \"attack\": 10\n            },\n            \"enemies\": [\n                {\n                    \"name\": \"Slime\",\n                    \"hp\": 10,\n                    \"attack\": 5\n                },\n                {\n                    \"name\": \"Goblin\",\n                    \"hp\": 25,\n                    \"attack\": 8\n                },\n                {\n                    \"name\": \"Dragon\",\n                    \"hp\": 80,\n                    \"attack\": 15\n                }\n            ]\n        }\n        save_data(data)\n    return data\n\ndef save_data(data):\n    with open('game_data.json', 'w') as f:\n        ______________# Save the data so that you can play again using dump()\n\ndata = load_data()\nplayer = data['player']\nenemies = data['enemies']\nflag = True\n\nfor enemy in enemies:\n    flag = battle(player, enemy)\n\nif flag != False: \n    print(\"Congratulations!\")\n\nYou encounter a Slime with 10 HP!\nYou deal 7 damage to the Slime!\nThe Slime deals 2 damage to you!\nInvalid choice! Try again.\nYou deal 9 damage to the Slime!\nYou defeated the Slime!\nYou encounter a Goblin with 25 HP!\nYou deal 6 damage to the Goblin!\nThe Goblin deals 8 damage to you!\nYou deal 7 damage to the Goblin!\nThe Goblin deals 5 damage to you!\nYou deal 7 damage to the Goblin!\nThe Goblin deals 4 damage to you!\nYou deal 10 damage to the Goblin!\nYou defeated the Goblin!\nYou encounter a Dragon with 80 HP!\nYou failed to escape!\nThe Dragon deals 13 damage to you!\nYou failed to escape!\nThe Dragon deals 9 damage to you!\nYou failed to escape!\nThe Dragon deals 15 damage to you!\nYou were defeated!\nGame over!\n\n\nIn this chapter, you learned how to work with files. You learned to read an entire file at once and read through a file’s contents one line at a time. You learned to write to a file and append text onto the end of a file. You learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program. Finally, You read about exceptions and how to handle the exceptions you’re likely to see in your programs."
  },
  {
    "objectID": "08_09_OOP.html#creating-and-using-a-class",
    "href": "08_09_OOP.html#creating-and-using-a-class",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.1 Creating and Using a Class",
    "text": "8.1 Creating and Using a Class\nIn the first lecture, we mentioned that everything in Python is an object, so you’ve been using objects constantly. Object Oriented Programming (OOP) is a programming paradigm that allows you to group variables (data/attributes) and functions (methods) into new data types called classes, from which you can create objects (instance). When you write a class, you define the general behavior that a whole category of objects can have.\nWhen you create individual objects from the class, each object is automatically equipped with the general behavior; you can then give each object whatever unique traits you desire. Making an object from a class is called instantiation, and you work with instances of a class. You’ve already used lots of classes created by other people (int, str, float, list, dict, etc.); these are designed to represent simple pieces of information, such as the cost of an apple, the name of a student. What if you want to represent something more complex? In this chapter, you’ll learn how to create your custom classes.\n\nLearning about OOP will help you see the world as a programmer does. Knowing the logic behind classes will train you to think logically, so you can write programs that effectively address almost any problem you encounter.\n\nYou can model almost anything using classes. Let’s start by writing a simple class, Dog, that represents a dog — not one dog in particular, but any dog. What do we know about most pet dogs? Well, they all have a name and an age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they’re common to most dogs.\n\n8.1.1 Creating the Dog Class\nEach instance created from the Dog class will store a name and an age, and we’ll give each dog the ability to sit() and roll_over():\n\nclass Dog:\n    \"\"\"A simple attempt to model a dog.\"\"\"\n    def __init__(self, name, age):\n        \"\"\"Initialize name and age attributes.\"\"\"\n        self.name = name\n        self.age = age\n    def sit(self):\n        \"\"\"Simulate a dog sitting in response to a command.\"\"\"\n        print(f\"{self.name} is now sitting.\")\n    def roll_over(self):\n        \"\"\"Simulate rolling over in response to a command.\"\"\"\n        print(f\"{self.name} rolled over!\")\n\nWe first define a class called Dog with the class keyword. By convention, capitalized names refer to classes in Python. We then write a docstring describing what this class does.\n\nThere are no parentheses in the class definition here because we’re creating this class from scratch\n\n\n8.1.1.1 The __init__() Method\n\nA function that’s part of a class is a method. The __init__() method is a special method that Python runs whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python’s default method names from conflicting with your method names.\nThe self parameter is required in the method definition, and it must come first before any other parameters. It must be included in the definition because when Python calls this method later (to create an instance of Dog), the method call will automatically pass the self argument. The two variables defined in the body of the __init__() method each have the prefix self. Any variable prefixed with self (refer as instance attributes) is available to every method in the class, and we’ll also be able to access these variables through any instance created from the class, which can be different between instances.\nThe line self.name = name takes the value associated with the parameter name and assigns it to the variable name, which is then attached to the instance being created. The same process happens with self.age = age. Variables that are accessible through instances like this are called attributes.\n\nThe Dog class has two other methods defined: sit() and roll_over(). Because these methods don’t need additional information to run, we define them to have one parameter, self, so that the instances we create later will have access to these methods. In other words, they’ll be able to sit and roll over.\n\n\n8.1.1.2 Making an Instance from a Class\nWhen we make an instance of Dog, Python will call the __init__() method from the Dog class. We’ll pass Dog() a name and an age as arguments; self is passed automatically, so we don’t need to pass it.\n\nmy_dog = Dog('Willie', 6) # This is known as constructor expression\n\n# You can access their instance attributes using dot notation:\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"My dog is {my_dog.age} years old.\")\n\nMy dog's name is Willie.\nMy dog is 6 years old.\n\n\nHere, we tell Python to create a dog whose name is ‘Willie’ and whose age is 6, which is known as constructor expression. When Python reads this line, it calls the __init__() method in Dog with the arguments ‘Willie’ and 6. The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog. To access the attributes of an instance, you use dot notation. After we create an instance from the class Dog, we can use dot notation to call any method defined in Dog.\n\nmy_dog.sit()\nmy_dog.roll_over()\n\nWillie is now sitting.\nWillie rolled over!\n\n\nTo call a method, give the name of the instance (in this case, my_dog) and the method you want to call, separated by a dot agian.\n\nThe class constructor of Python is actually divided into two steps. Check out here for more information. There is also a destructor __del__, but in Python, destructors are not needed as much as in C++ because Python has a garbage collector that handles memory management automatically.\n\n\n\n8.1.1.3 Creating Multiple Instances\nOnce you create a class, you can use it to create different objects.\n\nmy_dog = Dog('Willie', 6) \nyour_dog = Dog('Lucy', 3)\n\n# Even though my_dog and your_dog are both instances of the Dog class, they represent two distinct objects in memory.\nprint(my_dog == your_dog)\n\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"My dog is {my_dog.age} years old.\")\nmy_dog.sit()\n\nprint(f\"\\nYour dog's name is {your_dog.name}.\")\nprint(f\"Your dog is {your_dog.age} years old.\")\nyour_dog.sit()\n\nFalse\nMy dog's name is Willie.\nMy dog is 6 years old.\nWillie is now sitting.\n\nYour dog's name is Lucy.\nYour dog is 3 years old.\nLucy is now sitting.\n\n\nIn this example, we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own attributes, capable of the same set of actions."
  },
  {
    "objectID": "08_09_OOP.html#working-with-classes-and-instances",
    "href": "08_09_OOP.html#working-with-classes-and-instances",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.2 Working with Classes and Instances",
    "text": "8.2 Working with Classes and Instances\nOnce you write a class, you’ll spend most of your time working with instances created from that class. One of the first tasks you’ll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.\n\n8.2.1 The Car Class\nHere, we create another class that Car with four instance attributes:\n\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\nIn the Car class, we define the __init__() method with the self parameter first, just like we did with the Dog class. We also give it other parameters: make, model, year and odometer_reading. The __init__() method takes in these parameters and assigns them to the attributes associated with instances made from this class. When we make a new Car instance, we’ll need to specify a make, model, and year for our instance. We define a method called get_descriptive_name() that puts a car’s year, make, and model into one string neatly describing the car. To work with the attribute values in this method, we use self.make, self.model, and self.year.\nWhen an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, which assigns a default value. In the above example, an attribute called odometer_reading always starts with a value of 0. Finally, there is a method read_odometer() that helps us read each car’s odometer.\nOutside of the class, we make an instance from the Car class and assign it to the variable my_new_car. Then we call get_descriptive_name() to show what kind of car we have! Our car starts with a mileage of 0:\n\nmy_new_car = Car('audi', 'a4', 2024) \nprint(my_new_car.get_descriptive_name())\nmy_new_car.read_odometer()\n\n2024 Audi A4\nThis car has 0 miles on it.\n\n\nNot many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.\n\n8.2.1.1 Modifying Attribute Values\nYou can change an attribute’s value in different ways: you can change the value directly through an instance, set the value through a method, or increment the value (add a certain amount to it) through a method. The simplest way to modify the value of an attribute is to access the attribute directly through an instance.\n\nmy_new_car.odometer_reading = 23\nmy_new_car.read_odometer()\n\nThis car has 23 miles on it.\n\n\nIt can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally.\n\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n\n    ## We add these there methods!\n    def update_odometer(self, mileage):\n        \"\"\"\n        Set the odometer reading to the given value.\n        Reject the change if it attempts to roll the odometer back.\n        \"\"\"\n        if mileage &gt;= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n            \n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\n    def fill_gas_tank(self):\n        \"\"\"Filling the gas tank.\"\"\"\n        print(\"The gas tank is now full!\")\n\nThe only modification to Car is the addition of update_odometer(). This method takes in a mileage value and assigns it to self.odometer_reading. It also checks that the new reading makes sense before modifying the attribute. If the value provided for mileage is greater than or equal to the existing mileage, self.odometer_reading, you can update the odometer reading to the new mileage. If the new mileage is less than the existing mileage, you’ll get a warning that you can’t roll back an odometer! In addition, we also define the new method increment_odometer() takes in a number of miles and adds this value to self.odometer_reading. Finally, a method fill_gas_tank() is also added to the class.\n\nmy_new_car = Car('audi', 'a4', 2024)\nprint(my_new_car.get_descriptive_name())\n\nmy_new_car.update_odometer(23)\nmy_new_car.read_odometer()\n\nmy_new_car.fill_gas_tank()\nmy_new_car.increment_odometer(100)\nmy_new_car.read_odometer()\n\n2024 Audi A4\nThis car has 23 miles on it.\nThe gas tank is now full!\nThis car has 123 miles on it.\n\n\n\nYou can use methods like this to control how users of your program update values, such as an odometer reading with additional logic added.\n\n\n\n8.2.1.2 __repr__ and __str__ method\nNotice that when you evaluate the my_new_car, it will return a message that returns the address of the object:\n\nmy_new_car\n\n&lt;__main__.Car at 0x1a1c96e60a0&gt;\n\n\nWhen writing your classes, it’s a good idea to have a method that returns a string containing useful information about a class instance. You can change this behavior by adding a special function __repr__:\n\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\"\n        Set the odometer reading to the given value.\n        Reject the change if it attempts to roll the odometer back.\n        \"\"\"\n        if mileage &gt;= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n            \n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\n    def fill_gas_tank(self):\n        \"\"\"Filling the gas tank.\"\"\"\n        print(\"The gas tank is now full!\")\n\n    ## We add these two methods!\n    def __repr__(self):\n        return f'Car(make={self.make}, model={self.model}, year={self.year})'\n    \n    def __str__(self):\n        return self.get_descriptive_name()\n\n\nmy_new_car = Car('audi', 'a4', 2024)\nmy_new_car\n\nCar(make=audi, model=a4, year=2024)\n\n\nThe Python documentation indicates that __repr__ returns the “official” string representation of the object. We also define the __str__ special method that is used to replace the behavior of __repr__ in some cases. This method is called when you convert an object to a string with the built-in function str(), such as when you print an object or call str() explicitly.\n\nprint(my_new_car)\nstr(my_new_car)\n\nCar(make=audi, model=a4, year=2024)\n\n\n'Car(make=audi, model=a4, year=2024)'\n\n\n\nSpecial methods like __init__(), __str__() and __repr__ are called dunder methods(Double UNDERscore). There are many dunder methods that you can use to customize classes i\n\n\n8.2.2 Exercise 1: Create a Pokemon class with three instance attributes: name, which stores the name of the Pokemon as a string, type which stores the type of Pokemon (e.g., “Fire”, “Water”, “Grass”, etc.) as string and total_species as an integer. In addition, add the __str__() method to the class so that it can print out meaningful information as follows:\n\nPikachu (Electric, total species 320)\nComplete the following class and execute the code cell to see which six Pokemon you get.\n\nclass Pokemon:\n    # Your code here\n    def __init__(_,_,_,_):\n        _______\n\n    # Your code here\n    def __str__(_):\n        return f\"{_} ({_}, total specis {_})\"\n\n\nimport random\nimport json \nimport time\nimport requests\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\n## 1. Download the data\nurl = 'https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json'\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    with open('pokedex.json', 'w') as f:\n        f.write(response.text)\nelse:\n    print(f\"Failed to download the file. Status code: {response.status_code}\")\n\nwith open('Pokedex.json', 'r') as file:\n    pokemon_data = json.load(file)\n\n\n## 2. Randomly pick 6 pokemon\nrandom.shuffle(pokemon_data)\npicks = pokemon_data[:6]\n\n\n## 3. Print the pokemon you got!\nprint(\"The pokemon you got are: \")\nfor i in range(6):\n    pokemon = Pokemon(picks[i]['name']['english'], picks[i]['type'][0], sum([picks[i]['base'][key] for key in picks[i]['base'] if key != \"name\"]))\n    slow_print(str(pokemon))\n\nThe pokemon you got are: \nIncineroar (Fire, total specis 530)\nAurorus (Rock, total specis 521)\nSawsbuck (Normal, total specis 475)\nCombee (Bug, total specis 244)\nTapu Fini (Water, total specis 570)\nHeatran (Fire, total specis 600)"
  },
  {
    "objectID": "08_09_OOP.html#inheritance",
    "href": "08_09_OOP.html#inheritance",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.3 Inheritance",
    "text": "8.3 Inheritance\nYou don’t always have to start from scratch when writing a class. If the class you’re writing is a specialized version of another class you wrote, you can use inheritance which is called ” is a” releationship. When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class, and the new class is the child class. The child class can inherit any or all of the attributes and methods of its parent class, but it’s also free to define new attributes and methods of its own.\n\n8.3.1 The __init__() method for a Child Class\nWhen writing a new class based on an existing class, we will often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let’s model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote about earlier. Then we’ll only have to write code for the attributes and behaviors specific to electric cars.\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery_size = 40\n   \n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n\nWhen you create a child class, the parent class must be part of the current file and appear before the child class. We then define the child class, ElectricCar. The name of the parent class must be included in parentheses in the definition of a child class.\nThe __init__() method takes in the information required to make a Car instance. The super() function is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car, which gives an ElectricCar instance all the attributes defined in that method. The name super comes from a convention of calling the parent class a superclass (base class) and the child class a subclass (derived class).\nWe also add a new attribute specific to electric cars (a battery) and a method to report on this attribute. We’ll store the battery size and write a method that prints a description of the battery. This attribute/method will be associated with all instances created from the ElectricCar class but won’t be associated with any instances of Car.\n\nWe make an instance of the ElectricCar class and assign it to my_leaf.\n\nmy_leaf = ElectricCar('nissan', 'leaf', 2024) \nprint(my_leaf.get_descriptive_name())\nmy_leaf.describe_battery()\n\n2024 Nissan Leaf\nThis car has a 40-kWh battery.\n\n\nWhen we need to know the type of an object, we can pass the object to the built-in type() function. But if we’re doing a type check of an object, it’s a better idea to use the more flexible isinstance() built-in function. The isinstance() function will return True if the object is of the given class or a subclass of the given class.\n\ntype(my_leaf)\n\n__main__.ElectricCar\n\n\n\nisinstance(my_leaf, ElectricCar)\n\nTrue\n\n\n\nisinstance(my_leaf, Car)\n\nTrue\n\n\n\n\n8.3.2 Overriding Methods from the Parent Class\nYou can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Say the class Car had a method called fill_gas_tank(). This method is meaningless for an all-electric vehicle, so you might want to override this method. Here’s one way to do that:\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery_size = 40\n   \n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n    ## We overide the method here\n    def fill_gas_tank(self):\n        \"\"\"Electric cars don't have gas tanks.\"\"\"\n        print(\"This car doesn't have a gas tank!\")\n\nNow if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead.\n\nWhen you use inheritance, you can make your child classes retain what you need and override anything you don’t need from the parent class.\n\n\n\n8.3.3 Use composition to organize the code\nWhen modeling something from the real world in code, you may add more detail to a class. You’ll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together; this approach is called composition, which is sometimes referred to as the “has a” releationship.\nFor example, if we continue adding detail to the ElectricCar class, we might notice that we’re adding many attributes and methods specific to the car’s battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery. Then we can use a Battery instance as an attribute in the ElectricCar class:\n\nclass Battery:\n    \"\"\"A simple attempt to model a battery for an electric car.\"\"\"\n\n    def __init__(self, battery_size=40):\n        \"\"\"Initialize the battery's attributes.\"\"\"\n        self.battery_size = battery_size\n\n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n        \n    def get_range(self):\n        \"\"\"Print a statement about the range this battery provides.\"\"\"\n        if self.battery_size == 40:\n            range = 150\n        elif self.battery_size == 65:\n            range = 225\n        print(f\"This car can go about {range} miles on a full charge.\")\n\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery = Battery()\n\nWe define a new class called Battery that doesn’t inherit from any other class. The __init__() method has one parameter, battery_size, in addition to self. This optional parameter sets the battery’s size to 40 if no value is provided. The method describe_battery() has been moved to this class as well. A new method, get_range(), performs some simple analysis and is also added.\nIn the ElectricCar class, we now add an attribute called self.battery. This tells Python to create a new instance of Battery (with a default size of 40) and assign that instance to the attribute self.battery. Any ElectricCar instance will now have a Battery instance created automatically. When we want to describe the battery, we need to work through the car’s battery attribute:\n\nmy_leaf = ElectricCar('nissan', 'leaf', 2024)\nprint(my_leaf.get_descriptive_name())\nmy_leaf.battery.describe_battery()\nmy_leaf.battery.get_range()\n\n2024 Nissan Leaf\nThis car has a 40-kWh battery.\nThis car can go about 150 miles on a full charge.\n\n\n\nInheritance and composition are two essential concepts in object-oriented programming that model the relationship between two classes. Check out here for more in-depth comparisons."
  },
  {
    "objectID": "08_09_OOP.html#encapsulation---attributes-for-data-access",
    "href": "08_09_OOP.html#encapsulation---attributes-for-data-access",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.4 Encapsulation - Attributes for data access",
    "text": "8.4 Encapsulation - Attributes for data access\nMost object-oriented programming languages enable you to encapsulate (or hide) an object’s data from the code. Such data in these languages are said to be private data. Python does not have private data. Instead, you use naming conventions to design classes that encourage correct use. By convention, Python programmers know that any attribute name beginning with an underscore (_) is for a class’s internal use only. Code should use the class’s methods and attributes to interact with each object’s internal-use data attributes. Attributes whose identifiers do not begin with an underscore (_) are considered publicly accessible.\n\nHowever, even when we use these conventions, attributes are always accessible.\n\nLet’s develop a Time class that stores the time in 24-hour clock format with hours in the range 0–23 and minutes and seconds each in the range 0–59:\n\nclass Time:\n    \"\"\"Class Time with read-write attributes.\"\"\"\n\n    def __init__(self, hour=0, minute=0, second=0):\n        \"\"\"Initialize each attribute.\"\"\"\n        self.set_hour(hour)      # 0-23, note that this line calls the setter method hour\n        self.set_minute(minute)  # 0-59, note that this line calls the setter method minute\n        self.set_second(second)  # 0-59, note that this line calls the setter method second\n\n    #getter\n    def get_hour(self):\n        \"\"\"Return the hour.\"\"\"\n        print(\"getter is called\")\n        return self._hour\n\n    #setter\n    def set_hour(self, hour):\n        \"\"\"Set the hour.\"\"\"\n        print(\"setter is called\")\n        if not (0 &lt;= hour &lt; 24):\n            raise ValueError(f'Hour ({hour}) must be 0-23')\n\n        self._hour = hour\n\n    def get_minute(self):\n        \"\"\"Return the minute.\"\"\"\n        return self._minute\n\n    def set_minute(self, minute):\n        \"\"\"Set the minute.\"\"\"\n        if not (0 &lt;= minute &lt; 60):\n            raise ValueError(f'Minute ({minute}) must be 0-59')\n\n        self._minute = minute\n\n    def get_second(self):\n        \"\"\"Return the second.\"\"\"\n        return self._second\n\n    def set_second(self, second):\n        \"\"\"Set the second.\"\"\"\n        if not (0 &lt;= second &lt; 60):\n            raise ValueError(f'Second ({second}) must be 0-59')\n\n        self._second = second\n\n\nClass Time’s __init__ method specifies hour, minute and second parameters, each with a default argument of 0. The statements containing self.set_hour(), self.set_minute() and self.set_second() call methods that implement the class’s setter. Those methods then create attributes named _hour, _minute and _second that is meant for use only inside the class!\nLines 10–21 define a publicly accessible read-write property named hour that manipulates a data attribute named _hour. The single-leading-underscore (_) naming convention indicates that we should not access _hour directly. We define a getter method which gets (that is, returns) a data attribute’s value and a setter method, which sets a data attribute’s value.\n\nHere is how we initialize an object:\n\nwake_up = Time(hour=6, minute=30)\n\nsetter is called\n\n\nThe following code expression invokes the getter method:\n\nwake_up.get_hour()\n\ngetter is called\n\n\n6\n\n\nThe following code expression invokes the setter by assigning a value to the attribute:\n\nwake_up.set_hour(8)\n\nsetter is called\n\n\nClass Time’s getter and setter define the class’s public interface — that is, the set of attributes programmers should use to interact with objects of the class. Just like the private attributes above, not all methods need to serve as part of a class’s interface. Some serve as utility methods used only inside the class and are not intended to be part of the class’s public interface used by others. Such methods should be named with a single leading underscore. In other object-oriented languages like C++, Java and C#, such methods typically are implemented as private methods.\n\nIn Python, there is a more Pythonic way to define the getter and setter using properties. You can check out here for more information.\n\nNote that although we define the public interface, the internal attribute can still be accessed.\n\nwake_up._hour\n\n8\n\n\n\n8.4.1 Simulating “Private” Attributes\nIn programming languages such as C++, Java and C#, classes state explicitly which class members are publicly accessible. Class members that may not be accessed outside a class definition are private and visible only within the class that defines them. Python programmers often use “private” attributes for data or utility methods that are essential to a class’s inner workings but are not part of the class’s public interface.\nRather than _hour, we can name the attribute __hour with two leading underscores. This convention indicates that __hour is “private” and should not be accessible to the class’s clients.\n\nclass PrivateClass:\n    \"\"\"Class with public and private attributes.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the public and private attributes.\"\"\"\n        self.public_data = \"public\"  # public attribute\n        self.__private_data = \"private\"  # private attribute\n\n\nmy_object = PrivateClass()\nmy_object.public_data\n\n'public'\n\n\nWhen we attempt to access __private_data directly, we get an AttributeError indicating that the class does not have an attribute by that name:\n\nmy_object.__private_data\n\nAttributeError: 'PrivateClass' object has no attribute '__private_data'\n\n\n\nEven with double-underscore (__) naming, we can still access and modify __private_data, because we know that Python renames attributes simply by prefixing their names with ‘_ClassName’\n\n\nprint(my_object._PrivateClass__private_data)\nmy_object._PrivateClass__private_data = 'modified'\nprint(my_object._PrivateClass__private_data)\n\nprivate\nmodified\n\n\n\n\n8.4.2 Class Methods\nClass methods are associated with a class rather than individual objects like regular methods are. You can recognize a class method in code when you see two markers: the @classmethod decorator before the method’s def statement and the use of cls as the first parameter, as shown in the following example:\n\nclass ExampleClass:\n    def exampleRegularMethod(self):\n        print('This is a regular method.')\n\n    @classmethod # This is the \"decorator\" that takes another function as input, extends or modifies its behavior, and returns a new function\n    def exampleClassMethod(cls):\n        print('This is a class method.')\n\n# Call the class method without instantiating an object:\nExampleClass.exampleClassMethod()\n\nobj = ExampleClass()\n# Given the above line, these two lines are equivalent:\nobj.exampleClassMethod()\nobj.__class__.exampleClassMethod()\n\nThis is a class method.\nThis is a class method.\nThis is a class method.\n\n\nThe cls parameter acts like self except self refers to an object, but the cls parameter refers to an object’s class. This means that the code in a class method cannot access an individual object’s attributes or call an object’s regular methods. Class methods can only call other class methods or access class attributes. We use the name cls because class is a Python keyword. We often call class methods through the class object, as in ExampleClass.exampleClassMethod(). But we can also call them through any object of the class, as in obj.exampleClassMethod().\nClass methods aren’t commonly used. The most frequent use case is to provide alternative constructor methods besides __init__(). For example, what if a constructor function could accept either a string of data the new object needs or a string of a filename that contains the data the new object needs? We don’t want the __init__() method’s parameters to be lengthy and confusing. Instead, let’s use class methods to return a new object. For example, let’s create an AsciiArt class:\n\n%%writefile face.txt\n _______\n|  . .  |\n| \\___/ |\n|_______|\n\nOverwriting face.txt\n\n\n\nclass AsciiArt:\n    def __init__(self, characters):\n        \"\"\" Approach1: Initialize it with string \"\"\"\n        self._characters = characters\n\n    @classmethod\n    def fromFile(cls, filename):\n        \"\"\" Approach2: Initialize it with filename \"\"\"\n        with open(filename) as fileObj:\n            characters = fileObj.read()\n            return cls(characters) # This calls the __init__ function\n\n    def display(self):\n        print(self._characters)\n\n    # Other AsciiArt methods would go here...\n\nface1 = AsciiArt(' _______\\n' +\n                 '|  . .  |\\n' +\n                 '| \\\\___/ |\\n' +\n                 '|_______|')\nface1.display()\n\nface2 = AsciiArt.fromFile('face.txt')\nface2.display()\n\n _______\n|  . .  |\n| \\___/ |\n|_______|\n _______\n|  . .  |\n| \\___/ |\n|_______|\n\n\n\nThe AsciiArt class has an __init__() method that can be passed the text characters of the image as a string. It also has a fromFile() class method that can be passed the filename string of a text file containing the ASCII art. Both methods create AsciiArt objects. Note that the last line of fromFile calls __init__() method. This is a trick you can use to follow the “Don’t Repeat Yourself (DRY)” principle. If we rename this class or modify the content of the constructor (__init__) at some point, we won’t have to remember to update the class method.\n\n\n8.4.3 Class Attributes\nA class attribute is a variable that belongs to the class rather than to an object. We create class attributes inside the class but outside all methods, just like we can create global variables in a .py file but outside all functions. Here’s an example of a class attribute named count, which keeps track of how many CreateCounter objects have been created:\n\nclass CreateCounter:\n    count = 0 # This is a class attribute.\n\n    def __init__(self):\n        CreateCounter.count += 1\n\nprint('Objects created:', CreateCounter.count)  # Prints 0.\na = CreateCounter()\nb = CreateCounter()\nc = CreateCounter()\nprint('Objects created:', CreateCounter.count)  # Prints 3.\n\nObjects created: 0\nObjects created: 3\n\n\nThe CreateCounter class has a single class attribute named count. All CreateCounter objects share this attribute rather than having their own separate count attributes. This is why the CreateCounter.count += 1 line in the constructor function can keep count of every CreateCounter object created.\n\n\n8.4.4 Static Methods\nA static method doesn’t have a self or cls parameter. Static methods are effectively just functions, because they can’t access the attributes or methods of the class or its objects. Rarely, if ever, do you need to use static methods in Python. If you do decide to use one, you should strongly consider just creating a regular function instead.\nWe define static methods by placing the @staticmethod decorator before their def statements. Here is an example of a static method:\n\nclass ExampleClassWithStaticMethod:\n    @staticmethod\n    def sayHello():\n        print('Hello!')\n\n# Note that no object is created, the class name precedes sayHello():\nExampleClassWithStaticMethod.sayHello()\n\nHello!\n\n\n\nStatic methods are more common in other languages that don’t have Python’s flexible language features. Python’s inclusion of static methods imitates the features of other languages but doesn’t offer much practical value.\n\nYou’ll rarely need class methods, class attributes, and static methods, and they’re also prone to overuse. If you’re thinking, “Why can’t I just use a function or global variable instead?” this is a hint that you probably don’t need to use a class method, class attribute, or static method. The only reason we cover them is so you can recognize them when you encounter them in code. You can find more information about the discussion here."
  },
  {
    "objectID": "08_09_OOP.html#polymorphism",
    "href": "08_09_OOP.html#polymorphism",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.5 Polymorphism",
    "text": "8.5 Polymorphism\nPolymorphism allows objects of one type to be treated as objects of another type.\n\nFor example, the len() function returns the length of the argument passed to it. You can pass a string to len() to see how many characters it has, but you can also pass a list or dictionary to len() to see how many items or key-value pairs it has, respectively. This polymorphism of function is called generic functions or method/function overloading because it can handle objects of many different types.\nPolymorphism also includes operator overloading, where operators (such as + or *) can behave differently based on the type of objects they’re operating on. For example, the + operator does mathematical addition when operating on two integer or float values, but it does string concatenation when operating on two strings.\n\nIn Python, we can achieve method polymorphism by defining a method in a base class and then overriding it in the derived classes. Each derived class can then provide its implementation of the method. For example:\n\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\n\ndef speak(animal):\n    print(animal.speak())\n\nanimals = [Dog(\"Rufus\"), Cat(\"Whiskers\"), Dog(\"Buddy\")]\n\n# method overriding\nfor animal in animals:\n    print(f'{animal.name} : {animal.speak()}')\n\n# method overloading\nfor animal in animals:\n    speak(animal)\n\nRufus : Woof!\nWhiskers : Meow!\nBuddy : Woof!\nWoof!\nMeow!\nWoof!\n\n\nIn this example, the Animal class defines the speak method as a pass statement, meaning it does nothing. However, both Dog and Cat classes override the method with their implementation of the method. This is called method overriding and is also a form of polymorphism. The speak() function accepts any object that implements the speak() method, meaning it can handle animals of different types. Here, we can pass both Dog and Cat objects to the speak() function, as they both inherit the speak() method from the Animal class.\n\n8.5.1 Operator overloading\nPython has several dunder method. You’re already familiar with the __init__() dunder method name, but Python has several more. We often use them for operator overloading — that is, adding custom behaviors that allow us to use objects of our classes with Python operators, such as + or &gt;=. Other dunder methods let objects of our classes work with Python’s built-in functions, such as len(). These methods are documented online in the official Python documentation at here.\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __eq__(self, other):\n        return (self.x == other.x) and (self.y == other.y)\n\np1 = Point(1, 2)\np2 = Point(3, 4)\np3 = p1 + p2\np4 = Point(4, 6)\nprint(p3.x, p3.y)  # Output: 4 6\nprint(p3 == p4)\n\n4 6\nTrue\n\n\nIn this example, we define the __add__ and __eq__ method in the Point class to implement the addition and equality of two Point objects. When we use the + and = operators with two Point objects, the __add__ and __eq__methods are called automatically to perform the addition and comparison.\nFor more information about overloading, see here.\n\n8.5.2 Exercise 2: Inherit from Pokemon class to create new classes, firePokemon and waterpokemon, that accept the same parameters when constructed. Add a new method attack() for the two derived classes that recieve a single parameter attack_type and print out the message like this:\n\nMagmortar is attacking with flamethrower\nIn addition, define a function PokemonAttack(), which receives a Pokemon object and an attack type, then call the method attack(). Complete the following class/function and execute the code cell.\n\nclass Pokemon:\n    def __init__(self, name, type, total_specis):\n        self.name = name\n        self.type = type\n        self.total_specis = total_specis\n        \n    def __str__(self):\n        return f\"{self.name} ({self.type}, total specis {self.total_specis})\"\n    \n\nclass firePokemon(Pokemon):\n    # Your code here\n    def __init__(self, name, type, total_specis):\n        _________\n    # Your code here\n    def attack(__, __):\n        print(f\"{self.name} is attacking with {attack_type}\")\n    \nclass waterPokemon(Pokemon):\n    # Your code here\n    def __init__(self, name, type, total_specis):\n        _________\n    # Your code here\n    def attack(__, __):\n        print(f\"{self.name} is attacking with {attack_type}\")\n    \ndef PokemonAttack(pokemon, attack_type):\n    # Your code here\n    _________\n\n\nimport random\nimport json \nimport time\nimport requests\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\n## 1. Download the data\nurl = 'https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json'\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    with open('pokedex.json', 'w') as f:\n        f.write(response.text)\nelse:\n    print(f\"Failed to download the file. Status code: {response.status_code}\")\n\nwith open('Pokedex.json', 'r') as file:\n    pokemon_data = json.load(file)\n\n\n## 2. Get the pokemon\nrandom.shuffle(pokemon_data)\ngetpokemon = []\ni = 0\nwhile True:\n    if len(getpokemon) == 6:\n        break\n    if pokemon_data[i]['type'][0] != \"Fire\" and pokemon_data[i]['type'][0] != \"Water\":\n        i += 1\n        continue\n    else:\n        if pokemon_data[i]['type'][0] == \"Fire\":\n            pokemon = firePokemon(pokemon_data[i]['name']['english'], pokemon_data[i]['type'][0], sum([pokemon_data[i]['base'][key] for key in pokemon_data[i]['base'] if key != \"name\"]))\n        else:\n            pokemon = waterPokemon(pokemon_data[i]['name']['english'], pokemon_data[i]['type'][0], sum([pokemon_data[i]['base'][key] for key in pokemon_data[i]['base'] if key != \"name\"]))\n        getpokemon.append(pokemon)\n        i += 1\n\n# 3. Print the pokemon and attack!\nfor i in range(6):\n    if getpokemon[i].type == \"Fire\":\n        attack = 'flamethrower'\n    else:\n        attack = 'hydro pump'\n    PokemonAttack(getpokemon[i], attack)\n\nMarill is attacking with hydro pump\nPalkia is attacking with hydro pump\nPanpour is attacking with hydro pump\nMagcargo is attacking with flamethrower\nKingdra is attacking with hydro pump\nLitleo is attacking with flamethrower"
  },
  {
    "objectID": "08_09_OOP.html#data-class",
    "href": "08_09_OOP.html#data-class",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.6 Data Class",
    "text": "8.6 Data Class\nData classes are among Python 3.7’s most important new features. They help you build classes faster by using more concise notation and by autogenerating “boilerplate” code that’s common in most classes. For instance:\n\nA data class autogenerates __init__, __repr__ and __eq__, saving you time.\nA data class can autogenerate the special methods that overload the &lt;, &lt;=, &gt; and &gt;= comparison operators.\nWhen you change data attributes defined in a data class, then use it in a script or interactive session, the autogenerated code updates automatically. So, you have less code to maintain and debug.\nSome static code analysis tools and IDEs can inspect variable annotations and issue warnings if your code uses the wrong type. This can help you locate logic errors in your code before you execute it.\n\nCheck out here for more details."
  },
  {
    "objectID": "08_09_OOP.html#summary",
    "href": "08_09_OOP.html#summary",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.7 Summary",
    "text": "8.7 Summary\nObject-oriented programming is a programming paradigm that provides a means of structuring programs so that attributes and behaviors are bundled into individual objects. The discussion of OOP is centered around inheritance, encapsulation and Polymorphism:\n\nInheritance promotes code reusability and organization by allowing derived classes to inherit attributes and methods from parent classes.\nEncapsulation improves maintainability and security by bundling data and methods within objects and controlling access to their internal state.\nPolymorphism enhances flexibility and extensibility by enabling a single interface to represent different types, allowing for interchangeable objects and easier code modification.\n\nHowever, Python implements object-oriented features slightly differently than other OOP languages, such as Java or C++. For example, Python lets you overload its operators via its dunder methods, which begin and end with double underscore characters. These methods provide a way for Python’s built-in operators to work with objects of the classes you create."
  },
  {
    "objectID": "10_11_NumPy.html#array-oriented-programming-with-numpy",
    "href": "10_11_NumPy.html#array-oriented-programming-with-numpy",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.1 Array-Oriented Programming with NumPy",
    "text": "9.1 Array-Oriented Programming with NumPy\nThe NumPy (Numerical Python) library first appeared in 2006 and is the preferred Python array implementation. It offers a high-performance, richly functional n-dimensional array type called array, which, from this point forward, we’ll refer to by its synonym, array. Operations on arrays are up to one or two orders of magnitude faster than those on lists. Many Python libraries depend on NumPy. Many popular data science libraries such as Pandas, SciPy (Scientific Python), and Keras (for deep learning) are built on or depend on NumPy.\nIn this chapter, we explore the array’s basic capabilities. The built-in lists can have multiple dimensions. You generally process multi-dimensional lists with nested loops or list comprehensions with multiple clauses. A strength of NumPy is “array-oriented programming,” which uses functional-style programming with internal iteration to make array manipulations concise and straightforward, eliminating the kinds of bugs that can occur with the external iteration of explicitly programmed loops.\nIn Python the types are dynamically inferred and we do not have to allocate the memory by ourselves. This type of flexibility also points to the fact that Python variables are more than just their values; they also contain extra information about the type and the size of the value:\n\n\n\n\nsource: https://jakevdp.github.io/PythonDataScienceHandbook/figures/cint_vs_pyint.png\n\nSimilarly, the list in Python is very flexible that can store heterogeneous objects. But this flexibility comes at a cost: to allow these flexible types, each item in the list must contain its type, size, and other information. Every element is a complete Python object. In the special case that all variables are of the same type, much of this information is redundant, so storing the data in a fixed-type array can be much more efficient. The difference between a dynamic-type list and a fixed-type (NumPy-style) array is illustrated:\n\n\n\n\nsource: https://jakevdp.github.io/PythonDataScienceHandbook/figures/array_vs_list.png\n\nAt the implementation level, the array essentially contains a single pointer to one contiguous block of data. The Python list, on the other hand, includes a pointer to a block of pointers, each of which in turn points to a whole Python object like the Python integer we saw earlier.\n\nThe advantage of the list is flexibility: because each list element is a full structure containing both data and type information, the list can be filled with data of any desired type. Fixed-type NumPy-style arrays lack this flexibility but are much more efficient for storing and manipulating data.\n\nFrom the previous lecture, we know that every object consists of data and methods. The ndarray object of the NumPy package not only provides efficient storage of array-based data but adds to this efficient operations on that data."
  },
  {
    "objectID": "10_11_NumPy.html#creating-array-from-existing-data",
    "href": "10_11_NumPy.html#creating-array-from-existing-data",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.2 Creating array from Existing Data",
    "text": "9.2 Creating array from Existing Data\nThe NumPy documentation recommends importing the numpy module as np so that you can access its members with “np.”\n\nimport numpy as np\n\nThe numpy module provides various functions for creating arrays. Here we use the array() function, which receives a collection of elements and returns a new array containing the argument’s elements. Let’s pass a list for example:\n\nnumbers = np.array([2, 3, 5, 7, 11])\nnumbers, type(numbers)\n\n(array([ 2,  3,  5,  7, 11]), numpy.ndarray)\n\n\nThe array() function copies its argument’s contents into the array. Note that the type is numpy.ndarray, but all arrays are output as “array.”\n\n9.2.1 Multidimensional Arguments\nThe array() function copies its argument’s dimensions. Let’s create an array from a two-row-by-three-column list:\n\nnp.array([[1, 2, 3], [4, 5, 6]])\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\nNumPy auto-formats arrays based on their number of dimensions, aligning the columns within each row.\n\n9.2.1.1 array Attributes\nThe array function determines an array’s element type from its argument’s elements. You can check the element type with an array’s dtype attribute:\n\nintegers = np.array([[1, 2, 3], [4, 5, 6]])\nfloats = np.array([0.0, 0.1, 0.2, 0.3, 0.4])\n\nintegers.dtype, floats.dtype\n\n(dtype('int32'), dtype('float64'))\n\n\nAs you’ll see in the next section, various array-creation functions receive a dtype keyword argument so you can specify an array’s element type.\nFor performance reasons, NumPy is written in the C programming language and uses C’s data types. By default, NumPy stores integers as the NumPy type int_ values — which correspond to 32-bit (4-byte) integers in C (this may be platform-dependent) — and stores floating-point numbers as the NumPy type float64 values — which correspond to 64-bit (8-byte) floating-point values (double) in C. In our examples, most commonly, you’ll see the types int64, float64 and bool for non-numeric data (such as strings). The complete list of supported types is at https://docs.scipy.org/doc/numpy/user/basics.types.html.\nThe attribute ndim contains an array’s number of dimensions and the attribute shape contains a tuple specifying an array’s dimensions:\n\nprint(integers.ndim)\nprint(floats.ndim)\n\n2\n1\n\n\n\nprint(integers.shape)\nprint(floats.shape)\n\n(2, 3)\n(5,)\n\n\nHere, integers have 2 rows and 3 columns (6 elements) and floats are one-dimensional, containing 5 floating numbers.\nYou can view an array’s total number of elements with the attribute size and the number of bytes required to store each element with itemsize:\n\nprint(integers.size)\nprint(integers.itemsize)\nprint(floats.size)\nprint(floats.itemsize)\n\n6\n4\n5\n8\n\n\nNote that the integers’ size is the product of the shape tuple’s values — two rows of three elements each for a total of six elements. In each case, itemsize is 4 because integers contain int32 values and 8 since floats contain float64 values.\n\n\n\n9.2.2 Filling array with Specific Values\nNumPy provides functions zeros(), ones() and full() for creating arrays containing 0s, 1s or a specified value, respectively. By default, zeros() and ones() create arrays containing float64 values. We’ll show how to customize the element type momentarily. The first argument to these functions must be an integer or a tuple of integers specifying the desired dimensions. For an integer, each function returns a one-dimensional array with the specified number of elements:\n\nnp.zeros(5)\n\narray([0., 0., 0., 0., 0.])\n\n\nFor a tuple of integers, these functions return a multidimensional array with the specified dimensions. You can specify the array’s element type with the zeros() and ones() function’s dtype keyword argument:\n\nnp.ones((2, 4), dtype=np.int64)\n\narray([[1, 1, 1, 1],\n       [1, 1, 1, 1]], dtype=int64)\n\n\nThe array returned by full() contains elements with the second argument’s value and type:\n\nnp.full((3, 5), 13)\n\narray([[13, 13, 13, 13, 13],\n       [13, 13, 13, 13, 13],\n       [13, 13, 13, 13, 13]])\n\n\n\n\n9.2.3 Creating array from Ranges\n\n9.2.3.1 Creating Integer Ranges with arange()\nLet’s use NumPy’s arange function to create integer ranges — similar to using the built-in function range. In each case, arange first determines the resulting array’s number of elements, allocates the memory, then stores the specified range of values in the array:\n\nnp.arange(5)\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(5, 10)\n\narray([5, 6, 7, 8, 9])\n\n\n\nnp.arange(10, 1, -2) \n\narray([10,  8,  6,  4,  2])\n\n\n\nIt is the same as range() which takes three arguments numpy.arange(start, stop, step)\n\n\n\n9.2.3.2 Creating Floating-Point Ranges with linspace()\nYou can produce evenly spaced floating-point ranges with NumPy’s linspace() function. The function’s first two arguments specify the starting and ending values in the range, and the ending value is included in the array. The optional keyword argument num specifies the number of evenly spaced values to produce:\n\nnp.linspace(0.0, 1.0, num=5)\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n\n\n\n\n9.2.3.3 Reshaping an array\nYou also can create an array from a range of elements, then use the array method reshape() to transform the one-dimensional array into a multidimensional array. Let’s create an array containing the values from 1 through 20, then reshape it into four rows by five columns:\n\nnp.arange(1, 21).reshape(4, 5)\n\narray([[ 1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10],\n       [11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20]])\n\n\nNote the chained method calls in the preceding snippet. First, arange produces an array containing the values 1–20. Then we call reshape() on that array to get the 4-by-5 array that was displayed. You can reshape() any array, provided that the new shape has the same number of elements as the original. So a six-element one-dimensional array can become a 3-by-2 or 2-by-3 array, and vice versa!\nWhen displaying an array, if there are many items, NumPy drops the middle rows, columns or both from the output. The following snippets generate 100,000 elements.\n\nnp.arange(1, 100001).reshape(100, 1000)\n\narray([[     1,      2,      3, ...,    998,    999,   1000],\n       [  1001,   1002,   1003, ...,   1998,   1999,   2000],\n       [  2001,   2002,   2003, ...,   2998,   2999,   3000],\n       ...,\n       [ 97001,  97002,  97003, ...,  97998,  97999,  98000],\n       [ 98001,  98002,  98003, ...,  98998,  98999,  99000],\n       [ 99001,  99002,  99003, ...,  99998,  99999, 100000]])\n\n\nThe above case shows the first and last three of the 3 rows, and the first and last three of the 3000 columns. The notation ... represents the missing data.\n\n\n\n9.2.4 List vs. array Performance: Introducing %timeit\nMost array operations execute significantly faster than corresponding list operations. To demonstrate, we’ll use the %timeit magic command, which times the average duration of operations.\n\nimport random\n\nHere, let’s use the random module’s randint() function with a list comprehension to create a list of six million die rolls and time the operation using %timeit:\n\n%timeit rolls_list = [random.randint(1, 6) for i in range(0, 6_000_000)] #_ is use to separate long integer\n\n2.19 s ± 29.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\nBy default, %timeit executes a statement in a loop, and it runs the loop seven times. If you do not indicate the number of loops, %timeit chooses an appropriate value.\n\nNow, let’s use the randint() function from the numpy.random module to create an array\n\n%timeit rolls_array = np.random.randint(1, 7, 6_000_000)\n\n43 ms ± 872 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)"
  },
  {
    "objectID": "10_11_NumPy.html#indexing-and-slicing",
    "href": "10_11_NumPy.html#indexing-and-slicing",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.3 Indexing and Slicing",
    "text": "9.3 Indexing and Slicing\nOne-dimensional arrays can be indexed and sliced using the same syntax and techniques demonstrated in the “Lists and Tuples” chapter. Here, we focus on array-specific indexing and slicing capabilities.\nTo select an element in a two-dimensional array, specify a tuple containing the element’s row and column indices in square brackets:\n\ngrades = np.array([[87, 96, 70], [100, 87, 90],\n                   [94, 77, 90], [100, 81, 82]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\n\ngrades[0, 1]  # row 0, column 1\n\n96\n\n\nTo select a single row, specify only one index in square brackets:\n\ngrades[1]\n\narray([100,  87,  90])\n\n\nTo select multiple sequential rows, use slice notation:\n\ngrades[0:2]\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nTo select multiple non-sequential rows, use a list of row indices (fancy indexing):\n\ngrades[[1, 3]]\n\narray([[100,  87,  90],\n       [100,  81,  82]])\n\n\nYou can select subsets of the columns by providing a tuple specifying the row(s) and column(s) to select. Each can be a specific index, a slice or a list. Let’s select only the elements in the first column:\n\ngrades[:, 0]\n\narray([ 87, 100,  94, 100])\n\n\nThe 0 after the comma indicates that we’re selecting only column 0. The : before the comma indicates which rows within that column to select. In this case, : is a slice representing all rows. You can select consecutive columns using a slice:\n\ngrades[:, 1:3]\n\narray([[96, 70],\n       [87, 90],\n       [77, 90],\n       [81, 82]])\n\n\nor specific columns using a list of column indices:\n\ngrades[:, [0, 2]]\n\narray([[ 87,  70],\n       [100,  90],\n       [ 94,  90],\n       [100,  82]])\n\n\n\n9.3.1 Views: Shallow Copies\nViews are objects “see” the data in other objects, rather than having their own copies of the data. Views are also known as shallow copies. Various array methods and slicing operations produce views of an array’s data. The array method view() returns a new array object with a view of the original array object’s data. First, let’s create an array and a view of that array:\n\nnumbers = np.arange(1, 6)\nnumbers2 = numbers.view()\n\nWe can use the built-in id() function to see that numbers and numbers2 are different objects:\n\nid(numbers), id(numbers2)\n\n(2050186483472, 2050186488944)\n\n\nTo prove that numbers2 views the same data as numbers, let’s modify an element in numbers, then display both arrays:\n\nnumbers[1] *= 10\nnumbers\n\narray([ 1, 20,  3,  4,  5])\n\n\n\nnumbers2\n\narray([ 1, 20,  3,  4,  5])\n\n\nSimilarly, changing a value in the view also changes that value in the original array:\n\nnumbers2[1] /= 10\nnumbers, numbers2\n\n(array([1, 2, 3, 4, 5]), array([1, 2, 3, 4, 5]))\n\n\nSlices also create views. Let’s make numbers2 a slice that views only the first three elements of numbers:\n\nnumbers2 = numbers[0:3]\nnumbers2\n\narray([1, 2, 3])\n\n\nAgain, we can confirm that numbers and numbers2 are different objects with id():\n\nid(numbers), id(numbers2)\n\n(2050186483472, 2050186489712)\n\n\nNow, let’s modify an element both arrays share, then display them. Again, we see that numbers2 is a view of numbers:\n\nnumbers[1] *= 20\nnumbers\n\narray([ 1, 40,  3,  4,  5])\n\n\n\nnumbers2\n\narray([ 1, 40,  3])\n\n\n\n\n9.3.2 Deep Copies\nThough views are separate array objects, they save memory by sharing element data from other arrays. However, when sharing mutable values, sometimes creating a deep copy with independent copies of the original data is necessary. This is especially important in multi-core programming, where separate parts of your program could attempt to modify your data at the same time, possibly corrupting it.\nThe array method copy() returns a new array object with a deep copy of the original array object’s data. First, let’s create an array and a deep copy of that array:\n\nnumbers = np.arange(1, 6)\nnumbers2 = numbers.copy()\n\nTo prove that numbers2 has a separate copy of the data in numbers, let’s modify an element in numbers, then display both arrays:\n\nnumbers[1] *= 10\nnumbers\n\narray([ 1, 20,  3,  4,  5])\n\n\n\nnumbers2\n\narray([1, 2, 3, 4, 5])\n\n\n\nRecall that if you need deep copies of other types of Python objects, pass them to the copy module’s deepcopy() function.\n\n\n\n9.3.3 Reshaping and Transposing\nWe’ve used array method reshape() to produce two-dimensional arrays from one-dimensional ranges. NumPy provides various other ways to reshape arrays.\nThe array methods reshape() and resize() both enable you to change an array’s dimensions. Method reshape() returns a view (shallow copy) of the original array with the new dimensions. It does not modify the original array:\n\ngrades = np.array([[87, 96, 70], [100, 87, 90]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\n\ngrades.reshape(1, 6)\n\narray([[ 87,  96,  70, 100,  87,  90]])\n\n\n\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nA common trick is that you can use -1 to specify the shape in resahpe(). The length of the dimension set to -1 is automatically determined by inferring from the specified values of other dimensions:\n\ngrades.reshape(-1, 3) # Same as grades.reshape(2, 3)\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nMethod resize() modifies the original array’s shape:\n\ngrades.resize(1, 6)\ngrades\n\narray([[ 87,  96,  70, 100,  87,  90]])\n\n\nYou can take a multidimensional array and flatten it into a single dimension with the methods flatten() and ravel().\nMethod flatten() deep copies the original array’s data:\n\ngrades = np.array([[87, 96, 70], [100, 87, 90]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\n\nflattened = grades.flatten()\nflattened\n\narray([ 87,  96,  70, 100,  87,  90])\n\n\n\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nMethod ravel() produces a view of the original array, which shares the grades array’s data!\n\nraveled = grades.ravel()\nraveled\n\narray([ 87,  96,  70, 100,  87,  90])\n\n\n\nraveled[0] = 100\ngrades\n\narray([[100,  96,  70],\n       [100,  87,  90]])\n\n\nYou can quickly transpose an array’s rows and columns, so the rows become the columns and the columns become the rows. The T attribute returns a transposed view (shallow copy) of the array. The original grades array represents two students’ grades (the rows) on three exams (the columns). Let’s transpose the rows and columns to view the data as the grades on three exams (the rows) for two students (the columns):\n\ngrades.T\n\narray([[100, 100],\n       [ 96,  87],\n       [ 70,  90]])\n\n\nTransposing does not modify the original array:\n\ngrades\n\narray([[100,  96,  70],\n       [100,  87,  90]])\n\n\nYou can combine arrays by adding more columns or more rows — known as horizontal stacking and vertical stacking. Let’s create another 2-by-3 array of grades:\n\ngrades2 = np.array([[94, 77, 90], [100, 81, 82]])\ngrades2\n\narray([[ 94,  77,  90],\n       [100,  81,  82]])\n\n\nLet’s assume grades2 represents three additional exam grades for the two students in the grades array. We can combine grades and grades2 with NumPy’s hstack() (horizontal stack) function by passing a tuple containing the arrays to combine. The extra parentheses are required because hstack() expects one argument:\n\nnp.hstack((grades, grades2))\n\narray([[100,  96,  70,  94,  77,  90],\n       [100,  87,  90, 100,  81,  82]])\n\n\nNext, let’s assume that grades2 represents two more students’ grades on three exams. In this case, we can combine grades and grades2 with NumPy’s vstack() (vertical stack) function:\n\nnp.vstack((grades, grades2))\n\narray([[100,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\n\n\n9.3.4 NumPy Calculation Methods\nAn array has various methods that perform calculations using its contents. By default, these methods ignore the array’s shape and use all the elements in the calculations. For example, calculating the mean of an array totals all of its elements regardless of its shape, then divides by the total number of elements. You can perform these calculations on each dimension as well. For example, in a two-dimensional array, you can calculate each row’s mean and each column’s mean.\n\ngrades = np.array([[87, 96, 70], [100, 87, 90],\n                    [94, 77, 90], [100, 81, 82]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\nWe can use methods to calculate sum(), min(), max(), mean(), std() (standard deviation) and var() (variance) — each is a functional-style programming reduction:\n\nprint(grades.sum())\nprint(grades.min())\nprint(grades.max())\nprint(grades.mean())\nprint(grades.std())\nprint(grades.var())\n\n1054\n70\n100\n87.83333333333333\n8.792357792739987\n77.30555555555556\n\n\n\n9.3.4.1 Calculations by Row or Column\nMany calculation methods can be performed on specific array dimensions, known as the array’s axes. These methods receive an axis keyword argument that specifies which dimension to use in the calculation, giving you a quick way to perform calculations by row or column in a two-dimensional array.\nAssume that you want to calculate the average grade on each exam, represented by the columns of grades. Specifying axis=0 performs the calculation on all the row values within each column:\n\ngrades.mean(axis=0)\n\narray([95.25, 85.25, 83.  ])\n\n\nSo 95.25 above is the average of the first column’s grades (87, 100, 94 and 100), 85.25 is the average of the second column’s grades (96, 87, 77 and 81) and 83 is the average of the third column’s grades (70, 90, 90 and 82). Similarly, specifying axis=1 performs the calculation on all the column values within each individual row. To calculate each student’s average grade for all exams, we can use:\n\n\n\n\nsource: https://scipy-lectures.org/_images/reductions.png\n\n\ngrades.mean(axis=1)\n\narray([84.33333333, 92.33333333, 87.        , 87.66666667])\n\n\nThis produces four averages—one each for the values in each row. So 84.33333333 is the average of row 0’s grades (87, 96 and 70), and the other averages are for the remaining rows. See https://numpy.org/doc/stable/reference/arrays.ndarray.html for more methods.\n\nFor more operations such as linear algebra, you can use the sub-module numpy.linalg, which implements basic linear algebra, such as solving linear systems, singular value decomposition, etc. However, it is not guaranteed to be compiled using efficient routines, and thus we recommend the use of scipy.linalg, which will introduce in a later chapter."
  },
  {
    "objectID": "10_11_NumPy.html#array-operators",
    "href": "10_11_NumPy.html#array-operators",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.4 array Operators",
    "text": "9.4 array Operators\nNumPy provides many operators which enable you to write simple expressions that perform operations on entire arrays. First, let’s perform element-wise arithmetic with arrays and numeric values by using arithmetic operators and augmented assignments. Element-wise operations are applied to every element, so the snippet below multiplies every element by 2 and cubes every element. Each returns a new array containing the result:\n\nnumbers = np.arange(1, 6) # array([1,2,3,4,5])\nnumbers * 2\n\narray([ 2,  4,  6,  8, 10])\n\n\n\nnumbers ** 3\n\narray([  1,   8,  27,  64, 125], dtype=int32)\n\n\nAugmented assignments modify every element in the left operand in place!\n\nnumbers += 10\nnumbers\n\narray([11, 12, 13, 14, 15])\n\n\n\n9.4.1 Broadcasting\nNormally, the arithmetic operations require as operands two arrays of the same size and shape. When one operand is a single value, called a scalar, NumPy performs the elementwise calculations as if the scalar were an array of the same shape as the other operand, but with the scalar value in all its elements. This is called broadcasting. Snippets above use this capability. For example, numbers * 2 is equivalent to numbers * [2, 2, 2, 2, 2]\nBroadcasting also can be applied between arrays of different sizes and shapes, enabling some concise and powerful manipulations. We’ll show more examples of broadcasting later in the chapter when we introduce NumPy’s universal functions.\n\n9.4.1.1 Arithmetic Operations Between arrays\nYou may perform arithmetic operations and augmented assignments between arrays of the same shape. Let’s multiply the one-dimensional arrays numbersand numbers2 (created below) that each contains five elements:\n\nnumbers2 = np.linspace(1.1, 5.5, 5) # array([ 1.1,  2.2,  3.3,  4.4,  5.5])\nnumbers * numbers2\n\narray([12.1, 26.4, 42.9, 61.6, 82.5])\n\n\nThe result is a new array formed by multiplying the arrays element-wise in each operand — 11 * 1.1, 12 * 2.2, 13 * 3.3, etc. Arithmetic between arrays of integers and floating-point numbers results in an array of floating-point numbers.\n\nc = np.ones((3, 3))\nc * c \n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\nNote that the above operation is not matrix multiplication. To perform matrix multiplication use the dot() method!\n\nc.dot(c)\n\narray([[3., 3., 3.],\n       [3., 3., 3.],\n       [3., 3., 3.]])\n\n\nWe can similarly extend broadcasting to arrays of higher dimensions. Observe the result when we add a one-dimensional array to a two-dimensional array:\n\na = np.array([0, 1, 2])\nM = np.ones((3, 3))\nM + a\n\narray([[1., 2., 3.],\n       [1., 2., 3.],\n       [1., 2., 3.]])\n\n\nHere the one-dimensional array a is stretched, or broadcasted, across the second dimension in order to match the shape of M.\n\n\n9.4.1.2 Rules of Broadcasting\nBroadcasting in NumPy follows a strict set of rules to determine the interaction between the two arrays:\n\nRule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.\nRule 2: If the shape of the two arrays does not match in any dimension, the array with a shape equal to 1 in that dimension is stretched to match the other shape.\nRule 3: If in any dimension, the sizes disagree and neither is equal to 1, an error is raised.\n\n\n\n\n\nsource: https://scipy-lectures.org/_images/numpy_broadcasting.png\n\nNow let’s take a look at an example where both arrays need to be broadcast:\n\na = np.arange(3).reshape((3, 1))\nb = np.arange(3)\na + b\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\nWe’ll start by determining the shapes of the arrays:\n\na.shape is (3,1)\nb.shape is (3,)\n\nRule 1 says we must pad the shape of b with ones:\n\na.shape is (3,1)\nb.shape becomes (1,3)\n\nAnd rule 2 tells us that we must upgrade each of these 1s to match the corresponding size of the other array:\n\na.shape is (3,3)\nb.shape becomes (3,3)\n\nNow because the results match, these shapes are compatible!\nNext, let’s look at an example in which the two arrays are incompatible!\n\nM = np.ones((3, 2))\na = np.arange(3)\n\nWe’ll start by determining the shapes of the arrays:\n\nM.shape is (3,2)\na.shape is (3,)\n\nRule 1 says we must pad the shape of a with ones:\n\na.shape is (3,2)\nb.shape becomes (1,3)\n\nBy rule 2, the first dimension of a is then stretched to match that of M:\n\nM.shape is (3,2)\na.shape becomes (3,3)\n\nNow we hit rule 3 — the final shapes do not match, so these two arrays are incompatible, as we can observe by attempting this operation:\n\nM + a\n\nValueError: operands could not be broadcast together with shapes (3,2) (3,) \n\n\n\n\n9.4.1.3 Comparing arrays\nYou can compare arrays with individual values and with other arrays. Comparisons are performed element-wise. Such comparisons produce arrays of Boolean values in which each element’s True or False value indicates the comparison result:\n\nnumbers &gt;= 13 # numbers = array([11, 12, 13, 14, 15])\n\narray([False, False,  True,  True,  True])\n\n\nThe above implicitly used broadcasting!\n\nnumbers2 &lt; numbers # numbers2 = array([ 1.1,  2.2,  3.3,  4.4,  5.5])\n\narray([ True,  True,  True,  True,  True])\n\n\n\nnumbers == numbers2\n\narray([False, False, False, False, False])\n\n\n\nnumbers == numbers\n\narray([ True,  True,  True,  True,  True])"
  },
  {
    "objectID": "10_11_NumPy.html#universal-functions",
    "href": "10_11_NumPy.html#universal-functions",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.5 Universal Functions",
    "text": "9.5 Universal Functions\nNumPy offers dozens of standalone universal functions (or ufuncs) that perform various element-wise operations (which means it applies the same operation to each element in the array). Each performs its task using one or two arrays or array-like (such as lists) arguments. Some of these functions are called when you use operators like + and * on arrays. Each returns a new array containing the results.\n\n9.5.1 The Slowness of Loops\nComputation on NumPy arrays can be very fast or it can be very slow. The key to making it fast is to use vectorized operations, generally implemented through NumPy’s universal functions (ufuncs). The relative sluggishness of Python generally manifests itself in situations where many small operations are being repeated; for instance, looping over arrays to operate on each element. For example, imagine we have an array of values and we’d like to compute the reciprocal of each. A straightforward approach might look like this:\n\ndef compute_reciprocals(values):\n    output = np.empty(len(values))\n    for i in range(len(values)):\n        output[i] = 1.0 / values[i]\n    return output\n\nvalues = np.random.randint(1, 10, 5)\ncompute_reciprocals(values)\n\narray([0.14285714, 0.14285714, 0.25      , 0.16666667, 0.2       ])\n\n\nBut if we measure the execution time of this code for a large input, we see that this operation is very slow:\n\nbig_array = np.random.randint(1, 10, 1_000_000)\n%timeit compute_reciprocals(big_array)\n\n1.22 s ± 9.99 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\nIt turns out that the bottleneck here is not the operations themselves but the type checking and function dispatches that Python must do at each cycle of the loop. Each time the reciprocal is computed, Python first examines the object’s type and does a dynamic lookup of the correct function to use for that type. If we were working in compiled code instead, this type of specification would be known before the code executed and the result could be computed much more efficiently.\nFor many types of operations, NumPy provides a convenient interface into just this kind of statically typed, compiled routine. This is known as a vectorized operation. For simple operations like the element-wise division here, vectorization is as simple as using Python arithmetic operators directly on the array object. This vectorized approach is designed to push the loop into the compiled layer that underlies NumPy, leading to much faster execution.\n\nVectorization in NumPy refers to the practice of performing operations on entire arrays of data, rather than on individual elements. This is accomplished by applying an operation to the entire array, instead of looping through each element of the array one at a time.\n\n\nprint(1.0 / values)\n\n[0.14285714 0.14285714 0.25       0.16666667 0.2       ]\n\n\nLooking at the execution time for our big array, we see that it completes orders of magnitude faster than the Python loop:\n\n%timeit (1.0 / big_array)\n\n2.21 ms ± 58.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\nVectorized operations in NumPy are implemented via ufuncs, whose main purpose is to quickly execute repeated operations on values in NumPy array.\n\n9.5.1.1 Exploring NumPy’s Ufuncs\nLet’s add two arrays with the same shape, using the add() universal function:\n\nnumbers2 = np.arange(1, 7) * 10 # array([10, 20, 30, 40, 50, 60])\nnp.add(numbers, numbers2) # equivalent to numbers + numbers2\n\narray([11, 24, 39, 56, 75, 96])\n\n\n\n\n9.5.1.2 Broadcasting with Universal Functions\nLet’s use the multiply() universal function to multiply every element of numbers2 by the scalar value 5:\n\nnp.multiply(numbers2, 5) # equivalent to numbers2 * 5\n\narray([ 50, 100, 150, 200, 250, 300])\n\n\nLet’s reshape numbers2 into a 2-by-3 array, then multiply its values by a one-dimensional array of three elements:\n\nnumbers3 = numbers2.reshape(2, 3)\nnumbers4 = np.array([2, 4, 6])\nnumbers3, numbers4\n\n(array([[10, 20, 30],\n        [40, 50, 60]]),\n array([2, 4, 6]))\n\n\n\nnp.multiply(numbers3, numbers4) # Equivalent to numbers3 * numbers4\n\narray([[ 20,  80, 180],\n       [ 80, 200, 360]])\n\n\nThis works because numbers4 has the same length as each row of numbers3, so NumPy can apply the multiply operation by treating numbers4 as if it were the following array:\narray([[2, 4, 6],\n       [2, 4, 6]])\nIf a universal function receives two arrays of different shapes that do not support broadcasting, a ValueError occurs. You can review the broadcasting rules at https://numpy.org/doc/stable/user/basics.broadcasting.html.\n\nVectorization and ufunc functions are closely related to broadcasting in NumPy, as they are often used together to perform element-wise operations on arrays of different shapes. By combining vectorization, ufunc functions, and broadcasting, you can efficiently perform complex arithmetic operations on arrays in NumPy.\n\nThere are other special ufunc. Let’s create an array and calculate the square root of its values, using the sqrt universal function:\n\nnumbers = np.array([1, 4, 9, 16, 25, 36])\nnp.sqrt(numbers)\n\narray([1., 2., 3., 4., 5., 6.])\n\n\n\n\n9.5.1.3 Create Your Own Vectorizing functions\nTo get good performance, we should try to avoid looping over elements in our vectors and matrices and instead use vectorized algorithms. The first step in converting a scalar algorithm to a vectorized algorithm is to ensure that the functions we write work with vector inputs.\n\ndef Theta(x):\n    \"\"\"\n    Scalar implemenation of the Heaviside step function.\n    \"\"\"\n    if x &gt;= 0:\n        return 1\n    else:\n        return 0\n\n\nTheta_vec = np.vectorize(Theta)\nTheta_vec(np.array([-3,-2,-1,0,1,2,3]))\n\narray([0, 0, 0, 1, 1, 1, 1])\n\n\nYou can view the complete list, their descriptions and more information about universal functions at https://numpy.org/doc/stable/reference/ufuncs.html\n\nSee here for more vectorization examples in different thinking levels.\n\n\n\n\n9.5.2 Type casting\nSince NumPy arrays are statically typed, the type of an array does not change once created. But we can explicitly cast an array of some type to another using the astype() functions. This always creates a new array of a new type:\n\nM = np.random.rand(5,5)\nM.dtype\n\ndtype('float64')\n\n\n\nM2 = M.astype(np.int64)\nM2\n\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0]], dtype=int64)\n\n\nSee https://scipy-lectures.org/intro/numpy/elaborate_arrays.html for more details."
  },
  {
    "objectID": "10_11_NumPy.html#file-io",
    "href": "10_11_NumPy.html#file-io",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.6 File I/O",
    "text": "9.6 File I/O\nNumPy has its own binary format, not portable but with efficient I/O. This is useful when storing and reading back array data. Use the functions numpy.save() and numpy.load().\n\nnp.save(\"random-matrix.npy\", M)\nM2 = np.load(\"random-matrix.npy\")\nM2\n\narray([[0.63296042, 0.27197126, 0.2261708 , 0.1958696 , 0.9284412 ],\n       [0.27045565, 0.16168923, 0.06145811, 0.91101895, 0.03550733],\n       [0.52027297, 0.5984186 , 0.08252073, 0.80356072, 0.76129669],\n       [0.20675944, 0.47959083, 0.28455249, 0.03627423, 0.4218361 ],\n       [0.11976237, 0.47007539, 0.26740034, 0.51019782, 0.77871332]])\n\n\nIn summary:\nTo make the code faster using NumPy\n\nIn place operations: a *= 3 instead of a = 3*a\nUse views instead of copies whenever possible\nBroadcasting: Use broadcasting to do operations on arrays\nVectorizing for loops: Find tricks to avoid for loops using NumPy arrays.\n\nPython objects:\n\nHigh-level objects: integers, floating-point\nContainers: lists (costless append), dictionaries (fast lookup)\nPython lists are very general. They can contain any kind of object and are dynamically typed\nHowever, they do not support mathematical functions such as matrix and dot multiplications. Implementing such functions for Python lists would not be very efficient because of the dynamic typing\n\nNumPy provides:\n\nExtension package to Python for multi-dimensional arrays\nNumpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created\nBecause of the static typing, fast implementation of mathematical functions such as multiplication and addition of NumPy arrays can be implemented in a compiled language (C and Fortran is used). Moreover, Numpy arrays are memory efficient"
  },
  {
    "objectID": "00_Copilot.html#get-started-with-github-copilot-in-python",
    "href": "00_Copilot.html#get-started-with-github-copilot-in-python",
    "title": "Appendix A — Increase productivity and learning with Github Copilot in Python",
    "section": "A.1 Get Started With GitHub Copilot in Python",
    "text": "A.1 Get Started With GitHub Copilot in Python\nGitHub Copilot, an exciting new innovation, offers a virtual AI-powered assistant integrated into your code editor, creating significant buzz upon its public release. This tool provides exceptional support for languages such as Python.\nGitHub Copilot is the first commercial product based on the OpenAI Codex system, capable of converting natural language into code across more than a dozen programming languages. OpenAI Codex comes from the GPT-3 language learning model. It was taught using both regular text and a vast number of code examples found on GitHub, which has hundreds of millions of public code projects.\n\nA.1.1 Trial or get your free access to GitHub Copilot\nYou can enjoy a sixty-day trial period without paying anything, but only after providing your billing information (Be sure to cancel the unpaid subscription plan before it expires to avoid unwanted charges!). Students and open-source maintainers may get a free GitHub Copilot subscription. GitHub will verify your status once a year based on proof of academic enrollment, such as a picture of your school ID or an email address in the .edu domain. For detailed instructions on setting up follow the steps in the our notes.\n\n\nA.1.2 Install a Visual Studio Code Extension\nBecause Microsoft owns GitHub, it’s no surprise that their Visual Studio Code editor was the first tool to receive GitHub Copilot support. There are a few ways to install extensions in Visual Studio Code, but the quickest is that you can find the Extensions icon in the Activity Bar located on the left-hand side of the window and try searching for the “GitHub Copilot” and “Github Copilot Labs” extension on the Visual Studio Marketplace.\nAfter the installation is complete, Visual Studio Code will ask you to sign in to GitHub to give it access to your GitHub profile, which your new extension requires. Visual Studio Code needs to know who you are to verify your GitHub Copilot subscription status. However, granting access to your GitHub profile will also allow the editor to read your private repositories. If you change your mind, then you can revoke this authorization at any time by going to your GitHub profile settings and finding GitHub for VS Code in the Authorized OAuth Apps.\n\n\nA.1.3 Keyboard shortcut\nTo make working with GitHub Copilot in Visual Studio Code even more productive, here are the most common keyboard shortcuts worth remembering:\n\n\n\nAction\nWindows / Linux\nmacOS\n\n\n\n\nTrigger inline suggestions\nAlt+\\\nOption+\\\n\n\nSee the next suggestion\nAlt+]\nOption+]\n\n\nSee the previous suggestion\nAlt+[\nOption+[\n\n\nAccept a suggestion\nTab\nTab\n\n\nDismiss an inline suggestion\nEsc\nEsc\n\n\nShow all suggestions in a new tab\nCtrl+Enter\nCtrl+Enter\n\n\n\n\nYou can change the keyboard shortcut following the instruction from here\n\nSometimes GitHub Copilot suggestions may get in your way. If that’s the case, then you can disable them globally or for a particular programming language by clicking on the extension’s icon in the bottom right corner of the editor’s window:\n\n\n\n\nsource: https://realpython.com/github-copilot-python/#install-a-visual-studio-code-extension\n\n\n\nA.1.4 Hand Over the Reins to GitHub Copilot\nNow it’s time to make sure GitHub Copilot is working as expected in either Visual Studio Code. To check if GitHub Copilot is working as expected start writing a sample function signature, such as add(a, b):\n\ndef hello:\n    \n\nAs soon as you type the colon (:) at the end of the first line to introduce a new code block, GitHub Copilot fills in the suggested function body for you. Until you either accept it by hitting Tab or reject it with Esc, it’ll show up in gray font. The suggested code calls the print() function to display the Hello World text on the screen in this case. While that wasn’t spectacular, it confirms that GitHub Copilot is indeed working correctly!\n\ndef add(a, b):\n    \n\nSure enough, GitHub Copilot gives a very sensible suggestion, which returns the sum of a and b. Notice the difference between returning a value from the function and printing the result on the screen. Your clever virtual assistant can infer the intent from the function’s name and arguments."
  },
  {
    "objectID": "00_Copilot.html#synthesize-python-code-from-natural-language",
    "href": "00_Copilot.html#synthesize-python-code-from-natural-language",
    "title": "Appendix A — Increase productivity and learning with Github Copilot in Python",
    "section": "A.2 Synthesize Python Code From Natural Language",
    "text": "A.2 Synthesize Python Code From Natural Language\nBecause GitHub Copilot was trained on natural language as well as curated samples of different programming languages. Therefore, it’s perfectly possible to explain an abstract problem to GitHub Copilot using plain English or another natural language and expect it to generate the corresponding code in the desired programming language.\n\nThe underlying machine learning model is also capable of doing the opposite — that is, explaining a piece of code in a natural language or even translating one programming language into another.\n\n\nA.2.1 Use a Python Comment to Describe the Problem\nComments can sometimes be helpful in explaining why a certain piece of code looks the way it does. You typically write comments for your future self or your teammates working on the same codebase. When you add GitHub Copilot into the mix, then it becomes yet another target audience who can read your code comments. Consider the following single-line comment in Python, which describes the classic Hello, World! program:\n\n# Print \"Hello, World!\"\n\nAfter typing that comment into your code editor, you’ll notice that GitHub Copilot doesn’t automatically pick it up. When you choose to communicate with it through comments, you must open the GitHub Copilot side panel or tab to see the suggestions (ALT+ENTER). Alternatively, you may start typing a bit of code to have it auto-completed. Notice that GitHub Copilot understands that you wish to treat the quoted fragment \"Hello, world!\" of your comment as literal text rather than an instruction!\nApparently, that was too easy for GitHub Copilot. How about raising the bar by requesting a more specific output? For example, you may want to print Hello, World! backward in Chinese. The best one that you’ll ever get for this particular comment is this:\n\n# Print \"Hello, World!\" in Chinese in reverse order\nprint('世界，你好！'[::-1])\n\n！好你，界世\n\n\nNow, tha’’s impressive! GitHub Copilot nails it by generating not only correct but also Pythonic code that experienced Pythonistas would write themselves. The suggestions will get even more interesting when you include more comments.\n\n\nA.2.2 Add More Comments to Increase the Problem Complexity\nUsing a single-line comment to describe a problem is fine, but you can only pack so much content in it. Fortunately, it’s possible to combine multiple consecutive comments into a logical and cohesive story that GitHub Copilot will treat as a whole. You can use multiline comments to achieve this:\n\n\"\"\"\nWrite a program that does the following:\n1.  Create a dictionary called `grades` that maps subject names to lists of grades for each student. Assume that each student has the same number of grades for each subject.\n2.  Create a dictionary called `subject_averages` that maps subject names to their average grades across all students.\n3.  Create a dictionary called `student_totals` that maps student names to their total grades across all subjects.\n4.  Create a variable called `top_student` that contains the name of the student with the highest total grade.\n5.  Print out the top-performing student's name and total grade, as well as the average grade for each subject.\n\"\"\"\n\ngrades = {\n    'Math': [[90, 85, 92, 87, 94], [95, 88, 91, 89, 92], [87, 83, 85, 90, 89]],\n    'Science': [[82, 88, 89, 91, 85], [90, 86, 88, 87, 92], [85, 83, 87, 84, 89]],\n    'English': [[88, 85, 92, 86, 90], [91, 87, 89, 92, 85], [83, 86, 88, 87, 90]],\n}\n\nStudent 2 has the highest total grade of 1342\nThe average grade for Math is 89.13333333333334\nThe average grade for Science is 87.06666666666666\nThe average grade for English is 87.93333333333334\n\n\nIsn’t that amazing? You gave GitHub Copilot a natural language description of a task, and it got exactly the right solution for you.\n\nKeep in mind that the suggestions you’ll might get different results from those presented here. Sometimes it takes trial and error before getting the desired result, so try tweaking your comments a little bit if you’re not getting satisfactory results immediately.\n\nYou can edit the code generated by GitHub Copilot just like your own code. Sometimes, you may not like its formatting, the naming conventions that it applied, or a specific fragment of the logic that you’d rather rewrite. On other occasions, seeing a suggestion may inspire you to come up with a more clever alternative.\n\n\nA.2.3 Receive Even More Intelligent Code Completion Suggestions\nYou can think of GitHub Copilot as an intelligent code completion mechanism on steroids that understands the context of your project at a deep level, providing the most appropriate suggestions for you. When you work with GitHub Copilot long enough, it may sometimes give you the creepy feeling that it can read your mind. Say that you want to find the roots of the second-degree polynomial, also known as the quadratic function, with three coefficients: a, b, and c:\n\ndef find_roots(a, b, c):\n    \"\"\"\n    Write a function that takes in the coefficients of a quadratic equation and returns the roots of the equation.\n    \"\"\"\n    discriminant = b**2 - 4*a*c\n    if discriminant &lt; 0:\n        return None\n    elif discriminant == 0:\n        return -b / (2*a)\n    else:\n        return (-b + discriminant**0.5) / (2*a), (-b - discriminant**0.5) / (2*a)\n\n\nfind_roots(1, 2, 1)  # Function f(x) = x^2 + 2x + 1\n\n-1.0\n\n\n\nA.2.3.1 Provide Context to Get Better Suggestions\nThe fundamental theorem of algebra states that a degree 𝑛 polynomial with complex coefficients has exactly n complex roots. In other words, a quadratic function, which is a second-degree polynomial, always has exactly two complex roots even when there are none in the real domain. How can you request that GitHub Copilot change the implementation so that you’ll get the complex roots instead of the real ones? You need to add constraints to the problem by giving GitHub Copilot some context to draw from. For example, you may import a module that you wish to be used or write a Python docstring that describes the expected result in natural language:\n\nimport cmath # For complex numbers\n\ndef find_roots(a, b, c):\n    \"\"\"Return a tuple of complex numbers.\"\"\"\n\n\nfind_roots(1, 0, 1)  # Function f(x) = x^2 + 1\n\n(1j, -1j)\n\n\n\n\n\nA.2.4 Ditch Stack Overflow for Instant, Context-Aware Solutions\nGitHub Copilot can reduce your dependence on daily tasks. It can instantly deliver tailor-made code snippets that fit the context of your project like a glove, unlike even the best answer you’d find online. Moreover, it doesn’t force you to leave the code editor, so you can stay in the zone and accelerate your progress. Read on to get a taste of having the collective knowledge of the Python community at your fingertips.\nPython has a relatively expressive syntax, which allows you to write concise and readable code. Nevertheless, occasional boilerplate code is unavoidable, even in your favorite programming language. Sometimes, there’s no way around writing a piece of code that looks long and verbose yet seemingly doesn’t do a lot of useful work.\nFor example, fetching data from a URL address, serializing it to JSON, and saving the result to a file involves a lot of boring details, which don’t contribute much value. Wouldn’t it be cool if you could focus on what matters to you the most—that is, sorting out a solution to a higher-level problem while letting GitHub Copilot map the individual steps to fragments of code? Well, it turns out that you can! As before, start by writing a descriptive function signature, and leave the rest to GitHub Copilot:\n\ndef save_json(url, filename):\n    \"\"\"\n    Write a function that takes in a URL and a filename, and saves the JSON response from the URL to the filename.\n    \"\"\"\n    import requests\n    import json\n    response = requests.get(url)\n    with open(filename, 'w') as f:\n        json.dump(response.json(), f)\n\n\nsave_json(\"https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json\", \"pokedex.json\")\n\n\n\nA.2.5 Always Have the API Documentation at Your Fingertips\nSay you wanted to write a small Python function to process the word file. In the traditional approach, you’d start by making a web search for word API. Then, you’d probably get overwhelmed by their guides, quick starts, and reference documentation. Fortunately, you have GitHub Copilot, which has been trained to use well-known APIs, so you can give it a minimal hint about which API to call:\n\n# install library that process word file for python\n!pip install python-docx\n\nDefaulting to user installation because normal site-packages is not writeable\nCollecting python-docx\n  Downloading python-docx-0.8.11.tar.gz (5.6 MB)\n     ---------------------------------------- 5.6/5.6 MB 25.3 MB/s eta 0:00:00\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: lxml&gt;=2.3.2 in c:\\programdata\\anaconda3\\lib\\site-packages (from python-docx) (4.9.1)\nBuilding wheels for collected packages: python-docx\n  Building wheel for python-docx (setup.py): started\n  Building wheel for python-docx (setup.py): finished with status 'done'\n  Created wheel for python-docx: filename=python_docx-0.8.11-py3-none-any.whl size=184489 sha256=9989f8c38802a0fbc53905ed3c08f3091c5722db4935f7c9e6f1b70726f89bd4\n  Stored in directory: c:\\users\\adm\\appdata\\local\\pip\\cache\\wheels\\83\\8b\\7c\\09ae60c42c7ba4ed2dddaf2b8b9186cb105255856d6ed3dba5\nSuccessfully built python-docx\nInstalling collected packages: python-docx\nSuccessfully installed python-docx-0.8.11\n\n\n\n# Getting the Full Text from a demo.docx File\n\nDocument Title\nA plain paragraph with some bold and some italic\nHeading, level 1\nIntense quote\nfirst item in unordered list\nfirst item in ordered list\n\n\n\n\nExploring new libraries in Python with GitHub Copilot is an enjoyable experience. Perhaps you’re revisiting a framework for which your knowledge has become a little rusty, and you’re struggling to remember where to begin. But even when you’re quite familiar with a given tool, GitHub Copilot can sometimes surprise you by suggesting more efficient solutions or parts of its API that you had no idea about.\nThe name copilot was a clever choice by GitHub to describe this product. It avoids misleading people into thinking it could take control and replace you as the programmer. You have to remember that the code produced by GitHub Copilot isn’t always ideal. In fact, it can sometimes be suboptimal or insecure, and it might follow bad programming practices.\n\nIt’s less of a problem when the code contains syntactical errors or if it’s completely nonsensical, because that’s easy to spot. However, the code that looks plausible at first glance can still be incorrect and contain logical errors. Therefore, you should never trust GitHub Copilot without carefully reviewing and testing the code it generates!\n\n\nIt may make us lazy and discourage them from thinking independently. Like with every powerful tool, you can use GitHub Copilot for the right or wrong purposes.\n\nGitHub Copilot is a revolutionary programming aid that can increase your speed and productivity as a software engineer. It saves you time by generating boilerplate code and sparing you from diving into documentation. Because it understands the context of your project, the instant suggestions that you get are tailor-made and usually work the way you intended.\n\n\nA.2.6 Prompt-engineer\n\n# Create a list of the first 10 prime numbers\nx =\n\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n\n\n# Create a list of the first 10 prime numbers using a list comprehension\nx ="
  },
  {
    "objectID": "00_Copilot.html#copilot-labs",
    "href": "00_Copilot.html#copilot-labs",
    "title": "Appendix A — Increase productivity and learning with Github Copilot in Python",
    "section": "A.3 Copilot Labs",
    "text": "A.3 Copilot Labs\nhttps://dev.to/github/why-use-github-copilot-and-copilot-labs-practical-use-cases-for-the-ai-pair-programmer-4hf4\nhttps://github.com/blackgirlbytes/rock-paper-scissors-copilot/\n\ndef isLeapYear(year):\n    # Years divisible by 400 are leap years:\n    if year % 400 == 0:\n        return True\n    # Otherwise, years divisible by 100 are not leap years:\n    elif year % 100 == 0:\n        return False\n    # Otherwise, years divisible by 4 are leap years:\n    elif year % 4 == 0:\n        return True\n    # Otherwise, every other year is not a leap year:\n    else:\n        return False\n\ndef upcoming_leap_year(current_year):\n    while True:\n        if isLeapYear(current_year):\n            return current_year\n        current_year += 1\n\nassert upcoming_leap_year(2023) == 2024\nassert upcoming_leap_year(1999) == 2000\nassert upcoming_leap_year(2099) == 2104"
  },
  {
    "objectID": "04_Algorithms_sol.html#a-taste-of-algorithm",
    "href": "04_Algorithms_sol.html#a-taste-of-algorithm",
    "title": "Appendix B — Algorithms",
    "section": "B.1 A taste of algorithm",
    "text": "B.1 A taste of algorithm\nAn informal definition of an algorithm is:\n\nAlgorithm: a step-by-step method for solving a problem or doing a task.\n\nIn this definition, an algorithm is independent of the computer system. More specifically, we should also note that the algorithm accepts input data and creates output data\n\n\n\nLet us elaborate on this simple definition with an example. We want to develop an algorithm for finding the largest integer among a list of positive integers. It is obvious that finding the largest integer among many integers is a task that cannot be done in one step. The algorithm needs to test each integer one by one.\nTo solve this problem, we need an intuitive approach. First use a small number of integers (for example, five), then extend the solution to any number of integers. Assume that the algorithm handles the integers one by one. It looks at the first integer without knowing the values of the remaining integers. After it handles the first one, it looks at the second integer, and so on.\n\n\n\nThe above figure does not show what should be done in each step. We can modify the figure to show more details.\n\n\n\nThere are two problems for the above figure to become an algorithm that can be programmed. First, the action in the first step is different than those for the other steps. Second, the wording is not the same in steps 2 to 5. The reason that the first step is different than the other steps is because Largest is not initialized! If we initialize Largest to \\(-∞\\), then the first step can be the same as the other steps!\n\n\n\nIs it possible to generalize the algorithm? We want to find the largest of n positive integers, where n can be 1000, 1000000, or more. We can tell the computer to repeat the steps n times!"
  },
  {
    "objectID": "04_Algorithms_sol.html#algorithm-representations",
    "href": "04_Algorithms_sol.html#algorithm-representations",
    "title": "Appendix B — Algorithms",
    "section": "B.2 Algorithm representations",
    "text": "B.2 Algorithm representations\nComputer scientists have defined three constructs for a structured program or algorithm. The idea is that a program must be made of a combination of only these three constructs: sequence, decision, and repetition.\n\nIt has been proven there is no need for any other constructs!\n\n\n\n\n\nx = 150\nif x%2 == 0:\n  print('x is even')\nelse:\n  print('x is odd')\n\nx is even\n\n\n\nn = 0\nwhile (n &lt; 10):\n  print(n)\n  n = n + 1\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nB.2.1 Example 1: Write an algorithm that finds the sum of two integers.\nThis is a simple problem that can be solved using only the sequence construct. Note also that we name the algorithm, define the input to the algorithm and, at the end, we use a return instruction to return the sum\n\ndef SumOfTwo(first, second):\n  \"\"\"\n    Parameters\n    ----------\n    first: int\n        The first integer\n    second: int\n        The second integer\n    Returns\n    -------\n    sum : int\n        The sum of two integers\n  \"\"\"\n  # Your code here\n  sum = first + second\n  return sum\n\n\nassert(SumOfTwo(3,5)==8)\nassert(SumOfTwo(-7,-3)==-10)\n\n\n\nB.2.2 Example 2: Write an algorithm to change a numeric grade to a pass/no pass grade.\nThis problem cannot be solved with only the sequence construct. We also need the decision construct. The computer is given an integer between 0 and 100. It returns ‘pass’ if the integer is greater than or equal to 70, and returns ‘no pass’ if the integer is less than 60.\n\ndef Pass_NoPass(score):\n  \"\"\"\n    Parameters\n    ----------\n    score: int\n        The score to be changed to grade\n    Returns\n    -------\n    grade : str\n        The grade\n  \"\"\"\n  # Your code here\n  if score &gt;= 60:\n    grade = \"pass\"\n  else:\n    grade = \"nopass\"\n  return grade\n\n\nassert(Pass_NoPass(90)==\"pass\")\nassert(Pass_NoPass(55)==\"nopass\")\n\n\n\nB.2.3 Example 3: Write an algorithm to find the largest of a set of integers. We do not know the number of integers.\nWe use the concept before to write an algorithm for this problem\n\nimport math\n\ndef FindLargest(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: list\n        The input list that contains integers\n    Returns\n    -------\n    largest : int\n        The largest integer\n  \"\"\"\n  # Your code here\n  largest = - math.inf\n  for current in ilist:\n    if current &gt; largest:\n      largest = current\n    else:\n      pass\n  return largest\n\n\nassert(FindLargest([])==-math.inf)\nassert(FindLargest([7,3,5,10])==10)\nassert(FindLargest([-7,-2,5,18])==18)\n\n\nB.2.4 Exercise 1: Write an algorithm to find the smallest of the first 5 integers in a set of integers.\n\nHere we need a counter to count the number of integers.\n\ndef FindSmallest(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: list\n        The input list that contains integers\n    Returns\n    -------\n    largest : int\n        The smallest integer of the first 5 integers in the list\n  \"\"\"\n  # Your code here\n  smallest = math.inf\n  if len(ilist) != 0:\n    counter = 0\n    while(counter&lt;5):\n      if ilist[counter] &lt; smallest:\n        smallest = ilist[counter]\n      counter = counter +1\n  return smallest\n\n\nassert(FindSmallest([])== math.inf)\nassert(FindSmallest([7,3,5,10,6])==3)\nassert(FindSmallest([7,4,5,10,6,1])==4)"
  },
  {
    "objectID": "04_Algorithms_sol.html#a-more-formal-definition",
    "href": "04_Algorithms_sol.html#a-more-formal-definition",
    "title": "Appendix B — Algorithms",
    "section": "B.3 A more formal definition",
    "text": "B.3 A more formal definition\nNow that we have discussed the concept of an algorithm and shown its representation, here is a more formal definition.\n\nAlgorithm: An ordered set of unambiguous steps that produces a result and terminates in a finite time.\n\n\nWell-Defined: An algorithm must be a well-defined, ordered set of instructions.\nUnambiguous steps: Each step in an algorithm must be clearly and unambiguously defined. If one step is to add two integers, we must define both ‘integers’ as well as the ‘add’ operation\nProduce a result: An algorithm must produce a result, otherwise it is useless. The result can be data returned to the calling algorithm, or some other effect (for example, printing).\nTerminate in a finite time: An algorithm must terminate (halt). If it does not (that is, it has an infinite loop), we have not created an algorithm."
  },
  {
    "objectID": "04_Algorithms_sol.html#basic-algorithms",
    "href": "04_Algorithms_sol.html#basic-algorithms",
    "title": "Appendix B — Algorithms",
    "section": "B.4 Basic algorithms",
    "text": "B.4 Basic algorithms\nSeveral algorithms are used in computer science so prevalently that they are considered ‘basic’.\n\nB.4.0.1 Summation\nOne commonly used algorithm in computer science is summation. The solution is simple: we use the add operator in a loop\n\n\n\n\ndef summation(numbers):\n  \"\"\"\n    Parameters\n    ----------\n    numbers: list\n        The input list.\n    Returns\n    -------\n    sum : int\n        The summation of the input list, if the input is empty please return None\n  \"\"\"\n  # Your code here\n  # Special case: If the numbers list is empty, return None:\n  if len(numbers) == 0:\n    return None\n\n  # Start the total at 0:\n  sum = 0\n\n  # Loop over each number in numbers:\n  for current in numbers:\n    # Add the number to the total:\n    sum += current\n\n  return sum\n\n\nassert summation([1, 2, 3]) == sum([1, 2, 3])\nassert summation([12, 20, 37]) == sum([12, 20, 37])\nassert summation([]) == None\n\n\n\nB.4.0.2 Product\nAnother common algorithm is finding the product of a list of integers.\n\n\n\n\ndef product(numbers):\n  \"\"\"\n    Parameters\n    ----------\n    numbers: list\n        The input list.\n    Returns\n    -------\n    product : int\n        The product of the input list, if the input is empty please return None\n  \"\"\"\n  # Special case: If the numbers list is empty, return None:\n  if len(numbers) == 0:\n    return None\n\n  # Your code here\n  product = 1\n\n  # Loop over each number in numbers:\n  for current in numbers:\n    # Multiply the number to the total:\n    product *= current\n\n  return product\n\n\n# For Python 3.8 or later\nassert product([1, 2, 3]) == math.prod([1, 2, 3])\nassert product([12, 20, 37]) == math.prod([12, 20, 37])\nassert product([]) == None\n\n\n# For Python 3.7 or earlier\nimport numpy as np\nassert product([1, 2, 3]) == np.prod([1, 2, 3])\nassert product([12, 20, 37]) == np.prod([12, 20, 37])\nassert product([]) == None\n\n\n\nB.4.0.3 Smallest and largest"
  },
  {
    "objectID": "04_Algorithms_sol.html#sorting",
    "href": "04_Algorithms_sol.html#sorting",
    "title": "Appendix B — Algorithms",
    "section": "B.5 Sorting",
    "text": "B.5 Sorting\nOne of the most common applications in computer science is sorting, which is the process by which data is arranged according to its values. People are surrounded by data. If the data was not ordered, it would take hours and hours to find a single piece of information. Imagine the difficulty of finding someone’s telephone number in a telephone book that is not ordered!\n\nB.5.1 Selection sorts\nIn a selection sort, the list to be sorted is divided into two sublists — sorted and unsorted— which are separated by an imaginary wall. We find the smallest element from the unsorted sublist and swap it with the element at the beginning of the unsorted sublist. After each selection and swap, the imaginary wall between the two sublists moves one element ahead, increasing the number of sorted elements and decreasing the number of unsorted ones. Each time we move one element from the unsorted sublist to the sorted sublist, we have completed a sort pass.\nA list of n elements requires n  − 1 passes to completely rearrange the data.\n\n\n\nThe visualization is as follows:\n\n\n\nThe figure shows how the wall between the sorted and unsorted sublists moves in each pass. As we study the figure, we will see that the list is sorted after five passes, which is one less than the number of elements in the list. Thus, if we use a loop to control the sorting, the loop will have one less iteration than the number of elements to be sorted.\n\n\n\n\nsource: https://github.com/hustcc/JS-Sorting-Algorithm\n\nRefer to https://visualgo.net/en/sorting for more visualization of sorting algorithms.\n\n\n\nThe algorithm uses two loops, one inside the other. The outer loop is iterated for each pass: the inner loop finds the smallest element in the unsorted list.\n\nB.5.2 Exercise 2: Write a selection sort for list of intergers that sorts the integer from smallest to largest\n\n\ndef selection_sort(arr):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    Returns\n    -------\n    arr : list\n        The sorted list\n  \"\"\"\n  n = len(arr)\n  ## Move the wall one element to the right\n  for wall in range(n-1):\n    ## Place the wall at the leftmost of the list\n    min_index = wall\n    ## Find smallest element in the unsorted list\n    for cur in range(min_index+1,n):\n      if arr[cur] &lt; arr[min_index]:\n        min_index = cur\n    ## Swap smallest element with first element in the unsorted list\n    arr[wall], arr[min_index] = arr[min_index], arr[wall]\n  return arr\n\n\nassert(selection_sort([89,78,61,53,23,21,17,12,9,7,6,2,1])==sorted([89,78,61,53,23,21,17,12,9,7,6,2,1]))\nassert(selection_sort([1,5,8,9])==sorted([1,5,8,9]))\nassert(selection_sort([78,12,15,8,61,53,23,27])==sorted([78,12,15,8,61,53,23,27]))\nassert(selection_sort([5])==sorted([5]))\n\n\n\nB.5.3 Bubble sort\nIn the bubble sort method, the list to be sorted is also divided into two sublists—sorted and unsorted. The smallest element is bubbled up from the unsorted sublist and moved to the sorted sublist. After the smallest element has been moved to the sorted list, the wall moves one element ahead, increasing the number of sorted elements and decreasing the number of unsorted ones.\nEach time an element moves from the unsorted sublist to the sorted sublist, one sort pass is completed. Given a list of n elements, bubble sort requires up to n − 1 passes to sort the data.\n\n\n\nThe following shows how the wall moves one element in each pass. Looking at the first pass, we start with 56 and compare it to 32. Since 56 is not less than 32, it is not moved, and we step down one element. No exchanges take place until we compare 45 to 8. Since 8 is less than 45, the two elements are exchanged, and we step down one element. Because 8 was moved down, it is now compared to 78, and these two elements are exchanged. Finally, 8 is compared to 23 and exchanged. This series of exchanges places 8 in the first location, and the wall is moved up one position. The algorithm gets its name from the way in which numbers — in this example, 8 — appear to move to the start, or top, of the list in the same way that bubbles rise through water.\n\n\n\n\n\n\n\nsource: https://github.com/hustcc/JS-Sorting-Algorithm\n\n\n\n\n\nB.5.4 Exercise 3: Write a bubble sort for list of intergers that sorts the integer from smallest to largest\n\n\ndef bubble_sort(arr):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    Returns\n    -------\n    arr : list\n        The sorted list\n  \"\"\"\n  n = len(arr)\n  ## Move the wall one element to the right\n  for wall in range(n-1):\n    #swapped = False\n    ## bubble each element up to the left\n    for j in range(n-1, wall, -1):\n      if arr[j] &lt; arr[j-1]:\n        arr[j], arr[j-1] = arr[j-1], arr[j]\n        #swapped = True\n  return arr\n\n\nassert(bubble_sort([89,78,61,53,23,21,17,12,9,7,6,2,1])==sorted([89,78,61,53,23,21,17,12,9,7,6,2,1]))\nassert(bubble_sort([1,5,8,9])==sorted([1,5,8,9]))\nassert(bubble_sort([78,12,15,8,61,53,23,27])==sorted([78,12,15,8,61,53,23,27]))\nassert(bubble_sort([5])==sorted([5]))\n\n\n\nB.5.5 Insertion sort\nThe insertion sort algorithm is one of the most common sorting techniques, and it is often used by card players. Each card a player picks up is inserted into the proper place in their hand of cards to maintain a particular sequence. (Card sorting is an example of a sort that uses two criteria for sorting: suit and rank.)\nIn an insertion sort, as in the other two sorting algorithms discussed above, the list is divided into two parts—sorted and unsorted. In each pass, the first element of the unsorted sublist is transferred to the sorted sublist and inserted at the appropriate place. Note that a list of n elements will take n − 1 passes to sort the data.\n\n\n\n\n\n\nAs you can perceive from the above figure, the wall moves with each pass as an element is removed from the unsorted sublist and inserted into the sorted sublist.\n\n\n\n\nsource: https://github.com/hustcc/JS-Sorting-Algorithm\n\nThe design of insertion sort follows the same pattern seen in both selection sort and bubble sort. The outer loop is iterated for each pass, and the inner loop finds the position of insertion.\n\n\n\n\nB.5.6 Exercise 4: Write a insertion sort for list of intergers that sorts the integer from smallest to largest\n\n\ndef insertion_sort(arr):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    Returns\n    -------\n    arr : list\n        The sorted list\n  \"\"\"\n  n = len(arr)\n  ## Move the wall one element to the right\n  for wall in range(1,n):\n    temp = arr[wall]\n    cur =  wall -1\n    while arr[cur] &gt; temp and cur &gt;= 0:\n      arr[cur+1] = arr[cur]\n      cur = cur -1 \n    arr[cur+1] = temp\n  return arr\n\n\nassert(insertion_sort([89,78,61,53,23,21,17,12,9,7,6,2,1])==sorted([89,78,61,53,23,21,17,12,9,7,6,2,1]))\nassert(insertion_sort([1,5,8,9])==sorted([1,5,8,9]))\nassert(insertion_sort([78,12,15,8,61,53,23,27])==sorted([78,12,15,8,61,53,23,27]))\nassert(insertion_sort([5])==sorted([5]))\n\nThe three sorting algorithms discussed here are the least efficient sorting algorithms, and should not be used if the list to be sorted has more than a few hundred elements. There are however several reasons for discussing these sorting algorithms in an introductory book:\n\nThey are the simplest algorithms to understand and analyze.\nThey are the foundation of more efficient algorithms such as quicksort, heap sort, Shell sort, bucket sort, merge sort, radix sort, and so on.\n\nMost such advanced sorting algorithms are discussed in books on data structures. You may ask why there are so many sorting algorithms. The reason lies in the type of data that needs to be sorted. One algorithm may be more efficient for a list that is partially sorted, whereas another algorithm may be more efficient for a list that is completely unsorted.\nSee https://www.sortvisualizer.com/ for more details"
  },
  {
    "objectID": "04_Algorithms_sol.html#searching",
    "href": "04_Algorithms_sol.html#searching",
    "title": "Appendix B — Algorithms",
    "section": "B.6 Searching",
    "text": "B.6 Searching\nAnother common algorithm in computer science is searching, which is the process of finding the location of a target among a list of objects. In the case of a list, searching means that given a value, we want to find the location of the first element in the list that contains that value. There are two basic searches for lists: sequential search and binary search. Sequential search can be used to locate an item in any list, whereas binary search requires the list first to be sorted.\n\nB.6.1 Sequential search\nSequential search is used if the list to be searched is not ordered. Generally, we use this technique only for small lists, or lists that are not searched often. In other cases, the best approach is to first sort the list and then search it using the binary search discussed later.\nIn a sequential search, we start searching for the target from the beginning of the list. We continue until we either find the target or reach the end of the list. The following figure traces the steps to find the value 62. The search algorithm needs to be designed so that the search stops when we find the target or when we reach the end of the list.\n\n\n\n\nB.6.2 Exercise 5: Write a sequential search for a list of intergers that return the index of the target value. Note that we should return None if the target does not in the list!\n\n\ndef sequential_search(arr, target):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    target: int\n        The target we are trying to search\n    Returns\n    -------\n    location : int\n        The location or index of the target. Return None if it does not contain the target \n  \"\"\"\n  location = 0\n  while location &lt; len(arr) and arr[location] != target:\n    location += 1\n\n  if location == len(arr):\n    return None\n  return location\n\n\nassert(sequential_search([0,5,7,10,15], 0)==[0,5,7,10,15].index(0))\nassert(sequential_search([0,3,10,15,7], 15)==[0,3,10,15,7].index(15))\nassert(sequential_search([0,3,10,15,7], 7)==[0,3,10,15,7].index(7))\nassert(sequential_search([0,3,10,15,7], 6)==None)\n\n\n\nB.6.3 Binary search\nThe sequential search algorithm is very slow. If we have a list of a million elements, we must do a million comparisons in the worst case. If the list is not sorted, this is the only solution. If the list is sorted, however, we can use a more efficient algorithm called binary search. Generally speaking, programmers use a binary search when a list is large.\nA binary search starts by testing the data in the element at the middle of the list. This determines whether the target is in the first half or the second half of the list. If it is in the first half, there is no need to further check the second half. If it is in the second half, there is no need to further check the first half. In other words, we eliminate half the list from further consideration.\nWe repeat this process until we either find the target or satisfy ourselves that it is not in the list. The following figure shows how to find the target, 22, in a list of 12 numbers using three references: first, mid, and last.\n\nAt the beginning, first shows 1 and last shows 12. Let mid show the middle position, (1 + 12)/ 2, or 6 if truncated to an integer. Now compare the target (22) with data at position 6 (21). The target is greater than this value, so we ignore the first half of the list.\nMove first after mid, to position 7. Let mid show the middle of the second half, (7  +  12) / 2, or 9. Now compare the target (22) with data at position 9 (62). The target is smaller than this value, so we ignore the integers from this value (62) to the end.\nMove last before mid to position 8. Recalculate mid again, (8 + 7) / 2, or 7. Compare the target (22) with the value at this position (22). We have found the target and can quit.\n\n\n\n\nThe algorithm for binary search needs to be designed to find the target or to stop if the target is not in the list. It can be shown that if the target is not found in the list, the value of last becomes smaller than the value of first, an abnormal condition that helps us to know when to come out of the loop.\n\nB.6.4 Exercise 6: Write a binary search for a sorted list of intergers that return the index of the target value. Note that we should return None if the target does not in the list!\n\n\ndef binary_search(arr, target):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The sorted input list that contains integers\n    target: int\n        The target we are trying to search\n    Returns\n    -------\n    location : int\n        The location or index of the target. Return None if it does not contain the target \n  \"\"\"\n  first, last = 0, len(arr) - 1\n  while first &lt;= last:\n    mid = (first + last) // 2\n    val = arr[mid]\n    if val == target:\n      return mid\n    if val &lt; target:\n      first = mid + 1\n    else:\n      last = mid - 1\n  return None\n\n\nassert(binary_search(sorted([0,5,7,10,15]), 0)==sorted([0,5,7,10,15]).index(0))\nassert(binary_search(sorted([0,3,10,15,7]), 15)==sorted([0,3,10,15,7]).index(15))\nassert(binary_search(sorted([0,3,10,15,7]), 7)==sorted([0,3,10,15,7]).index(7))\nassert(binary_search(sorted([0,3,10,15,7]), 6)==None)"
  },
  {
    "objectID": "04_Algorithms_sol.html#recursion",
    "href": "04_Algorithms_sol.html#recursion",
    "title": "Appendix B — Algorithms",
    "section": "B.7 Recursion",
    "text": "B.7 Recursion\nIn general, there are two approaches to writing algorithms for solving a problem. One uses iteration, the other uses recursion. Recursion is a process in which an algorithm calls itself.\n\nB.7.1 Iterative\nTo study a simple example, consider the calculation of a factorial. The factorial of a integer is the product of the integral values from 1 to the integer. The definition is iterative as shown below. An algorithm is iterative whenever the definition does not involve the algorithm itself.\n\n\n\n\n\nB.7.2 Recursive\nAn algorithm is defined recursively whenever the algorithm appears within the definition itself. For example, the factorial function can be defined recursively as shown below.\n\n\n\nThe decomposition of factorial (3), using recursion, is shown below. If we study the figure carefully, we will note that the recursive solution for a problem involves a two-way journey. First we decompose the problem from top to bottom, and then we solve it from bottom to top.\nAlthough the recursive calculation looks more difficult when using paper and pencil, it is often a much easier and more elegant solution when using computers. Additionally, it offers a conceptual simplicity to the creator and the reader!\n\n\n\n\n\nB.7.3 Example 4: Let us write an algorithm to solve the factorial problem iteratively!\n\ndef Factorial(n):\n  \"\"\"\n    Parameters\n    ----------\n    n: int\n        The target factorial which is a nonnegative integer\n    Returns\n    -------\n    results : int\n        The result number \n  \"\"\"\n  results = 1\n  for i in range(1,n+1):\n    results *=i\n  return results\n\n\nassert(Factorial(5)==math.factorial(5))\nassert(Factorial(10)==math.factorial(10))\nassert(Factorial(1)==math.factorial(1))\nassert(Factorial(0)==math.factorial(0))\n\n\n\nB.7.4 Exercise 7: Try to write an algorithm to solve the factorial problem using recursion!\n\ndef Factorial_r(n):\n  \"\"\"\n    Parameters\n    ----------\n    n: int\n        The target factorial which is a positive integer\n    Returns\n    -------\n    results : int\n        The result number \n  \"\"\"\n  if n == 0:\n    return 1\n  else:\n    return n*Factorial_r(n-1)\n\n\nassert(Factorial_r(5)==math.factorial(5))\nassert(Factorial_r(10)==math.factorial(10))\nassert(Factorial_r(1)==math.factorial(1))\nassert(Factorial_r(0)==math.factorial(0))"
  },
  {
    "objectID": "05_Data_Structure_sol.html#a-taste-of-data-structure",
    "href": "05_Data_Structure_sol.html#a-taste-of-data-structure",
    "title": "Appendix C — Data Structure",
    "section": "C.1 A taste of data structure",
    "text": "C.1 A taste of data structure\n\nA data structure uses a collection of related variables that can be accessed individually or as a whole.\n\nIn other words, a data structure represents a set of data items that share a specific relationship."
  },
  {
    "objectID": "05_Data_Structure_sol.html#objects",
    "href": "05_Data_Structure_sol.html#objects",
    "title": "Appendix C — Data Structure",
    "section": "C.2 Objects",
    "text": "C.2 Objects\nAs it turns out, we have been using objects. Python provides us with many built-in objects. Here is some simple code where the first few lines should feel very simple and natural to you.\n\nstuff = list()\nstuff.append('python')\nstuff.append('chuck')\nstuff.sort()\nprint(stuff[0])\nprint(stuff.__getitem__(0))\nprint(list.__getitem__(stuff,0))\n\nchuck\nchuck\nchuck\n\n\nThe first line constructs an object of type list, the second and third lines call the append() method, the fourth line calls the sort() method, and the fifth line retrieves the item at position 0. The sixth line calls the __getitem__() method in the stuff list with a parameter of zero. The seventh line is an even more verbose way of retrieving the 0th item in the list. In this code, we call the __getitem__ method in the list class and pass the list and the item we want retrieved from the list as parameters.\nWe can take a look at the capabilities of an object by looking at the output of the dir() function:\n\ndir(stuff)\n\n['__add__',\n '__class__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__iadd__',\n '__imul__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__mul__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__reversed__',\n '__rmul__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n 'append',\n 'clear',\n 'copy',\n 'count',\n 'extend',\n 'index',\n 'insert',\n 'pop',\n 'remove',\n 'reverse',\n 'sort']\n\n\nAn object can contain a number of functions (which we call methods) as well as data that is used by those functions. We call data items that are part of the object attributes.\nWe use the class keyword to define the data and code that will make up each of the objects. The class keyword includes the name of the class and begins an indented block of code where we include the attributes (data) and methods (code).\n\nclass PartyAnimal:\n   x = 0\n\n   def party(self) :\n     self.x = self.x + 1\n     print(\"So far\",self.x)\n\nan = PartyAnimal()\nan.party()\nan.party()\nan.party()\n\nSo far 1\nSo far 2\nSo far 3\n\n\nEach method looks like a function, starting with the def keyword and consisting of an indented block of code. This object has one attribute (x) and one method (party). The methods have a special first parameter that we name by convention self.\nJust as the def keyword does not cause function code to be executed, the class keyword does not create an object. We need instruct Python to construct (i.e., create) an object or instance of the class PartyAnimal. It looks like a function call to the class itself. Python constructs the object with the right data and methods and returns the object which is then assigned to the variable an\nan = PartyAnimal()\nWhen the PartyAnimal class is used to construct an object, the variable an is used to point to that object. We use an to access the code and data for that particular instance of the PartyAnimal class.\nEach Partyanimal object/instance contains within it a variable x and a method/function named party. We call the party method in this line:\nan.party()\nWhen the party method is called, the first parameter (which we call by convention self) points to the particular instance of the PartyAnimal object that party is called from. Within the party method, we see the line:\nself.x = self.x + 1\nThis syntax using the dot operator is saying ‘the x within self.’ Each time party() is called, the internal x value is incremented by 1 and the value is printed out.\n\nC.2.1 Object lifecycle\nIn the previous examples, we define a class (template), use that class to create an instance of that class (object), and then use the instance. When the program finishes, all of the variables are discarded. Usually, we don’t think much about the creation and destruction of variables, but often as our objects become more complex, we need to take some action within the object to set things up as the object is constructed and possibly clean things up as the object is discarded.\nIf we want our object to be aware of these moments of construction and destruction, we add specially named methods to our object:\n\nclass PartyAnimal:\n   def __init__(self):\n     self.x = 0\n     print('I am constructed')\n\n   def party(self, y=5): # We can pass parameter like this\n     self.x = self.x + y\n     print('So far',self.x)\n\n   def __del__(self):\n     print('I am destructed', self.x)\n\nan = PartyAnimal()\nan.party()\nan.party(10)\nan.party(10)\nan = 42\nprint('an contains',an)\n\nI am constructed\nSo far 5\nSo far 15\nSo far 25\nI am destructed 25\nan contains 42\n\n\nAs Python constructs our object, it calls our __init__ method to give us a chance to set up some default or initial values for the object. When Python encounters the line:\nan = 42\nIt actually “throws our object away” so it can reuse the an variable to store the value 42. Just at the moment when our an object is being “destroyed” our destructor code (__del__) is called. We cannot stop our variable from being destroyed, but we can do any necessary cleanup right before our object no longer exists."
  },
  {
    "objectID": "05_Data_Structure_sol.html#array",
    "href": "05_Data_Structure_sol.html#array",
    "title": "Appendix C — Data Structure",
    "section": "C.3 Array",
    "text": "C.3 Array\nTo process large amounts of data, we need a data structure such as an array. An array is a sequenced collection of elements, of the same data type. We can refer to the elements in the array as the first element, the second element, and so forth until we get to the last element.\nIf we were to put our 100 scores into an array, we could designate the elements as scores[0], scores[1], and so on. The index indicates the ordinal number of the element, counting from the beginning of the array. The array as a whole has a name, scores, but each score can be accessed individually using its subscript as follows:\n\n\n\n\nC.3.1 Array in Python\nBecause arrays store information in adjoining blocks of memory, they’re considered contiguous data structures. In Python, we can use list or array from numpy library to implement array. See here for more information.\nPython list: - Python lists are very general. They can contain any kind of object and are dynamically typed - However, they do not support mathematical functions such as matrix and dot multiplications. Implementing such functions for Python lists would not be very efficient because of the dynamic typing\nNumPy array: - Extension package to Python for multi-dimensional arrays - Numpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created - Because of the static typing, fast implementation of mathematical functions such as multiplication and addition of numpy arrays can be implemented in a compiled language (C and Fortran is used). Moreover, Numpy arrays are memory efficient\n\nA string can be considered as an array of characters, see here.\n\nThe numpy package (module) is used in almost all numerical computation using Python. It is a package that provides high-performance vector, matrix and higher-dimensional data structures for Python. It is implemented in C and Fortran so when calculations are vectorized (formulated with vectors and matrices) it can provides good performance\n\nYou can easily create 1D array (Vector) using a Python list\n\nR1 = [1,9,2,8]\nR2 = 3\nR3 = []\n\nfor r in R1:\n  R3.append(r*R2)\nR1 = np.array([1,9,2,8])\nR2 = 3\nR3 = R1*R2\n\n\n\n\nSource: https://en.wikipedia.org/wiki/SIMD\n\n\nimport numpy as np\nfrom timeit import default_timer as timer\n\n\n# a vector: the argument to the array function is a Python list\nv = np.array([1,2,3,4])\nv, type(v), v.dtype, v.shape\n\n(array([1, 2, 3, 4]), numpy.ndarray, dtype('int64'), (4,))\n\n\n\nC.3.1.1 Example 1: Try to compare the speed of increment an array of integers containing 0 to 9999 by 1 using python list and numpy array.\n\n\na = list(range(10000))\n\n\nstart = timer()\n# Your code here\nfor i in range(10000):\n  a[i] = a[i]+1\nend = timer()\nprint(\"Total time : %.3f ms\" % (10**3 * (end - start)))\n\nTotal time : 2.783 ms\n\n\n\nb = np.arange(10000) # arguments: start, stop, step\n\n\nstart = timer()\nb = b + 1\nend = timer()\nprint(\"Total time : %.3f ms\" % (10**3 * (end - start)))\n\nTotal time : 0.169 ms\n\n\n\nnp.array_equal(np.array(a) , b)\n\nTrue\n\n\n\n\nC.3.2 Multidimensional arrays\nThe arrays discussed so far are known as one-dimensional arrays because the data is organized linearly in only one direction. Many applications require that data be stored in more than one dimension. One common example is a table, which is an array that consists of rows and columns. The following figure shows a table, which is commonly called a two-dimensional array (Matrix).\nThe array shown below holds the scores of students in a class. There are five students in the class and each student has four different scores for four subjects. The variable scores[2][3] show the score of the second student in the third quiz. Arranging the scores in a two-dimensional array can help us to find the average of scores for each student (the average over the row values) and find the average for each subject (the average over the column values), as well as the average of all subjects (the average of the whole table). Note that multidimensional arrays — arrays with more than two dimensions — are also possible.\n\n\n\n\nIn 2D, the first dimension corresponds to rows, the second to columns.\n\n\n\n\n\nsource: https://scipy-lectures.org/intro/numpy/operations.html\n\n\n# a matrix: the argument to the array function is a nested Python list\nM = np.array([[1, 1], [2, 2]]) # You can use nested list to implement 2D array in Python\nM, type(M), M.dtype, M.shape\n\n(array([[1, 1],\n        [2, 2]]), numpy.ndarray, dtype('int64'), (2, 2))\n\n\nNote the slicing of array works the same way as python list!\n\nM[0,:] # row 0\n\narray([1, 1])\n\n\n\nM[:,0] # column 0\n\narray([1, 2])\n\n\n\nM[1,1] #row1, column1\n\n2\n\n\n\n\nC.3.3 Memory layout\nThe indexes in a one-dimensional array directly define the relative positions of the element in actual memory. A two-dimensional array, however, represents rows and columns. How each element is stored in memory depends on the computer. Most computers use row-major storage, in which an entire row of an array is stored in memory before the next row. However, a computer may store the array using column-major storage, in which the entire column is stored before the next column. The following figure shows a two-dimensional array and how it is stored in memory using row-major or column-major storage. Row-major storage is more common.\n\n\n\nBy default, numpy array are row-major (C_CONTIGUOUS)\n\nM.flags\n\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\nYou can change to column major (F_CONTIGUOUS) but it will be much slower in numpy due to the cache effect (functions in numpy assumes that the array are stored in column major)\n\nM = np.array([[1, 1], [2, 2]], order='F')\nM.flags\n\n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\n\nC.3.3.1 Exercise 1: We have stored the two-dimensional array students in the memory. The array is 100 × 4 (100 rows and 4 columns). Show the address of the element students[5][3] assuming that the element student[0][0] is stored in the memory location with address 0 and each element occupies only one memory location. The computer uses row-major storage.\n\n\nstudent = np.random.randint(0,100,size=(100,4)) #2D array\ns = student.flatten() #1D array\n\nWe can use the following formula to find the location of an element, assuming each element occupies one memory location:\n\\(y = x + Cols \\times i + j\\)\nwhere x defines the start address, Cols defines the number of columns in the array, i defines the row number of the element, j defines the column number of the element, and y is the address we are looking for. In our example, x is 0, Cols is 4, i is 5 and j is 3. We are looking for the value of y:\n\\(y = 0 + 4 \\times i + j = 23\\)\n\nassert student[5][3] == s[23]\n\n\n\nC.3.4 Operations on array\nTraditionally, computer languages require that the size of an array (the number of elements in the array) be defined at the time the program is written and prevent it from being changed during the execution of the program. Recently, some languages have allowed variable-size arrays. Even when the language allows variable-sized arrays, insertion of an element into an array needs careful attention! See here for more information.\n\nBoth list and array can be considered as dynamic array\n\n\nC.3.4.1 Searching for elements\nWe often need to find the index of an element when we know the value. This type of search was discussed in Chapter 8. We can use sequential search for unsorted arrays or binary search on sorted arrays\n\n\nC.3.4.2 Insertion at the end\nIf the insertion is at the end of an array this can be done easily. For example, if an array has 30 elements, we increase the size of the array to 31 and insert the new item as the 31st item.\n\nstudent = list(range(1,31))\nstudent.append(31)\nprint(student)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]\n\n\n\nstudent = np.arange(1,31)\nstudent = np.append(student,31)\nstudent\n\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n\n\n\n\nC.3.4.3 Insertion at the beginning or middle\nIf the insertion is to be at the beginning or in the middle of an array, the process is lengthy and time consuming. For example, if we want to insert an element as the 9th element in an array of 30 elements, elements 9 to 30 should be shifted one element towards the end of the array to open an empty element at position 9 for insertion. The following shows\n\nC.3.4.4 Example 2: Try to insertion an element 31 as the 9th element in an array of 30 elements.\n\nElements 9 to 30 should be shifted one element towards the end of the array to open an empty element at position 9 for insertion. The following shows how to do it:\n\nstudent = np.arange(1,31)\nprint(student)\n\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n 25 26 27 28 29 30]\n\n\n\ni = 30\nstudent = np.append(student,0) # Need to enlarge the space of array first!\nwhile(i&gt;=9):\n  student[i] = student[i-1]\n  i = i-1\nstudent[i] = 31\nprint(student)\n\n[ 1  2  3  4  5  6  7  8 31  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n 24 25 26 27 28 29 30]\n\n\nNote that the shifting needs to take place from the end of the array to prevent losing the values of the elements. The code first copies the value of the 30th element into the 31st element, then copies the value of the 29th element into the 30th element, and so on. When the code comes out of the loop, the 9th element is already copied to the 10th element. The last line copies the value of the new item into the 9th element.\n\n\n\nC.3.5 Delete element\nDeletion of an element in an array is as lengthy and involved as insertion. For example, if the ninth element should be deleted, we need to shift elements 10 to 30 one position towards the start of the array.\n\nC.3.5.1 Exercise 2: Try to delete an the element in the 9th position of an array of 30 elements.\n\n\nstudent = np.arange(1,31)\nprint(student)\n\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n 25 26 27 28 29 30]\n\n\nWe need to shift elements 10 to 30 one position towards the start of the array\n\ni = 9\nwhile(i&lt;30):\n  student[i-1] = student[i]\n  i = i+1\nprint(student)\n\n[ 1  2  3  4  5  6  7  8 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n 26 27 28 29 30 30]\n\n\n\nC.3.5.2 Accessing array\nan array is a random-access structure, which means that each element of an array can be accessed randomly without the need to access the elements before or after it.\n\n\n\nC.3.6 Traversing array\nArray traversal refers to an operation that is applied to all elements of the array, such as reading, writing, applying mathematical operation, and so on. You can use loop like list but vectorization usually works better as we have seen earlier.\n\nAn array is a suitable structure when a small number of insertions and deletions are required, but a lot of searching and retrieval is needed."
  },
  {
    "objectID": "05_Data_Structure_sol.html#records",
    "href": "05_Data_Structure_sol.html#records",
    "title": "Appendix C — Data Structure",
    "section": "C.4 Records",
    "text": "C.4 Records\nA record is a collection of related elements, possibly of different types, having a single name. Each element in a record is called a field. A field differs from a variable primarily in that it is part of a record. The following figure contains two examples of records. The first example, fraction, has two fields, both of which are integers. The second example, student, has three fields made up of three different types.\n\n\n\n\nThe elements in a record can be of the same or different types, but all elements in the record must be related.\n\n\nC.4.1 Records in Python\nUsing dictionaries as a record data type or data object in Python is possible. Dictionaries are easy to create in Python as they have their own syntactic sugar built into the language.\n\nfraction = {\"numerator\":13, \"denominator\":17}\nstudent = {\"id\":2005, \"name\":\"George Boole\", \"grade\":'A'}\n\n\n\nC.4.2 Record name versus field name\nThe name of the record is the name of the whole structure, while the name of each field allows us to refer to that field. For example, in the student record of previous Figure, the name of the record is student, the name of the fields are student[\"id\"], student[\"name\"], and student[\"grade\"].\n\nstudent[\"id\"] = 2006\n\nSome programming languages use a period (.) to separate the name of the structure (record) from the name of its components (fields). You can implement this in Python using the following class.\n\nclass AttrDict(dict):\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.__dict__ = self\n\n\nstudent = AttrDict(student)\n\n\nstudent.id = 2006\n\n\n\nC.4.3 Comparison of records and arrays\nWe can conceptually compare an array with a record. This helps us to understand when we should use an array and when a record. An array defines a combination of elements, while a record defines the identifiable parts of an element. For example, an array can define a class of students (40 students), but a record defines different attributes of a student, such as id, name, or grade.\n\n\nC.4.4 Array of records\nIf we need to define a combination of element and at the same time some attributes of each element, we can use an array of records. For example, in a class of 30 students, we can have an array of 30 records, each record representing a student. The following figure shows an array of 30 student records called students.\n\n\n\n\nstudents = []\nfor i in range(30):\n  s = dict()\n  s[\"id\"] = i+2000\n  s[\"name\"] = \"Bob\"+str(i)\n  s[\"grade\"] = \"A\"\n  students.append(s)\n\n\nstudents\n\n[{'id': 2000, 'name': 'Bob0', 'grade': 'A'},\n {'id': 2001, 'name': 'Bob1', 'grade': 'A'},\n {'id': 2002, 'name': 'Bob2', 'grade': 'A'},\n {'id': 2003, 'name': 'Bob3', 'grade': 'A'},\n {'id': 2004, 'name': 'Bob4', 'grade': 'A'},\n {'id': 2005, 'name': 'Bob5', 'grade': 'A'},\n {'id': 2006, 'name': 'Bob6', 'grade': 'A'},\n {'id': 2007, 'name': 'Bob7', 'grade': 'A'},\n {'id': 2008, 'name': 'Bob8', 'grade': 'A'},\n {'id': 2009, 'name': 'Bob9', 'grade': 'A'},\n {'id': 2010, 'name': 'Bob10', 'grade': 'A'},\n {'id': 2011, 'name': 'Bob11', 'grade': 'A'},\n {'id': 2012, 'name': 'Bob12', 'grade': 'A'},\n {'id': 2013, 'name': 'Bob13', 'grade': 'A'},\n {'id': 2014, 'name': 'Bob14', 'grade': 'A'},\n {'id': 2015, 'name': 'Bob15', 'grade': 'A'},\n {'id': 2016, 'name': 'Bob16', 'grade': 'A'},\n {'id': 2017, 'name': 'Bob17', 'grade': 'A'},\n {'id': 2018, 'name': 'Bob18', 'grade': 'A'},\n {'id': 2019, 'name': 'Bob19', 'grade': 'A'},\n {'id': 2020, 'name': 'Bob20', 'grade': 'A'},\n {'id': 2021, 'name': 'Bob21', 'grade': 'A'},\n {'id': 2022, 'name': 'Bob22', 'grade': 'A'},\n {'id': 2023, 'name': 'Bob23', 'grade': 'A'},\n {'id': 2024, 'name': 'Bob24', 'grade': 'A'},\n {'id': 2025, 'name': 'Bob25', 'grade': 'A'},\n {'id': 2026, 'name': 'Bob26', 'grade': 'A'},\n {'id': 2027, 'name': 'Bob27', 'grade': 'A'},\n {'id': 2028, 'name': 'Bob28', 'grade': 'A'},\n {'id': 2029, 'name': 'Bob29', 'grade': 'A'}]\n\n\nIn an array of records, the name of the array defines the whole structure, the group of students as a whole. To define each element, we need to use the corresponding index. To define the parts (attributes) of each element, we need to use the dot operator. In other words, first we need to define the element, then we can define part of that element. Therefore, the id of the third student is defined as:\n\nstudents[2][\"id\"]\n\n2002\n\n\n\n\nC.4.5 Arrays versus array of records\nBoth an array and an array of record represents a list of items. An array can be thought of as a special case of an array of records in which each element is a record with only a single field!"
  },
  {
    "objectID": "05_Data_Structure_sol.html#linked-lists",
    "href": "05_Data_Structure_sol.html#linked-lists",
    "title": "Appendix C — Data Structure",
    "section": "C.5 Linked Lists",
    "text": "C.5 Linked Lists\nA linked list is a collection of data in which each element contains the location of the next element — that is, each element contains two parts: data and link. The data part holds the value information: the data to be processed. The link is used to chain the data together, and contains a pointer (an address) that identifies the next element in the list. In addition, a pointer variable identifies the first element in the list. The name of the list is the same as the name of the first pointer variable.\nThe following figure shows a linked list called scores that contains four elements. The link in each element, except the last, points to its successor. The link in the last element contains a null pointer, indicating the end of the list. We define an empty linked list to be only a null pointer:\n\n\n\nThe elements in a linked list are traditionally called nodes. A node in a linked list is a record that has at least two fields: one contains the data, and the other contains the address of the next node in the sequence (the link).\nBefore further discussion of linked lists, we need to explain the notation we use in the figures. We show the connection between two nodes using a line. One end of the line has an arrowhead, the other end has a solid circle. The arrowhead represents a copy of the address of the node to which the arrow head is pointed. The solid circle shows where this copy of the address is stored. The figure also shows that we can store a copy of the address in more than one place!\n\n\n\n\nC.5.1 Arrays versus linked lists\nBoth an array and a linked list are representations of a list of items in memory. The only difference is the way in which the items are linked together. In an array of records, the linking tool is the index. The element scores[3] is linked to the element scores[4] because the integer 4 comes after the integer 3. In a linked list, the linking tool is the link that points to the next element — the pointer or the address of the next element.\n\n\n\nThe list is contiguous. The nodes of a linked list can be stored with gaps between them: the link part of the node ‘glues’ the items together. In other words, the computer has the option to store them contiguously or spread the nodes through the whole memory. This has an advantage: insertion and deletion in a linked list is much easier. The only thing that needs to be changed is the pointer to the address of the next element. However, this comes with an overhead: each node of a linked list has an extra field, the address of the next node in memory.\n\n\nC.5.2 Linked-list in Python\nIn Python, there’s a specific object in the collections module that you can use for linked lists called deque (pronounced “deck”), which stands for double-ended queue.\nhttps://realpython.com/linked-lists-python/\n\nfrom collections import deque\ndeque()\n\ndeque([])\n\n\nBut we can create a linked list using custom class in order to help our understanding! First things first, create a class to represent your linked list:\n\nclass LinkedList:\n  def __init__(self):\n    self.head = None\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\nThe only information you need to store for a linked list is where the list starts (the head of the list). Next, create another class to represent each node of the linked list:\n\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.link = None\n  def __repr__(self):\n    return str(self.data)\n\nIn the above class definition, you can see the two main elements of every single node: data and link.\n\nscore = LinkedList()\nfirst_node = Node(66)\nscore.head = first_node\nscore\n\n66 -&gt; None\n\n\n\nsecond_node = Node(72)\nthird_node = Node(96)\nfirst_node.link = second_node\nsecond_node.link = third_node\nscore\n\n66 -&gt; 72 -&gt; 96 -&gt; None\n\n\nBy defining a node’s data and link values, you can create a linked list quite quickly. Here’s a slight change to the linked list’s __init__() that allows you to quickly create linked lists with some data:\n\nclass LinkedList:\n  def __init__(self, nodes=None):\n    self.head = None\n    if nodes:\n      node = Node(data=nodes.pop(0)) #pop will pop out the first entry of the list\n      self.head = node\n      for elem in nodes:\n        node.link = Node(data=elem)\n        node = node.link\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\n\nscore = LinkedList([66,72,96,85,74])\nscore\n\n66 -&gt; 72 -&gt; 96 -&gt; 85 -&gt; 74 -&gt; None\n\n\n\n\nC.5.3 Operations on linked lists\nThe same operations we defined for an array can be applied to a linked list.\n\nC.5.3.1 Searching a linked list\nThe search algorithm for a linked list can only be sequential (see Chapter 8) because the nodes in a linked list have no specific names (unlike the elements in an array) that can be found using a binary search. Since nodes in a linked list have no names, we use two pointers, pre (for previous) and cur (for current).\nAt the beginning of the search, the pre pointer is null and the cur pointer points to the first node. The search algorithm moves the two pointers together towards the end of the list. The following figure shows the movement of these two pointers through the list in an extreme case scenario: when the target value is larger than any value in the list. For example, in the five-node list, assume that our target value is 220, which is larger than any value in the list.\n\n\n\nWhen the search stops, the cur pointer points to the node that stops the search and the pre pointer points to the previous node. If the target is found, the cur pointer points to the node that holds the target value. If the target value is not found, the cur pointer points to the node with a value larger than the target value. In other words, since the list is sorted, and may be very long, we never allow the two pointers to reach the end of the list if we are sure that we have passed the target value. The searching algorithm uses a flag (a variable that can take only true or false values). When the target is found, the flag is set to true: when the target is not found, the flag is set to false. When the flag is true the cur pointer points to the target value: when the flag is false, the cur pointer points to a value larger than the target value.\nThe following shows some different situations. In the first case, the target is 98. This value does not exist in the list and is smaller than any value in the list, so the search algorithm stops while pre is null and cur points to the first node. The value of the flag is false because the value was not found. In the second case, the target is 132, which is the value of the second node. The search algorithm stops while cur is pointing to the second node and pre is pointing to the first node. The value of the flag is true because the target is found. In the third and the fourth cases, the targets are not found so the value of the flag is false.\n\n\n\n\nC.5.3.2 Example 3: The following shows a simplified algorithm for the search. Note how\nwe move the two pointers forward together. This guarantees that the two pointers move together. The search algorithm is used both by the insertion algorithm (if the target is not found) and by the delete algorithm (if the target is found).\n\n\n\n\n\ndef SearchLinkedList(ilist, target):\n  \"\"\"\n    Parameters\n    ----------\n    numbers: ilist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    cur : Node\n        The current pointer\n    pre : Node\n        The pre pointer  \n    flag : bool\n        Whether the taget had been found or not \n  \"\"\"\n  # Your code here\n  pre = None\n  cur = ilist.head\n  while(cur!=None and target &gt; cur.data):\n    pre = cur\n    cur = cur.link\n  if cur!=None and cur.data == target:\n    flag = True\n  else:\n    flag = False\n  return cur, pre, flag\n\n\nscore = LinkedList([102,132,178,201])\nscore\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nSearchLinkedList(score, 98)\n\n(102, None, False)\n\n\n\nSearchLinkedList(score, 132)\n\n(132, 102, True)\n\n\n\nSearchLinkedList(score, 150)\n\n(178, 132, False)\n\n\n\nSearchLinkedList(score, 305)\n\n(None, 201, False)\n\n\n\n\nC.5.3.3 Inserting a node\nBefore insertion into a linked list, we first apply the searching algorithm. If the flag returned from the searching algorithm is false, we will allow insertion, otherwise we abort the insertion algorithm, because we do not allow data with duplicate values. Four cases can arise:\n\nC.5.3.3.1 Insertion into an empty list\nIf the list is empty (ilist = None), the new item is inserted as the first element. One statement can do the job:\n\nilist = LinkedList()\n\n\nilist.head = Node(66)\nilist\n\n66 -&gt; None\n\n\n\n\nC.5.3.3.2 Insertion at the beginning\nIf the searching algorithm returns a flag with value of false and the value of the pre pointer is null, the data needs to be inserted at the beginning of the list. Two statements are needed to do the job:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 95)\ncur, pre, flag\n\n(102, None, False)\n\n\n\nnode = Node(95)\nnode.link = cur \nilist.head = node\nilist\n\n95 -&gt; 102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\nThe first assignment makes the new node become the predecessor of the previous first node. The second statement makes the newly connected node the first node.\n\n\n\n\n\nC.5.3.3.3 Insertion at the end\nIf the searching algorithm returns a flag with value of false and the value of the cur pointer is null, the data needs to be inserted at the end of the list. Two statements are needed to do the job:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 220)\ncur, pre, flag\n\n(None, 201, False)\n\n\n\nnode = Node(220)\npre.link = node\nnode.link = None\nilist\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; 220 -&gt; None\n\n\nThe first assignment connects the new node to the previous last node. The second statement makes the newly connected node become the last node.\n\n\n\n\n\nC.5.3.3.4 Insertion in the middle\nIf the searching algorithm returns a flag with a value of false and none of the returned pointers are null, the new data needs to be inserted at the middle of the list. Two statements are needed to do the job:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 156)\ncur, pre, flag\n\n(178, 132, False)\n\n\n\nnode = Node(156)\nnode.link = cur\npre.link = node\nilist\n\n102 -&gt; 132 -&gt; 156 -&gt; 178 -&gt; 201 -&gt; None\n\n\nThe first assignment connects the new node to its successor. The second statement connects the new node to its predecessor.\n\n\n\n\nC.5.3.4 Exercise 3: The following shows the pseudocode for inserting a new node in a linked list. The first section just adds a node to an empty list.\n\n\n\n\n\ndef InsertLinkedList(ilist, target, new):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    new: Node\n        The node that should be inserted\n    Returns\n    -------\n    ilist : llist\n        The new linked list\n  \"\"\"\n  # Your code here\n  cur, pre, flag = SearchLinkedList(ilist, target)\n  if flag == True:\n    return ilist\n  if ilist.head == None:\n    new.data = target\n    ilist.head = new\n  elif pre == None:\n    new.data = target\n    new.link = cur \n    ilist.head = new\n  elif cur == None:\n    new.data = target\n    pre.link = new\n    new.link = None\n  else:\n    new.data = target\n    new.link = cur\n    pre.link = new\n\n  return ilist\n\n\nilist = LinkedList()\nnew = Node(0)\nilist = InsertLinkedList(ilist, 66, new)\nilist\n\n66 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nnew = Node(0)\nilist = InsertLinkedList(ilist, 95, new)\nilist\n\n95 -&gt; 102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nnew = Node(0)\nilist = InsertLinkedList(ilist, 220, new)\nilist\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; 220 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nnew = Node(0)\nilist = InsertLinkedList(ilist, 156, new)\nilist\n\n102 -&gt; 132 -&gt; 156 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\n\n\nC.5.3.5 Deleting a node\nBefore deleting a node in a linked list, we apply the search algorithm. If the flag returned from the search algorithm is true (the node is found), we can delete the node from the linked list. However, deletion is simpler than insertion: we have only two cases — deleting the first node and deleting any other node. In other words, the deletion of the last and the middle nodes can be done by the same process.\n\nC.5.3.5.1 Deleting the first node\nIf the pre pointer is null, the first node is to be deleted. The cur pointer points to the first node and deleting can be done by one statement:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 102)\ncur, pre, flag\n\n(102, None, True)\n\n\n\nilist.head = cur.link\nilist\n\n132 -&gt; 178 -&gt; 201 -&gt; None\n\n\nThe statement connects the second node to the list pointer, which means that the first node is deleted.\n\n\n\n\n\nC.5.3.5.2 Deleting the middle or the last node\nIf neither of the pointers is null, the node to be deleted is either a middle node or the last node. The cur pointer points to the corresponding node and deleting can be done by one statement:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 132)\ncur, pre, flag\n\n(132, 102, True)\n\n\n\npre.link = cur.link\nilist\n\n102 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 201)\ncur, pre, flag\n\n(201, 178, True)\n\n\n\npre.link = cur.link\nilist\n\n102 -&gt; 132 -&gt; 178 -&gt; None\n\n\nThe statement connects the successor node to the predecessor node, which means that the current node is deleted.\n\n\n\n\nC.5.3.6 Exercise 4: The following algorithm shows the pseudocode for deleting a node. The algorithm is much simpler than the one for inserting. We have only two cases and each case needs only one statement.\n\n\n\n\n\ndef DeleteLinkedList(ilist, target):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    ilist : llist\n        The new linked list\n  \"\"\"\n  # Your code here\n  cur, pre, flag = SearchLinkedList(ilist, target)\n  if flag == False:\n    return ilist\n  elif pre == None:\n    ilist.head = cur.link\n  else:\n    pre.link = cur.link\n  return ilist\n\n\nilist = LinkedList([102,132,178,201])\nDeleteLinkedList(ilist, 95)\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nDeleteLinkedList(ilist, 102)\n\n132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nDeleteLinkedList(ilist, 132)\n\n102 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\n\n\nC.5.3.7 Retrieving a node\nRetrieving means randomly accessing a node for the purpose of inspecting or copying the data contained in the node. Before retrieving, the linked list needs to be searched. If the data item is found, it is retrieved, otherwise the process is aborted. Retrieving uses only the cur pointer, which points to the node found by the search algorithm.\n\nC.5.3.8 Example 4:\n\n\n\n\n\ndef RetrieveLinkedList(ilist, target):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    cur : Node\n        The node to be retrieved\n  \"\"\"\n  # Your code here\n  cur, pre, flag = SearchLinkedList(ilist, target)\n  if flag == False:\n    return False\n  else:\n    return cur\n\n\nilist = LinkedList([102,132,178,201])\nRetrieveLinkedList(ilist, 95), RetrieveLinkedList(ilist, 201)\n\n(False, 201)\n\n\n\n\nC.5.3.9 Traversing a linked list\nTo traverse the list, we need a ‘walking’ pointer, which is a pointer that moves from node to node as each element is processed. We start traversing by setting the walking pointer to the first node in the list. Then, using a loop, we continue until all of the data has been processed. Each iteration of the loop processes the current node, then advances the walking pointer to the next node. When the last node has been processed, the walking pointer becomes null and the loop terminates.\n\nC.5.3.10 Example 5:\n\n\n\n\n\ndef TraverseLinkedList(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    cur : Node\n        The node to be retrieved\n  \"\"\"\n  # Your code here\n  walker = ilist.head\n  while walker != None:\n    print(walker)\n    walker = walker.link\n\n\nilist = LinkedList([102,132,178,201])\nTraverseLinkedList(ilist)\n\n102\n132\n178\n201\n\n\n\n\n\nC.5.4 Applications of linked lists\nA linked list is a very efficient data structure for storing data that will go through many insertions and deletions. A linked list is a dynamic data structure in which the list can start with no nodes and then grow as new nodes are needed. A node can be easily deleted without moving other nodes, as would be the case with an array. For example, a linked list could be used to hold the records of students in a school. Each quarter or semester, new students enroll in the school and some students leave or graduate.\nA linked list can grow infinitely and can shrink to an empty list. The overhead is to hold an extra field for each node. A linked list, however, is not a good candidate for data that must be searched often. This appears to be a dilemma, because each deletion or insertion needs a search. We will see that some abstract data types, discussed in the next chapter, have the advantages of an array for searching and the advantages of a link list for insertion and deletion.\n\nA linked list is a suitable structure if a large number of insertions and deletions are needed, but searching a linked list is slower that searching an array."
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#background",
    "href": "06_Abstract_data_types_sol.html#background",
    "title": "Appendix D — Abstract Data Types",
    "section": "D.1 Background",
    "text": "D.1 Background\nProblem solving with a computer means processing data. To process data, we need to define the data type and the operation to be performed on the data. For example, to find the sum of a list of numbers, we should select the type for the number (integer or real) and define the operation (addition). The definition of the data type and the definition of the operation to be applied to the data is part of the idea behind an abstract data type (ADT)—to hide how the operation is performed on the data.\n\nIn other word, the user of an ADT needs only to know that a set of operations are available for the data type, but does not need to know how they are applied.\n\n\nD.1.1 Simple ADTs\nMany programming languages already define some simple ADTs as integral parts of the language. For example, the Python language defines a simple ADT called an integer. The type of this ADT is integer with predefined ranges. Python also defines several operations that can be applied on this data type (addition, subtraction, multiplication, division, and so on). Python  explicitly defines these operations on integers and what we expect as the results. A  programmer who writes a Python program to add two integers should know about the integer ADT and the operations that can be applied to it.\nThe programmer, however, does not need to know how these operations are actually implemented. For example, the programmer uses the expression z = x + y and expects the value of x (an integer) to be added to the value of y (an integer) and the result to be named z (an integer). The programmer does not need to know how the addition is performed. We learned in previous chapters that the way this addition is done by a computer is to store the two integers in two memory locations in two’s complement format, to load them into the CPU register, to add them in binary, and to store the result back to another memory location. The programmer, however, does not need to know this. An integer in Python is a simple abstract data type with predefined operations. How the operations are performed is not a concern for the programmer.\n\n\nD.1.2 Complex ADTs\nAlthough several simple ADTs, such as integer, float, character and so on, have been implemented and are available for use in most languages, many useful complex ADTs are not. As we will see in this chapter, we need a stack ADT, a queue ADT, and so on. To be efficient, these ADTs should be created and stored in the library of the computer to be used. The user of a stack, for example, should only need to know what operations are available for the stack, not how these operations are performed.\nTherefore, with an ADT, users are not concerned with how the task is done, but rather with what it can do. In other words, the ADT consists of a set of definitions that allow programmers to use the operation while their implementation is hidden. This generalization of operations with unspecified implementations is known as abstraction. We abstract the essence of the process and leave the implementation details hidden.\n\nThe concept of abstraction means: 1. We know what a data type can do. 2. How it is done is hidden.\n\nLet us now define an ADT. An abstract data type is a data type packaged with the operations that are meaningful for the data type. We then encapsulate the data and the operations on the data and hide them from the user.\n\nAbstract Data Type 1. Definition of data 2. Definition of operations 3. Encapsulation of data and operation\n\n\n\nD.1.3 Model for an abstract data type\nThe ADT model is shown in the Figure below. The colored area with an irregular outline represents the ADT. Inside the ADT are two different parts of the model: data structure and operations (public and private). The application program can only access the public operations through the interface. An interface is a list of public operations and data to be passed to or returned from those operations. The private operations are for internal use by the ADT. The data structures, such as arrays and linked lists, are inside the ADT and are used by the public and private operations.\n\n\n\nAlthough the public operations and the interface should be independent of the implementation, the private operations are dependent on the data structures chosen during the implementation of the ADT. We will elaborate on this issue when we discuss some of the ADTs."
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#stacks",
    "href": "06_Abstract_data_types_sol.html#stacks",
    "title": "Appendix D — Abstract Data Types",
    "section": "D.2 Stacks",
    "text": "D.2 Stacks\nA stack is a restricted linear list in which all additions and deletions are made at one end, the top. If we insert a series of data into a stack and then remove it, the order of the data is reversed. Data input as 5, 10, 15, 20, for example, would be removed as 20, 15, 10, and 5. This reversing attribute is why stacks are known as a last in, first out (LIFO) data structure.\nWe use many different types of stacks in our daily lives. We often talk of a stack of coins or a stack of books. Any situation in which we can only add or remove an object at the top is a stack. If we want to remove an object other than the one at the top, we must first remove all objects above it. Figure below shows three representations of stacks.\n\n\n\n\nD.2.1 Operations on stacks\n\nD.2.1.1 The stack operation\nThe stack operation creates an empty stack. Python’s built-in list type makes a decent stack data structure as it supports push and pop operations. Python’s lists are implemented as dynamic arrays internally, which means they occasionally need to resize the storage space for elements stored in them when elements are added or removed. The list over-allocates its backing storage so that not every push or pop requires resizing. For optimum performance, stacks based on Python lists should grow towards higher indexes and shrink towards lower ones.\n\nstack = []\n\n\n\nD.2.1.2 The push operation\nThe push operation inserts an item at the top of the stack. This operation returns the new stack with dataItem inserted at the top. Figure below shows the pictorial representation of this operation.\n\n\n\nIn Python we use append method as the push operation to put it into the stack (higher index).\n\nstack.append(20)\nstack.append(78)\nstack.append(30)\nprint(stack)\n\n[20, 78, 30]\n\n\n\n\nD.2.1.3 The pop operation\nThe pop operation deletes the item at the top of the stack. The following shows the pictorial representation of this operation.\n\n\n\n\nPoped = stack.pop()\nprint(Poped)\n\n30\n\n\nThe deleted item can be used by the application program or can be just discarded. After the pop operation, the item that was under the top element before the deletion becomes the top element.\n\n\nD.2.1.4 The empty operation\nThe empty operation checks the status of the stack.\n\ndef empty(lis):\n  if len(lis) == 0:\n    return True\n  else:\n    return False\n\n\nempty(stack)\n\nFalse\n\n\n\nstack.pop()\nstack.pop()\nempty(stack)\n\nTrue\n\n\n\n\n\nD.2.2 Stack ADT\nWe define a stack as an ADT as shown below:\n\n\n\n\n\nD.2.3 Stack applications\n\nD.2.3.1 Reversing data items\nReversing data items requires that a given set of data items be reordered so that the first and last items are exchanged, with all of the positions between the first and last being relatively exchanged also. For example, the list (2, 4, 7, 1, 6, 8) becomes (8, 6, 1, 7, 4, 2).\n\nD.2.3.2 Example 1: In Chapter 2 we gave a simple UML diagram to convert an integer from decimal to any base. Although the algorithm is very simple, if we print the digits of the converted integer as they are created, we will get the digits in reverse order. The print instruction in any computer language prints characters from left to right, but the algorithm creates the digits from right to left. We can use the reversing characteristic of a stack (LIFO structure) to solve the problem.\n\n\n\n\n\n\n\n\n\n\n\ndef DecimalToBinary(number):\n  \"\"\"\n    Parameters\n    ----------\n    number: int\n        The integer to be converted \n    Returns\n    -------\n    print the binary equivalent\n  \"\"\"\n  if number == 0:\n    print(\"0b0\")\n    return \n  S = []\n  while number != 0:\n    remainder = number % 2\n    S.append(remainder)\n    number = number //2\n  \n  print(\"0b\",end =\"\")\n  while len(S)!=0:\n    x = S.pop()\n    print(x,end =\"\")\n\n\nDecimalToBinary(0)\n\n0b0\n\n\n\nDecimalToBinary(35)\n\n0b100011\n\n\nWe create an empty stack first. Then we use a while loop to create the bits, but instead of printing them, we push them into the stack. When all bits are created, we exit the loop. Now we use another loop to pop the bits from the stack and print them. Note that the bits are printed in the reverse order to that in which they have been created.\n\n\nD.2.3.3 Pairing data items\nWe often need to pair some characters in an expression. For example, when we write a mathematical expression in a computer language, we often need to use parentheses to change the precedence of operators.\n3*((3+2)-5)\nWhen we type an expression with a lot of parentheses, we often forget to pair the parentheses. One of the duties of a compiler is to do the checking for us. The compiler uses a stack to check that all opening parentheses are paired with a closing parentheses.\n\nD.2.3.4 Exercise 1: Algorithm 12.2 shows how we can check if every opening parenthesis is paired with a closing parenthesis.\n\n\n\n\n\n\n\n\ndef CheckingParentheses(expression):\n  \"\"\"\n    Parameters\n    ----------\n    expression: str\n        The expression to be checked\n    Returns\n    -------\n    Error messages if unpaired parentheses are found\n  \"\"\"\n\n  S = []\n  for char in expression:\n    if char == '(':\n      S.append(char)\n    else:\n      if char == ')':\n        if len(S) == 0:\n          print(\"a closing parenthes is not matched\")\n        else:\n          S.pop()\n\n  if len(S)!=0:\n    print(\"unmatched opening parenthesis\")\n\n\nCheckingParentheses(\"3*((3+2)-5)\")\n\n\nCheckingParentheses(\"3*(3+2)-5)\")\n\na closing parenthes is not matched\n\n\n\nCheckingParentheses(\"3*(3+(2-5)\")\n\nunmatched opening parenthesis\n\n\n\n\n\nD.2.4 Stack implementation\nIn this section we describe the general ideas behind the implementation of a stack ADT. At the ADT level, we use the stack and its four operations (stack, push, pop, and empty): at the implementation level, we need to choose a data structure to implement it. Stack ADT can be implemented using either an array or a linked list.\n\n\n\nWe can write four algorithms in pseudocode for the four operations we defined for stack in each implementation. We showed algorithms to handle arrays and linked lists in Chapter 11: these algorithms can be modified to create the four algorithms we need for stacks: stack, push, pop, and empty. These algorithms are even easier than those presented in Chapter 11, because the insertion and deletion is done only at the top of stack. \n\nD.2.4.1 Example 2: The linked list implementation is as above, we have an extra record that has the name of the stack. This record also has two fields: a counter, which at each moment shows the number of data items in the stack. Another field is a pointer that points to the top element.\n\n\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.link = None\n  def __repr__(self):\n    return str(self.data)\n\nclass LinkedList:\n  def __init__(self, nodes=None):\n    self.head = None\n    if nodes:\n      node = Node(data=nodes.pop(0)) #pop will pop out the first entry of the list\n      self.head = node\n      for elem in nodes:\n        node.link = Node(data=elem)\n        node = node.link\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\n\nL = LinkedList(0)\n\n\n# Create an empty stack\ndef stack():\n  S={\"count\":0, \"top\":None}\n  return S\n\ndef push(S,L,x):\n  new = Node(x)\n  if S[\"top\"] == None:\n    L.head = new\n    S[\"top\"] = L.head\n  else:\n    new.link = L.head\n    L.head = new\n    S[\"top\"] = L.head\n  S[\"count\"] = S[\"count\"]+1\n\n\ndef pop(S,L):\n  if S[\"count\"] ==0:\n    return None\n  x = L.head\n  L.head = L.head.link\n  S[\"top\"] = L.head\n  S[\"count\"] = S[\"count\"]-1  \n  return x\n\ndef empty(S):\n  if S[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nS = stack()\npush(S,L,20)\nprint(S,L)\npush(S,L,78)\nprint(S,L)\npush(S,L,30)\nprint(S,L)\n\n{'count': 1, 'top': 20} 20 -&gt; None\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n{'count': 3, 'top': 30} 30 -&gt; 78 -&gt; 20 -&gt; None\n\n\n\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\n\n30\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n78\n{'count': 1, 'top': 20} 20 -&gt; None\n20\n{'count': 0, 'top': None} None\n\n\n\npush(S,L,20)\nprint(S,L)\npush(S,L,78)\nprint(S,L)\npush(S,L,30)\nprint(S,L)\n\n{'count': 1, 'top': 20} 20 -&gt; None\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n{'count': 3, 'top': 30} 30 -&gt; 78 -&gt; 20 -&gt; None\n\n\n\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\n\n30\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n78\n{'count': 1, 'top': 20} 20 -&gt; None\n20\n{'count': 0, 'top': None} None\n\n\n\nD.2.4.2 Example 3: In the array implementation, we have a record that has two fields. The first field can be used to store information about the array: we have used it as the count field, which at each moment shows the number of data items in the stack. The second field is an integer that holds the index of the top element. Note that the array is shown upside down to match the linked list implementation.\n\n\nimport numpy as np\nn = 10 # number of elements allocated to the array\nA = np.zeros(n, dtype=np.int8)\n\n\n# Create an empty stack\ndef stack():\n  S={\"count\":0, \"top\":-1}\n  return S\n\ndef push(S,A,x):\n  S[\"top\"] = S[\"top\"]+1\n  S[\"count\"] = S[\"count\"]+1\n  A[S[\"top\"]] = x\n\ndef pop(S,A):\n  if S[\"count\"] ==0:\n    return None\n  x = A[S[\"top\"]]\n  A[S[\"top\"]] = 0\n  S[\"top\"] = S[\"top\"]-1\n  S[\"count\"] = S[\"count\"]-1  \n  return x\n\ndef empty(S):\n  if S[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nS = stack()\npush(S,A,20)\nprint(S,A)\npush(S,A,78)\nprint(S,A)\npush(S,A,30)\nprint(S,A)\n\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n{'count': 3, 'top': 2} [20 78 30  0  0  0  0  0  0  0]\n\n\n\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\n\n30\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n78\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n20\n{'count': 0, 'top': -1} [0 0 0 0 0 0 0 0 0 0]\n\n\n\npush(S,A,20)\nprint(S,A)\npush(S,A,78)\nprint(S,A)\npush(S,A,30)\nprint(S,A)\n\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n{'count': 3, 'top': 2} [20 78 30  0  0  0  0  0  0  0]\n\n\n\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\n\n30\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n78\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n20\n{'count': 0, 'top': -1} [0 0 0 0 0 0 0 0 0 0]"
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#queues",
    "href": "06_Abstract_data_types_sol.html#queues",
    "title": "Appendix D — Abstract Data Types",
    "section": "D.3 Queues",
    "text": "D.3 Queues\nA queue is a linear list in which data can only be inserted at one end, called the rear, and deleted from the other end, called the front. These restrictions ensure that the data are processed through the queue in the order in which it is received. In other words, a queue is a first in, first out (FIFO) structure.\nQueues are familiar from everyday life. A line of people waiting for the bus at a bus station is a queue, a list of calls put on hold to be answered by a telephone operator is a queue, and a list of waiting jobs to be processed by a computer is a queue.\nFigure 12.8 shows two representations of queues, one a queue of people and the other a computer queue. Both people and data enter the queue at the rear and progress through the queue until they arrive at the front. Once they are at the front of the queue, they leave the queue and are served.\n\n\n\n\nD.3.1 Operations on queues\n\nD.3.1.1 The queue operation\nThe queue operation creates an empty queue. A queue is a collection of objects that supports fast FIFO semantics for inserts and deletes. The insert and delete operations are sometimes called enqueue and dequeue. Unlike lists or arrays, queues typically don’t allow for random access to the objects they contain. It’s possible to use a regular list as a queue, but this is not ideal from a performance perspective. Lists are quite slow for this purpose because inserting or deleting an element at the beginning requires shifting all the other elements by one!\nThe collections.deque implementation is a great default choice if you’re looking for a queue data structure in Python’s standard library.\n\nfrom collections import deque\n\nqueue = deque()\n\n\n\nD.3.1.2 The enqueue operation\nThe enqueue operation inserts an item at the rear of the queue. After the enqueue operation, the new item becomes the last item in the queue. This operation returns the new queue with new data inserted at the rear. Figure below shows the pictorial representation of this operation.\n\n\n\nIn Python, you can use the append operation for enqueue.\n\nqueue.append(20)\nqueue.append(78)\nqueue.append(30)\nqueue\n\ndeque([20, 78, 30])\n\n\n\n\nD.3.1.3 The dequeue operation\nThe dequeue operation deletes the item at the front of the queue. The deleted item can be used by the application program or can be just discarded. After the dequeue operation, the item that followed the front element becomes the front element. This operation returns the new queue with one less element. Figure below shows the pictorial representation of this operation.\n\n\n\n\nfront = queue.popleft()\nfront\n\n20\n\n\nIn python, you can use the popleft operation for dequeue.\n\n\nD.3.1.4 The empty operation\nThe empty operation checks the status of the queue.\n\ndef empty(q):\n  if len(q) == 0:\n    return True\n  else:\n    return False\n\n\nempty(queue)\n\nFalse\n\n\n\nqueue.popleft()\nqueue.popleft()\nempty(queue)\n\nTrue\n\n\n\n\n\nD.3.2 Queue ADT\nWe define a stack as an ADT as shown below:\n\n\n\n\n\nD.3.3 Queue applications\nQueues are one of the most common of all data processing structures. They are found in virtually every operating system and network and in countless other areas. For example, queues are used in online business applications such as processing customer requests, jobs, and orders. In a computer system, a queue is needed to process jobs and for system services such as print spools.\n\nD.3.3.1 Example 4: Queues can be used to organize databases by some characteristic of the data. For example, imagine we have a list of sorted data stored in the computer belonging to two categories: less than 1000, and greater than 1000. We can use two queues to separate the categories and at the same time maintain the order of data in their own category. Algorithm 12.3 shows the pseudocode for this operation.\n\n\n\n\n\n\n\n\ndef Categorizer(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist1: list\n        Input sorted list\n    Returns\n    -------\n    Categorize data into two categories and create two separate queues and print them out\n  \"\"\"\n\n  Q1 = deque()\n  Q2 = deque()\n  for data in ilist:\n    if data &lt; 1000:\n      Q1.append(data)\n    if data &gt;=1000:\n      Q2.append(data)\n  \n  print(\"Q1:\")\n  while len(Q1)!=0:\n    x = Q1.popleft()\n    print(x, end=' ')\n\n  print(\"\\nQ2:\")\n  while len(Q2)!=0:\n    x = Q2.popleft()\n    print(x, end=' ')\n\n\nCategorizer([150, 350, 500, 700, 1000, 1200, 1550])\n\nQ1:\n150 350 500 700 \nQ2:\n1000 1200 1550 \n\n\n\nCategorizer([50, 250, 900, 999, 1001, 1900, 2550])\n\nQ1:\n50 250 900 999 \nQ2:\n1001 1900 2550 \n\n\nAnother common application of a queue is to adjust and create a balance between a fast producer of data and a slow consumer of data. For example, assume that a CPU is connected to a printer. The speed of a printer is not comparable with the speed of a CPU. If the CPU waits for the printer to print some data created by the CPU, the CPU would be idle for a long time. The solution is a queue. The CPU creates as many chunks of data as the queue can hold and sends them to the queue. The CPU is now free to do other jobs. The chunks are dequeued slowly and printed by the printer. The queue used for this purpose is normally referred to as a spool queue.\n\n\nD.3.4 Queue implementation\nAt the ADT level, we use the queue and its four operations (queue, enqueue, dequeue, and empty): at the implementation level, we need to choose a data structure to implement it. A queue ADT can be implemented using either an array or a linked list.\n\n\n\nWe can write four algorithms in pseudocode for the four operations we defined for queues in each implementation. We described algorithms to handle arrays and linked lists in Chapter 11: we can modify those algorithms to create the four algorithms we need for queues: queue, enqueue, dequeue, and empty. These algorithms are easier than those presented in Chapter 11, because insertion is done only at the end of the queue and deletion is done only at the front of the queue.\n\nD.3.4.1 Exercise 2: In the array implementation we have a record with three fields. The first field can be used to store information about the queue: we have used this as a count field that shows the current number of data items in the queue. The second field is an integer that holds the index of the front element. The third field is also an integer, which holds the index of the rear element.\n\n\nimport numpy as np\nn = 10 # number of elements allocated to the array\nA = np.zeros(n, dtype=np.int8)\n\n\n# Create an empty queue\ndef queue():\n  Q={\"count\":0, \"rear\":-1, \"front\":-1}\n  return Q\n\ndef enqueue(Q,A,x):\n  if Q[\"front\"]==-1:\n    Q[\"front\"] = 0\n  Q[\"rear\"] = Q[\"rear\"]+1\n  Q[\"count\"] = Q[\"count\"]+1\n  A[Q[\"rear\"]] = x\n\ndef dequeue(Q,A):\n  if Q[\"count\"] ==0:\n    return None\n  x = A[Q[\"front\"]]\n  A[Q[\"front\"]] = 0\n  Q[\"front\"] = Q[\"front\"]+1\n  Q[\"count\"] = Q[\"count\"]-1  \n  return x\n\ndef empty(S):\n  if Q[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nQ = queue()\nenqueue(Q,A,20)\nprint(Q,A)\nenqueue(Q,A,78)\nprint(Q,A)\nenqueue(Q,A,30)\nprint(Q,A)\n\n{'count': 1, 'rear': 0, 'front': 0} [20  0  0  0  0  0  0  0  0  0]\n{'count': 2, 'rear': 1, 'front': 0} [20 78  0  0  0  0  0  0  0  0]\n{'count': 3, 'rear': 2, 'front': 0} [20 78 30  0  0  0  0  0  0  0]\n\n\n\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\n\n20\n{'count': 2, 'rear': 2, 'front': 1} [ 0 78 30  0  0  0  0  0  0  0]\n78\n{'count': 1, 'rear': 2, 'front': 2} [ 0  0 30  0  0  0  0  0  0  0]\n30\n{'count': 0, 'rear': 2, 'front': 3} [0 0 0 0 0 0 0 0 0 0]\n\n\n\nenqueue(Q,A,20)\nprint(Q,A)\nenqueue(Q,A,78)\nprint(Q,A)\nenqueue(Q,A,30)\nprint(Q,A)\n\n{'count': 1, 'rear': 3, 'front': 3} [ 0  0  0 20  0  0  0  0  0  0]\n{'count': 2, 'rear': 4, 'front': 3} [ 0  0  0 20 78  0  0  0  0  0]\n{'count': 3, 'rear': 5, 'front': 3} [ 0  0  0 20 78 30  0  0  0  0]\n\n\n\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\n\n20\n{'count': 2, 'rear': 5, 'front': 4} [ 0  0  0  0 78 30  0  0  0  0]\n78\n{'count': 1, 'rear': 5, 'front': 5} [ 0  0  0  0  0 30  0  0  0  0]\n30\n{'count': 0, 'rear': 5, 'front': 6} [0 0 0 0 0 0 0 0 0 0]\n\n\n\nD.3.4.2 Exercise 3: The linked list implementation is similar: we have an extra record that has the name of the queue. This node also has three fields: a count, a pointer that points to the front element, and a pointer that points to the rear element.\n\n\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.link = None\n  def __repr__(self):\n    return str(self.data)\n\nclass LinkedList:\n  def __init__(self, nodes=None):\n    self.head = None\n    if nodes:\n      node = Node(data=nodes.pop(0)) #pop will pop out the first entry of the list\n      self.head = node\n      for elem in nodes:\n        node.link = Node(data=elem)\n        node = node.link\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\n\nL = LinkedList(0)\n\n\n# Create an empty queue\ndef queue():\n  Q={\"count\":0, \"front\":None, \"rear\":None}\n  return Q\n\ndef enqueue(Q,L,x):\n  new = Node(x)\n  if Q[\"count\"] == 0:\n    L.head = new\n    Q[\"front\"] = L.head\n    Q[\"rear\"] = L.head\n  else:\n    Q[\"rear\"].link = new\n    Q[\"rear\"] = Q[\"rear\"].link\n  Q[\"count\"] = Q[\"count\"]+1\n\n\ndef dequeue(Q,L):\n  if Q[\"count\"] ==0:\n    return None\n  x = Q[\"front\"]\n  if Q[\"count\"] ==1:\n    Q[\"front\"] = None\n    Q[\"rear\"] = None\n  else:\n    Q[\"front\"] = Q[\"front\"].link\n  L.head = Q[\"front\"]\n  Q[\"count\"] = Q[\"count\"] - 1\n  return x\n\ndef empty(Q):\n  if Q[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nQ = queue()\nenqueue(Q,L,20)\nprint(Q,L)\nenqueue(Q,L,78)\nprint(Q,L)\nenqueue(Q,L,30)\nprint(Q,L)\n\n{'count': 1, 'front': 20, 'rear': 20} 20 -&gt; None\n{'count': 2, 'front': 20, 'rear': 78} 20 -&gt; 78 -&gt; None\n{'count': 3, 'front': 20, 'rear': 30} 20 -&gt; 78 -&gt; 30 -&gt; None\n\n\n\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\n\n20\n{'count': 2, 'front': 78, 'rear': 30} 78 -&gt; 30 -&gt; None\n78\n{'count': 1, 'front': 30, 'rear': 30} 30 -&gt; None\n30\n{'count': 0, 'front': None, 'rear': None} None\n\n\n\nenqueue(Q,L,20)\nprint(Q,L)\nenqueue(Q,L,78)\nprint(Q,L)\nenqueue(Q,L,30)\nprint(Q,L)\n\n{'count': 1, 'front': 20, 'rear': 20} 20 -&gt; None\n{'count': 2, 'front': 20, 'rear': 78} 20 -&gt; 78 -&gt; None\n{'count': 3, 'front': 20, 'rear': 30} 20 -&gt; 78 -&gt; 30 -&gt; None\n\n\n\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\n\n20\n{'count': 2, 'front': 78, 'rear': 30} 78 -&gt; 30 -&gt; None\n78\n{'count': 1, 'front': 30, 'rear': 30} 30 -&gt; None\n30\n{'count': 0, 'front': None, 'rear': None} None"
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#general-linear-lists",
    "href": "06_Abstract_data_types_sol.html#general-linear-lists",
    "title": "Appendix D — Abstract Data Types",
    "section": "D.4 General linear lists",
    "text": "D.4 General linear lists\nThis topic is beyond our scope."
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#trees",
    "href": "06_Abstract_data_types_sol.html#trees",
    "title": "Appendix D — Abstract Data Types",
    "section": "D.5 Trees",
    "text": "D.5 Trees\nA tree consists of a finite set of elements, called nodes (or vertices), and a finite set of directed lines, called arcs, that connect pairs of the nodes. If the tree is not empty, one of the nodes, called the root, has no incoming arcs. The other nodes in a tree can be reached from the root by following a unique path, which is a sequence of consecutive arcs. Tree structures are normally drawn upside down with the root at the top as shown below:\n\n\n\nWe can divide the vertices in a tree into three categories: the root, leaves, and the internal nodes. The following showsthe number of outgoing and incoming arcs allowed for each type of node.\n\n\n\n\nType of node\nIncoming arc\nOutgoing arc\n\n\n\n\nroot\n0\n0 or more\n\n\nleaf\n1\n0\n\n\ninternal\n1\n1 or more\n\n\n\n\nA node that is directly accessible (through a single arc) from a given node is called the child: the node from which the child is directly accessible is called a parent. Nodes with a common parent are called siblings. Descendents of a node are all nodes that can be reached by that node, and a node from which all descendents can be reached is called an ancestor. Each node in a tree may have a subtree.\nThe subtree of each node includes one of its children and all descendents of that child. Figure below shows all subtrees for the tree in Figure above\n\n\n\nAlthough trees have many applications in computer science, such as index files, their study is beyond the scope of this book. We introduce trees as a prelude to discussing one special type of tree, binary trees.\n\nD.5.1 Binary trees\nA binary tree is a tree in which no node can have more than two subtrees. In other words, a node can have zero, one, or two subtrees. These subtrees are designated as the left subtree and the right subtree. Figure below shows a binary tree with its two subtrees. Note that each subtree is itself a binary tree.\n\n\n\n\nD.5.1.1 Recursive definition of binary trees\nIn Chapter 8 we introduced the recursive definition of an algorithm. We can also define a structure or an ADT recursively. The following gives the recursive definition of a binary tree. Note that, based on this definition, a binary tree can have a root, but each subtree can also have a root.\n\nA binary tree is either empty or consists of a node, root, with two subtrees, in which each subtree is also a binary tree.\n\nFigure below shows eight trees, the first of which is an empty binary tree (sometimes called a null binary tree).\n\n\n\n\n\n\nD.5.2 Operations on binary trees\nThe six most common operations defined for a binary tree are tree (creates an empty tree) insert, delete, retrieve, empty and traversal. The first five are complex and beyond the scope of this book. We discuss binary tree traversal in this section.\n\nD.5.2.1 Binary tree traversals\nA binary tree traversal requires that each node of the tree be processed once and only once in a predetermined sequence. The two general approaches to the traversal sequence are depth-first and breadth-first traversal.\n\nD.5.2.1.1 Depth-first traversals\nGiven that a binary tree consists of a root, a left subtree, and a right subtree, we can define six different depth-first traversal sequences. Computer scientists have assigned standard names to three of these sequences in the literature: the other three are unnamed but are easily derived. The standard traversals are shown in Figure below.\n\n\n\n\nPreorder traversal. In preorder traversal the root node is processed first, followed by the left subtree and then the right subtree. The prefix pre indicates that the root node is processed before the subtrees.\nInorder traversal. In inorder traversal the left subtree is processed first, then the root node, and finally the right subtree. The prefix in indicates that the root node is processed between the subtrees.\nPostorder traversal. In postorder traversal the root node is processed after the left and right subtrees have been processed. The prefix post indicates that the root is processed after the subtrees.\n\n\nD.5.2.2 Example 5: Figure below shows how we visit each node in a tree using preorder traversal. The figure also shows the walking order. In preorder traversal we visit a node when we pass from its left side. The nodes are visited in this order: A, B, C, D, E, F.\n\n\n\n\n\n\nD.5.2.2.1 Breadth-first traversals\nIn breadth-first traversal of a binary tree we process all the children of a node before proceeding with the next generation. As with depth-first traversals, we can trace the traversal with a walk.\n\nD.5.2.3 Example 6: Figure below shows how we visit each node in a tree using breadth-first traversal. The figure also shows the walking order. The traversal order is A, B, E, C, D, F.\n\n\n\n\n\n\n\nD.5.2.4 Binary tree applications\n\nD.5.2.4.1 Expression trees\nAn arithmetic expression can be represented in three different formats: infix, postfix, and prefix. In an infix notation, the operator comes between the two operands. In postfix notation, the operator comes after its two operands, and in prefix notation it comes before the two operands. These formats are shown below for the addition of two operands A and B.\n\nPrefix: + A B\nInfix: A + B\nPostfix: A B +\n\nAlthough we use infix notation in our algorithms and in programming languages, the compiler often changes them to postfix notation before evaluating them. One way to do this conversion is to create an expression tree. In an expression tree, the root and the internal nodes are operators and the leaves are the operands. The three standard traversals (preorder, inorder, and postorder) then represent the three different expression formats: infix , postfix , and prefix. The inorder traversal produces the infix expression, the postorder traversal produces the postfix expression, and the preorder traversal produces the prefix expression. Figure below shows an expression and its expression tree. Note that only the infix notation needs parentheses.\n\n\n\n\n\n\n\nD.5.3 Binary search trees\nA binary search tree (BST) is a binary tree with one extra property: the key value of each node is greater than the key values of all nodes in each left subtree and smaller than the value of all nodes in each right subtree. Figure below shows the idea.\n\n\n\n\nD.5.3.1 Example 7: Figure below shows some binary trees that are BSTs and some that are not. Note that a tree is a BST if all its subtrees are BSTs and the whole tree is also a BST.\n\n\n\n\n\nD.5.3.1.1 BST implementation\nBSTs can be implemented using either arrays or linked lists. However, linked list structures are more common and more efficient. A linear implementation uses nodes with two pointers, left and right. The left pointer points to the left subtree and the right pointer points to the right subtree. If the left subtree is empty, the left pointer is null: if the right subtree is empty, the right pointer is null. Figure below shows a BST in which the data field of each node is a record.\n\n\n\n\nclass tree:\n  def __init__(self):\n    self.data=0\n    self.left=None\n    self.right=None\n  def __repr__(self):\n    lines, *_ = self._display_aux()\n    return \"\\n\".join(lines)\n  def _display_aux(self):\n    # https://stackoverflow.com/questions/34012886/print-binary-tree-level-by-level-in-python\n    \"\"\"Returns list of strings, width, height, and horizontal coordinate of the root.\"\"\"\n    # No child.\n    if self.right is None and self.left is None:\n      line = '%s' % self.data\n      width = len(line)\n      height = 1\n      middle = width // 2\n      return [line], width, height, middle\n\n    # Only left child.\n    if self.right is None:\n      lines, n, p, x = self.left._display_aux()\n      s = '%s' % self.data\n      u = len(s)\n      first_line = (x + 1) * ' ' + (n - x - 1) * '_' + s\n      second_line = x * ' ' + '/' + (n - x - 1 + u) * ' '\n      shifted_lines = [line + u * ' ' for line in lines]\n      return [first_line, second_line] + shifted_lines, n + u, p + 2, n + u // 2\n\n    # Only right child.\n    if self.left is None:\n      lines, n, p, x = self.right._display_aux()\n      s = '%s' % self.data\n      u = len(s)\n      first_line = s + x * '_' + (n - x) * ' '\n      second_line = (u + x) * ' ' + '\\\\' + (n - x - 1) * ' '\n      shifted_lines = [u * ' ' + line for line in lines]\n      return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2\n\n    # Two children.\n    left, n, p, x = self.left._display_aux()\n    right, m, q, y = self.right._display_aux()\n    s = '%s' % self.data\n    u = len(s)\n    first_line = (x + 1) * ' ' + (n - x - 1) * '_' + s + y * '_' + (m - y) * ' '\n    second_line = x * ' ' + '/' + (n - x - 1 + u + y) * ' ' + '\\\\' + (m - y - 1) * ' '\n    if p &lt; q:\n      left += [n * ' '] * (q - p)\n    elif q &lt; p:\n      right += [m * ' '] * (p - q)\n    zipped_lines = zip(left, right)\n    lines = [first_line, second_line] + [a + u * ' ' + b for a, b in zipped_lines]\n    return lines, n + m + u, max(p, q) + 2, n + u // 2    \n\ndef create_tree(root,val):  # create a binary tree\n  newnode=tree()\n  newnode.data=val\n  newnode.left=None\n  newnode.right=None\n  if root==None:\n    root=newnode\n    return root\n  else:\n    current=root\n    while current!=None:\n      backup=current\n      if current.data &gt; val:\n        current=current.left\n      else:\n        current=current.right\n    if backup.data &gt;val:\n      backup.left=newnode\n    else:\n      backup.right=newnode\n  return root\n\n\ndef inorder(ptr):   # Inorder\n  if ptr!=None:\n    inorder(ptr.left)\n    print(ptr.data, end=' ')\n    inorder(ptr.right)\n\n\ndata=[17,6,3,14,19]\nptr=None\nroot=None\nfor i in range(len(data)):\n  ptr=create_tree(ptr,data[i])\n\n\nptr\n\n  __17_ \n /     \\\n 6_   19\n/  \\    \n3 14    \n\n\nA very interesting property of a BST is that if we apply the inorder traversal of a binary tree, the elements that are visited are sorted in ascending order. For example, the three BSTs in Figure above, when traversed in the order gives the list (3, 6, 17), (17, 19), and (3, 6, 14, 17, 19).\n\nAn inorder traversal of a BST creates a list that is sorted in ascending order.\n\n\nD.5.3.2 Example 8: The code below is the inorder traversal of a binary search tree.\n\n\nprint('=======================================================')\nprint('Inorder：')\ninorder(ptr) \nprint()\n\n=======================================================\nInorder：\n3 6 14 17 19 \n\n\n\nD.5.3.3 Exercise 4: Try to write the postorder and preorder traversal of the above tree.\n\n\ndef postorder(ptr):  # Postorder\n  if ptr!=None:\n    postorder(ptr.left)\n    postorder(ptr.right)\n    print(ptr.data, end=' ')\n\ndef preorder(ptr):   # Preorder\n  if ptr!=None:\n    print(ptr.data, end= ' ')\n    preorder(ptr.left)\n    preorder(ptr.right)\n\n\nprint('=======================================================')\nprint('Postorder：')\npostorder(ptr)\nprint()\nprint('=======================================================')\nprint('Preorder：')\npreorder(ptr)\nprint() \n\n=======================================================\nPostorder：\n3 14 6 19 17 \n=======================================================\nPreorder：\n17 6 3 14 19 \n\n\n\n\nD.5.3.3.1 Binary search tree ADTs\nhttps://visualgo.net/en/bst\nThe ADT for a binary search tree is similar to the one we defined for a general linear list with the same operation. As a matter of fact, we see more BST lists than general linear lists today. The reason is that searching a BST is more efficient that searching a linear list: a general linear list uses sequential searching, but BSTs use a version of binary search.\nAnother feature that makes a BST interesting is that we can use a version of the binary search we used in Chapter 8 for a binary search tree. Figure below shows the UML for a BST search.\n\n\n\n\nD.5.3.4 Exercise 5: Search the above tree.\n\n\ndef search(ptr,val):    \n  i=1\n  while True:\n    if ptr==None:    \n      return \"Not Found\"\n    if ptr.data==val:      \n      print('Total search number %d'%i)\n      return \"Found\"\n    elif ptr.data &gt; val: \n      ptr=ptr.left\n    else:\n      ptr=ptr.right\n    i+=1\n\n\nsearch(ptr, 20)\n\n'Not Found'\n\n\n\nsearch(ptr, 14)\n\nTotal search number 3\n\n\n'Found'"
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#graphs",
    "href": "06_Abstract_data_types_sol.html#graphs",
    "title": "Appendix D — Abstract Data Types",
    "section": "D.6 Graphs",
    "text": "D.6 Graphs\nA graph is an ADT made of a set of nodes, called vertices, and set of lines connecting the vertices, called edges or arcs. Whereas a tree defines a hierarchical structure in which a node can have only one single parent, each node in a graph can have one or more parents. Graphs may be either directed or undirected. In a directed graph, or digraph, each edge, which connects two vertices, has a direction (shown in the figure by an arrowhead) from one vertex to the other. In an undirected graph, there is no direction. Figure below shows an example of both a directed graph (a) and an undirected graph (b).\n\n\n\nThe vertices in a graph can represent objects or concepts and the edges or arcs can represent a relationship between those objects or concepts. If a graph is directed, the relations are one-way: if a graph is undirected, the relation is two-way.\nFor instance, a map of cities and the roads connecting the cities can be represented in a computer using an undirected graph. The cities are vertices and the undirected edges are the roads that connect them. If we want to show the distances between the cities, we can use weighted graphs, in which each edge has a weight that represent the distance between two cities connected by that edge. Another application of graphs is in computer networks (Chapter 6). The vertices can represent the nodes or hubs; the edges can represent the route. Each edge can have a weight that defines the cost of reaching from one hub to the adjacent hub. A router can use graph algorithms to find the shortest path between itself and the final destination of a packet."
  }
]