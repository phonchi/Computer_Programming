[
  {
    "objectID": "index.html#book",
    "href": "index.html#book",
    "title": "Computer Programming",
    "section": "0.1 Book",
    "text": "0.1 Book\nThis is the companion book for the course computer programming open in the Department of Applied Mathematics, National Sun Yat-sen University. It aims for students who need a basic understanding of procedural programming and object-oriented programming concepts using Python 3. We will have hands-on exercises and quizzes to help you get familiar with each topic, and students will exercise logical thinking and programming skills for dealing with scientific problems.\nThe book is based on several well-known books and resources, including:\n\nAutomate the Boring Stuff with Python, 2nd Edition\nBeyond the Basic Stuff with Python\nScipy Lecture Notes"
  },
  {
    "objectID": "01_Python.html#introduction",
    "href": "01_Python.html#introduction",
    "title": "2  Python Basics",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nA programming language is a computer system created to allow humans to precisely express algorithms to the computer using a higher level of abstraction. Python is one of the top ten most-used languages, and remains popular in developing web applications, in scientific computation, and as an introductory language for students. Organizations that use Python range from Google to NASA, DropBox to Industrial Light & Magic, and across the spectrum of casual, scientific, and artistic computer users.\nPython emphasizes readability, and includes elements of the imperative, object-oriented, and functional programming paradigms, which will be explored later on. Python is an interpreted language, which for beginners means that Python instructions can be typed into an interactive prompt, or can be stored in a plain text file (called a “script”) and run later. These instructions are evaluated and the commands are executed by the Python interpreter in something called the shell.\n\n2.1.1 Hello, Python\nA command, often called a statement, instructs the interpreter to do something. The first program described in many programming Language introductions is “Hello, World”. This simple program outputs a nominal greeting, demonstrating how a particular language produces a result, and also how a language represents text.\n\n\nCode\nprint('Hello, World!')\n\n\nHello, World!\n\n\nThere are several aspects to note even in this simple Python statement. * First, print() is a built-in function, a pre-defined operation that Python can use to produce output, a result of the program that will be made visible to the user. The print is followed by opening and closing parentheses; what comes between those parentheses is the value or arguments to be printed.\n\nSecond, fixed values such as numbers, letters, and strings, are called constants or simple data type because their value does not change. String constants use single quotes ' or double quotes \" in Python. The quotation marks in front of the capital 'H' and after the exclamation point denotes the beginning and end of a string of characters that will be treated as a value in Python.\n\nProgramming languages carry out their instructions very precisely. If a user makes subtle changes to the message between the starting and finishing quotation marks within the print statement, the resultant printed text will change accordingly. Notice that it is possible for statements to span more than one line using \\ .\n\n\nCode\nprint('Hello,\\\n World')\n\n\nHello, World\n\n\n\nIn Jupyter Notebook, the print function can even be omitted if the statement you want to print is the last statement in the code.\n\n\n\nCode\n'hi python'\n'Hello, World!'\n\n\n'Hello, World!'\n\n\n\n2.1.1.1 Using string methods like a word processor\nOne of the simplest tasks you can do with strings is to change the case of the words in a string.\n\n\nCode\nprint('hi python'.title())\n\n\n'Hi Python'\n\n\nIn this example, we have the lowercase string ‘hi python’. The method title() appears after the string in the print() call. A method is an action that Python can perform on a piece of data. The dot (.) after the string tells Python to make the title() method act on the string. Every method is followed by a set of parentheses that can accept arguments just like a function.\nThere are also other useful methods for string\n\n\nCode\nprint('hi python'.upper())   # change a string to all uppercase \nprint('Hello World'.lower()) # change a string to all lowercase \nprint(' hi python '.strip()) # remove extra whitespace on the right and left sides of a string\n\n\nHI PYTHON\nhello world\nhi python\n\n\nThese example statements introduce another language feature. The # symbol denotes the beginning of a comment, a human-readable notation to the Python code that will be ignored by the computer when executed. A high-level description at the top of a script introduces a human reader to the overall purpose and methodology used in the script. All of the characters to the right of the # until the end of the line are ignored by Python.\n\n2.1.2 Exercise 1: Complete the following items to make sure you correctly set up the environment.\n\nOpen the explorer on the left-hand side\nConnect to the Python environment\nCreate a new code cell below and write a code snippet that prints out “finish”. Execute the cell.\nCreate a new script called “finish.py” and write a code snippet that prints out “finish”. Execute the script.\n\n\n\n\n\n2.1.3 Operators and Expressions\nBesides string, numbers are often used in programming. Python’s built-in operators allow numeric values to be manipulated and combined in a variety of familiar ways. Note that in Python, 2 + 3 is called an expression, which consists of values/operands (such as 2 or 3) and operators (such as +), and they are special statements! An expression is a combination of operators and operands that is interpreted to produce some other value.\n\n2.1.3.1 Using operand like a calculator\n\n\nCode\n# Integer\nprint(3+4)       # Prints “7”, which is 3 plus 4.\nprint(5-6)       # Prints “-1”, which is 5 minus 6\nprint(7*8)       # Prints “56”, which is 7 times 8\nprint(45/4)      # Prints “11.25”, which is 45 divided by 4, / is float(true) division\nprint(2**10)     # Prints “1024”, which is 2 to the 10th power\n\n\n7\n-1\n56\n11.25\n1024\n\n\n\nNote that we used ** to signify exponentiation, which can be somewhat surprising given that the caret symbol, ^, is often used for this purpose in some other programming languages. In Python, the caret operator belongs to XOR bitwise Boolean operations.\n\nWhen an operation such as forty-five divided by four produces a non-integer result, such as 11.25, Python implicitly switches to a floating-point representation. When purely integer answers are desired, a different set of operators can be used.\n\n\nCode\nprint(45//4)     # Prints “11”, which is 45 integer divided by 4, // is floor(integer) division\nprint(45%4)      # Prints “1”, because 4 * 11 + 1 = 45\n\n\n11\n1\n\n\nThe double slash signifies the integer floor division operator, while the percentage symbol signifies the modulus, or remainder operator. Taken together, we can read these calculations as, “Four goes into forty-five eleven times, with a remainder of one.”\nString values also can be combined and manipulated in some intuitive ways.\n\n\nCode\ns = 'hello' + 'world'\nt = s * 4\nprint(t)    # Prints “helloworldhelloworldhelloworldhelloworld”\n\n\nhelloworldhelloworldhelloworldhelloworld\n\n\nThe plus operator concatenates string values, while the multiplication operator replicates string values."
  },
  {
    "objectID": "01_Python.html#variables",
    "href": "01_Python.html#variables",
    "title": "2  Python Basics",
    "section": "2.2 Variables",
    "text": "2.2 Variables\nA variable is like a box in the computer’s memory where you can store value. If you want to use the result of an evaluated expression later in your program, you can save it inside a variable. You’ll store values in variables with an assignment statement. An assignment statement consists of a variable name, an equal sign, and the value to be stored. In Python, every single thing is stored as an object. A Python variable is actually a reference to an object!\n\n\n\n\nsource: https://runestone.academy/ns/books/published/cpp4python/AtomicData/AtomicData.html\n\n\n\nCode\nvarName = 100\n\n\nA variable is initialized (or created) the first time a value is stored in it. After that, you can use it in statements with other variables and values. When a variable is assigned a new value, the old value is forgotten. This is called overwriting the variable.\n\n\nCode\nspam = 'Hello'   # 'Hello' is a string object\nprint(spam)      # spam is a variable, it is just a reference or tag\nspam = 'Goodbye' # 'Goodbye' is another string object\nprint(spam)\n\n\nHello\nGoodbye\n\n\n\nIt’s much better to think of variables as labels that you can assign to values. You can also say that a variable references a certain value.\n\nThe naming of variables is largely up to the user in Python. Python’s simple rules are that variable names must begin with an alphabet letter or the underscore character, and may consist of an arbitrary number of letters, digits, and the underscore character (A-z, 0-9, and _ ). While a variable named m may be sufficient for a two line example script, experienced programmers strive to give meaningful, descriptive variable names in their scripts.\n\n\n\n\n\n\n\nValid variable names\nInvalid variable names\n\n\n\n\ncurrent_balance\ncurrent-balance (hyphens are not allowed)\n\n\ncurrentBalance\ncurrent balance (spaces are not allowed)\n\n\naccount4\n4account (can’t begin with a number)\n\n\n_42\n42 (can’t begin with a number)\n\n\nTOTAL_SUM\nTOTAL_$UM (special characters like $ are not allowed)\n\n\nhello\n‘hello’ (special characters like ’ are not allowed)\n\n\n\nPython variable names are case-sensitive, meaning that capitalization matters. A variable named size is treated as distinct from variables named Size or SIZE. A small number of keywords, names that are reserved for special meaning in Python, cannot be used as variable names. You can view this list by accessing the built-in Python help system.\n\n\nCode\nhelp('keywords')\n\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nVariables can be used to store all of the types of data values that Python is able to represent.\n\n\nCode\nmy_string = 'characters'\nmy_Boolean = True # True/False\nmy_integer = 5\nmy_floating_point = 26.2\nmy_complex = 2+1j # Note that 1 can not be omitted\n\n# You can condense the above statements into one line separated by ;\nmy_string = 'characters'; my_Boolean = True; my_integer = 5; my_floating_point = 26.2; my_complex = 2+1j\n\n\n### Multiple Assignment!\n# You can also assign values to more than one variable using just a single line of code!\nmy_string, my_Boolean, my_integer, my_floating_point, my_complex = 'characters',  True, 5, 26.2, 2+1j\n\n\n\n\nCode\nprint(10)\nprint(3.14)\nprint(2e10)   # scientific notation\nprint(12_000) # you can group digits using underscores to make large numbers more readable\nprint(3+2j)\n\n\n10\n3.14\n20000000000.0\n12000\n(3+2j)\n\n\nNote that when you’re writing long numbers, you can group digits using underscores to make large numbers more readable. In addition, print() can be used to print any numerical number including those in scientific notation.\n\n2.2.1 Data types\nIn Python variables and constants have a type. We can ask Python what type something is by using the type() function\n\n\nCode\ntype('Hello, World!'), type(False), type(4), type(3.2), type(3+5j)\n\n\n(str, bool, int, float, complex)\n\n\n\n\nCode\ntype(my_string),  type(my_Boolean), type(my_integer), type(my_floating_point), type(my_complex)\n\n\n(str, bool, int, float, complex)\n\n\nYou can convert object of one type to another using cast by str(), float(), int(), etc.\n\n\nCode\nfloat(3)\n\n\n3.0\n\n\n\n\nCode\nint(3.9)\n\n\n3\n\n\n\n\nCode\nint('3')\n\n\n3\n\n\n\n\nCode\nstr(3)\n\n\n'3'\n\n\nPython ord() and chr() are built-in functions. They are used to convert a character to an int and vice versa. Python ord() and chr() functions are exactly opposite of each other.\nPython ord() function takes string argument of a single Unicode character and return its integer Unicode code point value. Let’s look at some examples of using ord() function.\n\n\nCode\nx = ord('A')\nprint(x)\n\n\n65\n\n\nPython chr() function takes integer argument and return the string representing a character at that code point.\n\n\nCode\ny = chr(65)\nprint(y)\n\n\nA\n\n\n\n2.2.1.1 Conversion\nThere are two types of type conversion in Python.\n\nImplicit Conversion - automatic type conversion. Python always converts smaller data types to larger data types to avoid the loss of data.\nExplicit Conversion - manual type conversion\n\n\n\nCode\n5 + 4.2 # Implicit conversion\n\n\n9.2\n\n\nIn Python, complex &gt; float &gt; int &gt; bool\n\n\nCode\nint(4.7) + 3 # Explicit conversion\n\n\n7\n\n\n\n\n\n2.2.2 Debugging\nProgramming languages are not very forgiving for beginners, and a great deal of time learning to write software can be spent trying to find bugs, or errors in the code. Locating such bugs and correcting them is thus known as debugging. There are three major classes of bug that we create in software: syntax errors (mistakes in the symbols that have been typed), semantic errors (mistakes in the meaning of the program), and runtime errors (mistakes that occur when the program is executed.)\nSyntax errors are the most common for novices, and include simple errors such as forgetting one of the quote marks at the beginning or ending of a text string, failing to close open parentheses, or misspelling the function name print(). The Python interpreter will generally try to point these errors out when it encounters them, displaying an offending line number and a description of the problem. With some practice, a beginner can quickly learn to recognize and interpret common error cases. As examples:\n\n\nCode\nprint(5 + )\n\n\nSyntaxError: invalid syntax (Temp/ipykernel_24072/2298961889.py, line 1)\n\n\nThis expression is missing a value between the addition operator and the closing parenthesis.\n\n\nCode\nprint(mystring)\n\n\nNameError: name 'mystring' is not defined\n\n\nIn this case it found a name error and reports that the variable being printed has not been defined. Python can’t identify the variable name provided.\n\n\nCode\npront(5)\n\n\nNameError: name 'pront' is not defined\n\n\nLike calling someone by the wrong name, misspelling the name of a known function or variable can result in confusion and embarrassment.\nSemantic errors are flaws in the algorithm, or flaws in the way the algorithm is expressed in a language. Examples might include using the wrong variable name in a calculation, or getting the order of arithmetic operations wrong in a complex expression. Python follows the standard rules for operator precedence, so in an expression like total_pay = 40 + extra_hours * pay_rate, the multiplication will be performed before the addition, incorrectly calculating the total pay. (Unless your pay rate happens to be $1/hour.) Use parenthesis to properly specify the order of operations in complex expressions, thereby avoiding both semantic errors and code that may be harder to understand (e.g., total_pay = (40 + extra_hours) * pay_rate).\nFinally, runtime errors at this level might include unintentionally dividing by zero or using a variable before you have defined it. Python reads statements from top to bottom, and it must see an assignment statement to a variable before that variable is used in an expression.\n\n\nCode\n5/0\n\n\nZeroDivisionError: division by zero"
  },
  {
    "objectID": "01_Python.html#the-first-program",
    "href": "01_Python.html#the-first-program",
    "title": "2  Python Basics",
    "section": "2.3 The first program",
    "text": "2.3 The first program\nWhile the interactive shell is good for running Python instructions one at a time, sometimes you have to use a script, to write entire Python programs. In this case, you’ll type the instructions into the file editor.\n\n\nCode\n%%writefile hello.py\n\"\"\"\nThis program says hello and asks for your name.\nIt also ask the age of you.\n\"\"\"\n\nprint('Hello, world!')\nmyName = input('What is your name? ') # ask for their name\nprint('It is good to meet you, ' + myName)\nprint('The length of your name is:\\n' + str(len(myName)))\nmyAge = input('What is your age? ') # ask for their age\nprint('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\n\nWriting hello.py\n\n\nOnce you’ve entered your source code, the ipython magic %%writefile will save it so that you won’t have to retype it each time you start. You can then use another magic %run to execute the python script.\n\n\nCode\n%run hello.py\n\n\nHello, world!\nIt is good to meet you, phonchi\nThe length of your name is:\n7\nYou will be 33 in a year.\n\n\n\n2.3.1 Dissecting Your Program\nWith your new program open in the file editor, let’s take a quick tour of the Python instructions it uses by looking at what each line of code does.\n\nThe first line is the comment that tells others your intention of this program or the authorship of the program. Here it uses the multiline comment by using the triple quotes. The line print('Hello, world!') means “Print out the text in the string ‘Hello, world!’.” When Python executes this line, you say that Python is calling the print() function and the string value is being passed to the function. A value that is passed to a function call is an argument. When you write a function name, the opening and closing parentheses at the end identify it as the name of a function.\nThe input() function waits for the user to type some text on the keyboard and press ENTER. The myName = input() function call evaluates to a string equal to the user’s text, and the line of code assigns the myName variable to this string value.\nThe following call to print('It is good to meet you, ' + myName) is an expression. 'It is good to meet you, ' and myName between the parentheses are concatenated together via the operand + and printed out.\nYou can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string. If you want to concatenate an integer such as 29 with a string to pass to print(), you’ll need to get the value ‘29’, which is the string form of 29. The str() function can be passed an integer value and will evaluate to a string value version of the integer. Besides, there is a \\n in the statement print('The length of your name is:\\n' + str(len(myName))). The string starts with the backslash has a special escape meaning and \\n means adding a newline.\nThe int() function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. The myAge variable contains the value returned from input(). You can use the int(myAge) code to return an integer value of the string in myAge. This integer value is then added to 1 in the expression int(myAge) + 1. The result of this addition is passed to the str() function: str(int(myAge) + 1). The string value returned is then concatenated with the strings 'You will be ' and ' in a year.' to evaluate one large string value. This large string is finally passed to print() to be displayed on the screen.\n\n\n2.3.2 Exercise 2: Write a script that inputs a five-digit integer from the user. Separate the number into its individual digits. Print them separated by three spaces each. For example, if the user types in the number 42339, the script should print 4 \\(~~\\) 2 \\(~~\\) 3 \\(~~\\) 3 \\(~~\\) 9\n\nHint: Use floor division (//) and remainder (%) to isolate the digits.\n\n\nCode\n# Your answer here\n# x=42339\n# Get the user's input from their keyboard and convert it to integer:\nx = _____('Enter a 5 digit integer')\n# Get the last digit by remainder\ndigits4 = \n# Perform floor division and get the remainig digits\nx = \n#....\n\n# Print out the results\n____(digits0,'   ',digits1,'   ',digits2,'   ',digits3,'   ',digits4)\n\n\n4     2     3     3     9"
  },
  {
    "objectID": "01_Python.html#the-zen-of-python",
    "href": "01_Python.html#the-zen-of-python",
    "title": "2  Python Basics",
    "section": "2.4 The zen of Python",
    "text": "2.4 The zen of Python\n\n\nCode\nimport this\n\n\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\n\nYou can compute expressions with a calculator or enter string concatenations with a word processor. You can even do string replication easily by copying and pasting text. But once you know how to handle the programing elements, you will be able to instruct Python to operate on large amounts of data automatically for you to replace these tasks.\nDon’t try to write perfect code; write code that works, and then decide whether to improve your code for that project or move on to something new. But as you continue to the next chapters and start digging into more involved topics, try to keep this philosophy of simplicity and clarity in mind.\n\nYou can also refer PEP8 which is a reference document that provides guidelines and best practices on how to write Python code."
  },
  {
    "objectID": "02_Flow_control.html#introduction",
    "href": "02_Flow_control.html#introduction",
    "title": "3  Flow Control",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\nLast week, we learned the basics of individual instructions and that a program is just a series of instructions. But programming’s real strength isn’t just running one instruction after another. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you rarely want your programs to start from the first line of code and simply execute every line straight to the end. Flow control statements can decide which Python instructions to execute under which conditions.\nThese flow control statements directly correspond to the symbols in a flowchart. A flowchart usually has more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps (states) are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\n\n\nBut before you learn about flow control statements, you first need to learn how to represent those yes and no options and understand how to write those branching points as Python code. To that end, let’s explore Boolean values, comparison operators, and Boolean operators.\n\n3.1.1 Boolean expressions\nA boolean expression is an expression that is either true or false. The following examples use the operator ==, which compares two operands and produces True if they are equal and False otherwise:\n\n\nCode\n5 == 5, 5 == 6\n\n\nTrue and False are special values that belong to the class bool; they are not strings:\n\n\nCode\ntype(True), type(False)\n\n\nThe == operator is one of the comparison operators or relational operators; the others are:\n\n\n\n\nMeaning\n\n\n\n\nx != y\nx is not equal to y\n\n\nx &gt; y\nx is greater than y\n\n\nx &lt; y\nx is less than y\n\n\nx &gt;= y\nx is greater than or equal to y\n\n\nx &lt;= y\nx is less than or equal to y\n\n\nx is y\nx is the same as y\n\n\nx is not y\nx is not the same as y\n\n\n\n\nThe Python symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign = instead of a double equal sign ==. Remember that = is used in the assignment statement and == is a comparison operator. There is no such thing as =&lt; or =&gt;.\n\nThese operators evaluate to True or False depending on the values you give them and, therefore, can be used in the decision point as a condition statement.\n\n\nCode\nprint(42==42)\nprint(42==42.0)         # It will compare its value!\nprint(42=='42')         # int/float are always different from string\nprint(2!=3)\nprint('hello'=='Hello') # Python is case sensitive\nprint(42 &lt; 100)\nprint(42 &gt;= 100)\n\n\n\n\n3.1.2 Boolean (Logical) Operators\nThe three Boolean operators (and, or, and not) are used to operate on Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let’s explore these operators in detail.\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nTrue and True\nTrue\n\n\nTrue and False\nFalse\n\n\nFalse and True\nFalse\n\n\nFalse and False\nFalse\n\n\n\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nTrue or True\nTrue\n\n\nTrue or False\nTrue\n\n\nFalse or True\nTrue\n\n\nFalse or False\nFalse\n\n\n\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nnot True\nFalse\n\n\nnot False\nTrue\n\n\n\n\n\nCode\nprint((4 &lt; 5) and (5 &lt; 6))\nprint((6 &lt; 5) or (9 &lt; 6))\nprint((1 == 2) or (2 == 2))\nprint(not (1==3) and (3==4))\n\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. The Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the not operators first, then the and operators, and then the or operators."
  },
  {
    "objectID": "02_Flow_control.html#elements-of-flow-control",
    "href": "02_Flow_control.html#elements-of-flow-control",
    "title": "3  Flow Control",
    "section": "3.2 Elements of Flow Control",
    "text": "3.2 Elements of Flow Control\nIt can be shown that all programs could be written using three forms of control—namely, sequential execution, the selection statement and the repetition statement. This is the idea behind structured programming.\nFlow control statements often start with a part called the condition and are always followed by a block of code called the clause or body. The Boolean expressions you’ve seen so far could all be considered conditions, which are the same thing as expressions; the condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False. A flow control statement decides what to do based on whether its condition is True or False.\n\n3.2.1 Blocks of Code\nLines of Python code can be grouped together in blocks. You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.\n\nBlocks begin when the indentation increases.\nBlocks can contain other blocks.\nBlocks end when the indentation decreases to zero or to a containing block’s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let’s find the blocks in part of a small game program, shown here:\n\n\nCode\nname = 'Mary'\npassword = 'swordfish'\nif name == 'Mary':\n    print('Hello, Mary')\n    if password == 'swordfish':\n        print('Access granted.')\n    else:\n        print('Wrong password.')\n\n\nYou can view the execution of this program at https://autbor.com/blocks/. The first block of code starts at the line print('Hello, Mary') and contains all the lines after it. Inside this block is another block, which has only a single line in it: print('Access Granted.'). The third block is also one line long: print('Wrong password.').\nAn IndentationError occurs if you have more than one statement in a block and those statements do not have the same indentation:\n\n\nCode\nname = 'Mary'\npassword = 'swordfish'\nif name == 'Mary':\n  print('Hello, Mary')\n    if password == 'swordfish':\n        print('Access granted.')\n    else:\n        print('Wrong password.')\n\n\n\nIt is recomend to use four white spaces as the indentation\n\n\n\n3.2.2 Conditional execution\nThe control statement affords us a mechanism for jumping from one part of a program to another. In higher-level languages like Python, this enables what is called control structures, syntax patterns that allow us to express algorithms more succinctly. One example of this is the if-statement. An if statement’s body (that is, the block following the if statement) will execute if the statement’s condition is True. The body is skipped if the condition is False.\nIn Python, an if statement consists of the following:\n\nThe if keyword\nA condition (that is, an expression that evaluates to True or False)\nA colon\nStarting on the next line, an indented block of code (called the if body)\n\nThe boolean expression after the if statement is called the condition. We end the if statement with a colon character (:) and the line(s) after the if statement are indented. If the logical condition is true, then the indented statement gets executed. If the logical condition is false, the indented statement is skipped.\n\n\nCode\nname = 'Mary'\nif name == 'Alice':\n    print('Hi, Alice.')\n\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nA second form of the if statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:\n\n\nCode\nif name == 'Alice':\n    print('Hi, Alice.')\nelse:\n    print('Hello, stranger.')\n\n\nYou can also write the above code in one line using the ternary conditional operator:\n\n\nCode\nprint('Hi, Alice.') if name == 'Alice' else print('Hello, stranger.') # Note that we do not have colon in between!\n\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nSince the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution.\nSometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:\n\n\nCode\nname = 'Carol'\nage = 3000\nif name == 'Alice':\n    print('Hi, Alice.')\nelif age &lt; 12:\n    print('You are not Alice, kidd.')\nelse:\n    print('You are neither Alice nor a little kid.')\n\n\nYou can view the execution of this program at https://autbor.com/littlekid/. In plain English, this type of flow control structure would be “If the first condition is true, do this. Else, if the second condition is true, do that.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\n\n3.2.3 Exercise 1: Write a code that allows the user to input row and column. The program prints ‘black’ or ‘white’ depending on the color of the specified row and column of the chessboard. Chess boards are 8 x 8 spaces in size, and the rows and columns in this program begin at 0 and end at 7. If the inputs for a row or column are outside the 0 to 7 range, it should print ‘out of board’!\n\n\n\n\n\nsource: https://inventwithpython.com/pythongently/images/image011.png\n\n\n\nCode\nrow = int(input(\"Enter row\"))\ncolumn = int(input(\"Enter column\"))\n# If the column and row is out of bounds, print out of board:\nif column ____ or column ___ or row ___ or row ____:\n    print('out of board')\n# If the even/oddness of the column and row match, print 'white':\n____ column % _ == row % _:\n    print('white')\n# If they don't match, then print 'black':\n____:\n    print('black')\n\n\n\n\n3.2.4 Loops and Iterations\nYou can make a block of code execute over and over again using a while statement. The code in a while body will be executed as long as the while statement’s condition is True. In code, a while statement always consists of the following:\n\nThe while keyword\nA condition (that is, an expression that evaluates to True or False)\nA colon\nStarting on the next line, an indented block of code (called the while body)\n\n\n\nCode\nspam = 0\nwhile spam &lt; 5:\n    print('Hello, world.')\n    spam += 1 # equivalent to spam = spam + 1\n\n\n\nAugmented assignments abbreviate assignment expressions in which the same variable name appears on the left and right of the assignment’s = as above\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nMore formally, here is the flow of execution for a while statement:\n\nEvaluate the condition, yielding True or False.\nIf the condition is false, exit the while statement and continue execution at the next statement.\nIf the condition is true, execute the body and then go back to step 1.\n\nIn the while loop, the condition is always checked at the start of each iteration (that is, each time the loop is executed). If the condition is True, then the body is executed, and afterward, the condition is checked again. The first time the condition is found to be False, the while body is skipped.\nA common programming pattern is that we can run the program as long as the user wants by putting most of the program in a while loop. We’ll define a quit value and then keep the program running as long as the user has not entered the quit value:\n\n\nCode\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile message != 'quit':\n    message = input(prompt)\n    print(message)\n\n\nWe first set up a variable message to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time through the loop, the message is just an empty string, so Python enters the loop. At message = input(prompt), Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word ‘quit’, the prompt is displayed again and Python waits for more input. When the user finally enters ‘quit’, Python stops executing the while loop and the program ends.\n\nNote that Python considers 0, None, empty string, and empty container as False and all other things are True!\n\n\n\nCode\nbool(\"\"), bool(0), bool(None), bool(prompt), bool(12)\n\n\n\n3.2.4.1 Using break to Exit a Loop\nThe above program works well, except that it prints the word ‘quit’ as if it were an actual message. In fact, there is a shortcut to getting the program execution to break out of a while loop’s body early. If the execution reaches a break statement, it immediately exits the while loop’s body. In code, a break statement simply contains the break keyword.\n\n\nCode\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile True:\n    message = input(prompt)\n    if message == 'quit':\n        break\n    else:\n        print(message)\n\n\nThe fourth line creates an infinite loop; it is a while loop whose condition is always True. After the program execution enters this loop, it will exit the loop only when a break statement is executed. (An infinite loop that never exits is a common programming bug.)\nJust like before, this program asks the user to for the input. Now, however, while the execution is still inside the while loop, an if statement checks whether the message is equal to ‘quit’. If this condition is True, the break statement is run, and the execution moves out of the loop. Otherwise, the if statement’s body that contains the break statement is skipped, which again prints out the message. After that, the program execution jumps back to the start of the while statement to recheck the condition. Since this condition is merely the True Boolean value, the execution enters the loop to ask the user to type another message.\n\n\n3.2.4.2 continue Statemet\nRather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in that range:\n\n\nCode\ncurrent_number = 0\nwhile current_number &lt; 10:\n    current_number += 1\n    if current_number % 2 == 0:\n        continue\n    else:\n        print(current_number, end=' ')\n\n\nFirst, we set current_number to 0. Because it’s less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1, so current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0, the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current_number is not divisible by 2, the rest of the loop is executed and Python prints the current_number.\nNote that the built-in function print() displays its argument(s), then moves the cursor to the next line. You can change this behavior with the argument end. We used one space (’ ’), so each call to print displays the character’s value followed by one space.\n\nIf you ever run a program that has a bug causing it to get stuck in an infinite loop, press CTRL-C. This will send a KeyboardInterrupt error to your program and cause it to stop immediately.\n\n\n\n3.2.4.3 “TRUTHY” and “FALSY” Values\nLet us delve into the following program:\n\n\nCode\nname = ''\nwhile not name:\n    print('Enter your name:')\n    name = input()\n\nprint('How many guests will you have?')\nnumOfGuests = int(input())\n\nif numOfGuests:\n    print('Be sure to have enough room for all your guests.')\nprint('Done')\n\n\nYou can view the execution of this program at https://autbor.com/howmanyguests/. If the user enters a blank string for name, then the while statement’s condition will be True, and the program continues to ask for a name. If the value for numOfGuests is not 0, then the condition is considered to be True, and the program will print a reminder for the user. You could have entered not name != '' instead of not name, and numOfGuests != 0 instead of numOfGuests, but using the truthy and falsy values can make your code easier to read.\n\n\n\n3.2.5 for Loops and the range() Function\nThe while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function.\nIn code, a for statement looks something like for i in range(5): and includes the following:\n\nThe for keyword\nA variable name\nThe in keyword\nA call to the range() funtion with up to three integers passed to it (or an iterable object, which we will discuss later on)\nA colon\nStarting on the next line, an indented block of code (called the for body)\n\nLet’s create a new program to help you see a for loop in action.\n\n\nCode\nprint('My name is')\nfor i in range(5):\n    print('Jimmy Five Times (' + str(i) + ')')\n\n\nYou can view the execution of this program at https://autbor.com/fivetimesfor/. The code in the for loop’s body is run five times. The first time it is run, the variable i is set to 0. The print() call in the body will print Jimmy Five Times (0). After Python finishes an iteration through all the code inside the for loop’s body, the execution goes back to the top of the loop, and the for statement increments i by one. This is why range(5) results in five iterations through the body, with i being set to 0, then 1, then 2, then 3, and then 4. The variable i will go up to, but will not include, the integer passed to range().\nYou can actually use a while loop to do the same thing as a for loop; for loops are just more concise.\n\n\nCode\nprint('My name is')\ni = 0\nwhile i &lt; 5:\n    print('Jimmy Five Times (' + str(i) + ')')\n    i = i + 1\n\n\n\n3.2.5.1 The Starting, Stopping, and Stepping Arguments to range()\nSome functions can be called with multiple arguments separated by a comma, and range() is one of them. This lets you change the integer passed to range() to follow any sequence of integers, including starting at a number other than zero.\n\n\nCode\nfor i in range(12, 16):\n    print(i)\n\n\nThe range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.\n\n\nCode\nfor i in range(0, 10, 2):\n    print(i)\n\n\nThe range() function is flexible in the sequence of numbers it produces for for loops. For example , you can even use a negative number for the step argument to make the for loop count down instead of up.\n\n\nCode\nfor i in range(5, -1, -1):\n    print(i)\n\n\n\nNote that Python introduce switch statement as another control statement in Python 3.10\n\n\n3.2.6 Exercise 2: Write a script that displays the following triangle patterns. Use for loops to generate the patterns.\n\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\nHint: Try to use nested loops and use the outer loop to display each row while the inner loop to display each column\n\n\nCode\nfor row in range(__,__):\n    for column in range(__,__):\n        print('*', end='')\n    print()"
  },
  {
    "objectID": "02_Flow_control.html#importing-modules",
    "href": "02_Flow_control.html#importing-modules",
    "title": "3  Flow Control",
    "section": "3.3 Importing Modules",
    "text": "3.3 Importing Modules\nAll Python programs can call a basic set of functions called built-in functions, including the print(), input(), len() and range() functions you’ve seen before. Python also comes with a set of modules called the standard library. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematics-related functions. The random module has random number-related functions, and so on.\nBefore you can use the functions in a module, you must import the module with an import statement. In code, an import statement consists of the following:\n\nThe import keyword\nThe name of the module\nOptionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let’s give it a try with the random module, which will give us access to the random.randint() function.\n\n\nCode\nimport random\nfor i in range(5):\n    print(random.randint(1, 10))\n\n\nYou can view the execution of this program at https://autbor.com/printrandom/. The random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell Python to look for this function inside the random module. We will discuss it more in the following chapter.\n\nCheck out the Python standard library here or here\n\n\n3.3.1 Ending a Program Early with the sys.exit() Function\nThe last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.\n\n\nCode\n%%writefile exit.py\n\nimport sys\n\nwhile True:\n    print('Type exit to exit.')\n    response = input()\n    if response == 'exit':\n        sys.exit()\n    print('You typed ' + response + '.')\nprint('This line will not be printed')\n\n\n\n\nCode\n%run exit.py\n\n\nBy using expressions that evaluate to True or False (also called conditions), you can write programs that make decisions on what code to execute and what code to skip. You can also execute code over and over again in a loop while a certain condition evaluates to True. The break and continue statements are useful if you need to exit a loop or jump back to the loop’s start. These flow control statements will let you write more intelligent programs. You can also use another type of flow control by writing your own functions, which is the topic of the next chapter."
  },
  {
    "objectID": "03_Function.html#introductions",
    "href": "03_Function.html#introductions",
    "title": "4  Functions",
    "section": "4.1 Introductions",
    "text": "4.1 Introductions\nExperience has shown that the best way to develop and maintain a large program is to con struct it from smaller, more manageable pieces. This technique is called divide and conquer. We have already seen operations like print(), str() and len(), which involve parentheses wrapped around their operands. These are examples of Python’s built-in functions. Programming language allows us to use a name for a series of operations that should be performed on the given parameters. The appearance of a function in an expression or statement is known as a function call, or sometimes calling a function.\n\nIt allows you to execute a block of codes from various locations in your program by calling the function, rather than duplicating the code.\nIt also makes programs easier to modify. When you change a function’s code, all calls to the function execute the updated version.\n\n\nA function is a block of organized code that is used to perform a task. They provide better modularity and reusability.\n\n\n4.1.1 def Statements with Parameters\nWhen you call the print() or len() function, you pass them values, called arguments, by typing them between the parentheses. You can also define your own functions that accept arguments.\n\n\nCode\ndef hello(name):\n    print('Hello,', name)\n\nhello('Alice')\nhello('Bob')\n\n\nHello, Alice\nHello, Bob\n\n\nThe def statement defines the hello() function. Any indented lines that follow def hello(): make up the function’s body. The hello('Alice') line calls the now-created function. This function call is also known as passing the string value ‘Alice’ to the function.\n\n\n\nimage.png\n\n\nYou can view the execution of this program at https://autbor.com/hellofunc2/. The definition of the hello() function in this program has a parameter called name. When a function is called with arguments, the arguments are stored in the parameters. The first time the hello() function is called, it is passed the argument ‘Alice’. The program execution enters the function, and the parameter name is automatically set to ‘Alice’, which is what gets printed by the print() statement. One thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added print(name) after hello('Bob') in the previous program, the program would give you a NameError because there is no variable named name.\n\n\nCode\nprint(name)\n\n\nNameError: name 'name' is not defined\n\n\n\n4.1.1.1 Positional Arguments\nWhen you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is based on the order of the arguments provided. Values matched up this way are called positional arguments.\n\n\nCode\ndef describe_pet(animal_type, pet_name):\n    \"\"\"\n    Display information about a pet.\n    we can write multiple lines here!    \n    \"\"\"\n    print(\"\\nI have a\", animal_type, \".\")\n    print(\"My\", animal_type + \"'s name is\", pet_name.title() + \".\")\n\ndescribe_pet('hamster', 'harry')\n\n\n\nI have a hamster .\nMy hamster's name is Harry.\n\n\nWhen we call describe_pet(), we need to provide an animal_type and a name, in that order. For example, in the function call, the argument ‘hamster’ is assigned to the parameter animal_type and the argument ‘harry’ is assigned to the parameter pet_name. In the function body, these two parameters are used to display information about the pet being described.\nNote that the text on the second line is a comment called a docstring (multi-line comments introduced in Chapter 1), which describes what the function does. When Python generates documentation for the functions in your programs, it looks for a string immediately after the function’s definition. These strings are usually enclosed in triple quotes, which lets you write multiple lines. If you use the help() function, it will also be printed out as well as the function name and parameters.\n\n\nCode\nhelp(describe_pet)\n\n\nHelp on function describe_pet in module __main__:\n\ndescribe_pet(animal_type, pet_name)\n    Display information about a pet.\n    we can write multiple lines here!\n\n\n\n\n\nCode\nhelp(print)\n\n\nHelp on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n\n\n\n\nNote that if there is more than one argument in print(), the default separation value is a white space. But you can change this behavior by specifying the sep keyword.\n\n\n\nCode\nprint(\"8\", \"9\", sep=\"*\")\n\n\n8*9\n\n\n\n\n4.1.1.2 Return Values and return Statements\nWhen you call the len() function and pass it an argument such as ‘Hello’, the function call evaluates to the integer value. The value that a function call evaluates to is called the return value of the function.\nWhen creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:\n\nThe return keyword\nThe value or expression that the function should return\n\nWhen an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on the number passed as an argument.\n\n\nCode\nimport random\n\ndef getAnswer(answerNumber):\n    if answerNumber == 1:\n        return 'It is certain'\n    elif answerNumber == 2:\n        return 'It is decidedly so'\n    elif answerNumber == 3:\n        return 'Yes'\n    elif answerNumber == 4:\n        return 'Reply hazy try again'\n    elif answerNumber == 5:\n        return 'Ask again later'\n    elif answerNumber == 6:\n        return 'Concentrate and ask again'\n    elif answerNumber == 7:\n        return 'My reply is no'\n    elif answerNumber == 8:\n        return 'Outlook not so good'\n    elif answerNumber == 9:\n        return 'Very doubtful'\n\nr = random.randint(1, 9)\nfortune = getAnswer(r)\nprint(fortune)\n\n\nYes\n\n\nYou can view the execution of this program at https://autbor.com/magic8ball/. When this program starts, Python first imports the random module. Then the getAnswer() function is defined. Because the function is being defined (and not called), the execution skips over the code in it. Next, the random.randint() function is called with two arguments: 1 and 9. It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named r.\nThe getAnswer() function is called with r as the argument. The program execution moves to the top of the getAnswer() function, and the value r is stored in a parameter named answerNumber. Then, depending on the value in answerNumber, the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that was originally called getAnswer(). The returned string is assigned to a variable named fortune, which then gets passed to a print() call and is printed to the screen. The functions that return values are sometimes called fruitful functions.\n\n\n4.1.1.3 The None Value\nIn Python, there is a value called None, which represents the absence of a value. The None value is the only value of the NoneType data type. This can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where None is used is as the return value of print(). The print() function displays text on the screen, but it doesn’t need to return anything. But since all function calls need to evaluate to a return value, print() returns None. A function does not return a value is called a void function\n\n\nCode\nspam = print('Hello!')\nprint(spam)\ntype(spam)\n\n\nHello!\nNone\n\n\nNoneType\n\n\n\nBehind the scenes, Python adds return None in the end of any function definition with no return statement. Also, if you use a return statement without a value (that is, just the return keyword by itself), then None is returned.\n\n\n\n4.1.1.4 Keyword Arguments\nA keyword argument is a name-value pair you pass to a function. You directly associate the name and the value within the argument, so when you pass the argument to the function, there’s no confusion. Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call.\n\n\nCode\ndescribe_pet(animal_type='hamster', pet_name='harry')\n\n\n\nI have a hamster .\nMy hamster's name is Harry.\n\n\nThe function describe_pet() hasn’t changed. But when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument ‘hamster’ to the parameter animal_type and the argument ‘harry’ to pet_name. The output correctly shows that we have a hamster named Harry.\n\n\n4.1.1.5 Default parameter values\nWhen writing a function, you can define a default value for each parameter. If an argument for a parameter is provided in the function call, Python uses the argument value. If not, it uses the parameter’s default value. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to ‘dog’:\n\n\nCode\ndef describe_pet(pet_name, animal_type='dog'):\n    \"\"\"\n    Display information about a pet.\n    Here we have default value for the animal type    \n    \"\"\"\n    print(\"\\nI have a \" + animal_type + \".\")\n    print(\"My\" + animal_type +\"'s name is \" + pet_name.title() + \".\")\n    \ndescribe_pet('willie')\n\n\n\nI have a dog.\nMydog's name is Willie.\n\n\nNow when the function is called with no animal_type specified, Python knows to use the value ‘dog’ for this parameter. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet’s name. Python still interprets this as a positional argument, so if the function is called with just a pet’s name, that argument will match up with the first parameter listed in the function’s definition.\n\nWhen you use default values, any parameter with a default value needs to be listed after all the parameters that don’t have default values. This allows Python to continue interpreting positional arguments correctly. Otherwise error occurs.\n\n\n\nCode\ndef describe_pet(animal_type='dog', pet_name):\n    \"\"\"\n    Display information about a pet.\n    Here we have default value for the animal type    \n    \"\"\"\n    print(\"\\nI have a \" + animal_type + \".\")\n    print(\"My\" + animal_type +\"'s name is \" + pet_name.title() + \".\")\n    \ndescribe_pet('willie')\n\n\nSyntaxError: non-default argument follows default argument (Temp/ipykernel_24512/574269134.py, line 1)\n\n\n\n\n\n4.1.2 Advance usage\n\n4.1.2.1 Passing an Arbitrary Number of Arguments\nSometimes you won’t know how many arguments a function needs to accept ahead of time. Fortunately, Python allows a function to collect arbitrary arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings, but this parameter collects as many arguments as the calling line provides:\n\n\nCode\ndef make_pizza(size, *toppings):\n    \"\"\"Print the list of toppings that have been requested.\"\"\"\n    print(\"The size of the pizza is\", size, \"inch with the following toppings:\")\n    print(toppings)\n\nmake_pizza(6, 'pepperoni')\nmake_pizza(8, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nThe size of the pizza is 6 inch with the following toppings:\n('pepperoni',)\nThe size of the pizza is 8 inch with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nIn the function definition, Python assigns the first value it receives to the parameter size. All other values that come after are stored in the tuple (which we will discuss in later chapters) with the name toppings. The function calls include an argument for the size first, followed by as many toppings as needed.\n\nYou’ll often see the generic parameter name *args, which collects arbitrary positional arguments like this. The *arg must be the rightmost parameter (except for parameter with default value and the **kwargs).\n\n\n\n4.1.2.2 Using Arbitrary Keyword Arguments\nSometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:\n\n\nCode\ndef build_profile(first, last, **user_info):\n    \"\"\"Build a dictionary containing everything we know about a user.\"\"\"\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nuser_profile = build_profile('albert', 'einstein',\n                             location='princeton',\n                             field='physics')\nprint(user_profile)\n\n\n{'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'}\n\n\nThe definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs (Keyword arguments) as they want. The double asterisks before the parameter **user_info cause Python to create a dictionary (Which we will discuss in later chapters) called user_info containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary.\nIn the body of build_profile(), we add the first and last names to the user_info dictionary because we’ll always receive these two pieces of information from the user, and they haven’t been placed into the dictionary yet. Then we return the user_info dictionary to the function call line.\n\nYou’ll often see the parameter name **kwargs used to collect nonspecific keyword arguments. The **kwargs must be the rightmost paramter.\n\n\n4.1.3 Exercise 1: Please write a function implementing the “guess the number” game. The function accepts two arguments for the maximum number of tries and the maximum number. The function returns a boolean value indicating whether the player guessed the number correctly or not. If the player doesn’t guess the number correctly after the maximum number of tries, the function returns False; otherwise, it should return True. You can set the default value of the max number to an arbitrary number.\n\n\n\n\n\nCurrently, there exists a delay for the input() function in vscode. Therefore, it is recommended to play the game using the script!\n\n\n\nCode\n%%writefile guess_number.py\n\nimport random\n\ndef guess_number(max_tries, max_number=_____):\n    \"\"\"\n    Function that allows the player to guess a number between 1 and max_number\n    If the player can guess the correct number within max_tries times, return True\n    Otherwise, return False\n    \"\"\"\n    # Generate a random number between 1 and max_number\n    number = _____ \n\n    # Allow the player to guess up to max_tries times\n    for i in range(max_tries):\n        # Prompt the player to guess the number\n        guess = int(input(\"Guess the number (between 1 and \"+ str(max_number) +\"): \"))\n\n        # Check if the guess is correct\n        if ______:\n            print(\"Congratulations, you guessed the number!\")\n            ______\n        elif ______:\n            print(\"The number is higher than your guess.\")\n        else:\n            print(\"The number is lower than your guess.\")\n\n    # If the player couldn't guess the number in max_tries tries, reveal the answer\n    print(\"Sorry, you didn't guess the number. The number was \" + str(number) + \".\")\n    _______\n\n# Call the function to start the game with a maximum of 5 tries\ngame_result = guess_number(5)\n\n# Print the result of the game\nif game_result:\n    print(\"You won!\")\nelse:\n    print(\"You lost!\")\n\n\n\n\n\n4.1.4 Local and Global Scope\nParameters and variables assigned in a called function are said to exist in that function’s local scope. Variables assigned outside all functions are said to exist in the global scope. A variable in a local scope is called a local variable, while a variable in the global scope is called a global variable. A variable must be one or the other; it cannot be both local and global.\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. There is only one global scope, and it is created when your program begins. A local scope is created whenever a function is called. Any variables assigned in the function exist within the function’s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The next time you call the function, the local variables will not remember the values stored in them from the last time it was called.\n\n4.1.4.1 Local Variables Cannot Be Used in the Global Scope\nConsider this program, which will cause an error when you run it:\n\n\nCode\ndef spam():\n    eggs = 31337\n\nspam()\nprint(eggs)\n\n\nNameError: name 'eggs' is not defined\n\n\nThe error happens because the eggs variable exists only in the local scope created when spam() is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs.\n\n\n4.1.4.2 Local Scopes Cannot Use Variables in Other Local Scopes\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\n\nCode\ndef spam():\n    eggs = 99\n    bacon()\n    print(eggs)\n\ndef bacon():\n    ham = 101\n    eggs = 0\n\nspam()\n\n\n99\n\n\nYou can view the execution of this program at https://autbor.com/otherlocalscopes/. When the program starts, the spam() function is called, and a local scope is created. The local variable eggs is set to 99. Then the bacon() function is called, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101, and a local variable eggs — which is different from the one in spam()’s local scope—is also created and set to 0. When bacon() returns, the local scope for that call is destroyed, including its eggs variable. The program execution continues in the spam() function to print the value of eggs. Since the local scope for the call to spam() still exists, the only eggs variable is the spam() function’s eggs variable, which was set to 99.\n\n\n4.1.4.3 Global Variables Can Be Read from a Local Scope\n\n\nCode\ndef spam():\n    print(eggs)\n    \neggs = 42\nspam()\nprint(eggs)\n\n\n42\n42\n\n\nYou can view the execution of this program at https://autbor.com/readglobal/. Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam(), Python considers it a reference to the global variable eggs. This is why 42 is printed when the previous program is run.\n\n\nCode\ndef spam():\n    eggs = 'spam local'\n    print(eggs)    # prints 'spam local'\n\ndef bacon():\n    eggs = 'bacon local'\n    print(eggs)    # prints 'bacon local'\n    spam()\n    print(eggs)    # prints 'bacon local'\n\neggs = 'global'\nbacon()\nprint(eggs)        # prints 'global'\n\n\nbacon local\nspam local\nbacon local\nglobal\n\n\n\nIf you want to modify the global variable, use the global keywords.\n\n\n\nCode\ndef spam():\n    global eggs    # If you want to modify the global eggs use global keyword\n    eggs = 'spam local' \n    print(eggs)    # prints 'spam local'\n\neggs = 'global'\nspam()\nprint(eggs)\n\n\nspam local\nspam local\n\n\nYou can visulaize the execution here.\n\n\n\n4.1.5 Storing Your Functions in Modules\nOne advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, your programs become much easier to follow. You can go a step further by storing your functions in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file.\n\nStoring your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.\n\n\n4.1.5.1 Importing a module\nTo start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let’s make a module that contains the function make_pizza().\n\n\nCode\n%load_ext autoreload\n%autoreload 2\n\n\n\n\nCode\n%%writefile pizza.py\ndef make_pizza(size, *toppings):\n    \"\"\"Summarize the pizza we are about to make.\"\"\"\n    print(\"\\nMaking a \"+ str(size) + \"-inch pizza with the following toppings:\")\n    print(toppings)\n\n\nOverwriting pizza.py\n\n\n\n\nCode\nimport pizza\n\npizza.make_pizza(16, 'pepperoni')\npizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nWhen Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. To call a function from an imported module, enter the name of the module you imported, pizza, followed by the name of the function, make_pizza(), separated by a dot.\n\n\n4.1.5.2 Importing Specific Functions using from\nYou can also import a specific function from a module.\n\n\nCode\nfrom pizza import make_pizza\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nWith this syntax, you don’t need to use the dot notation when you call a function.\n\n\n4.1.5.3 Importing All Functions in a Module\nYou can tell Python to import every function in a module by using the asterisk (*) operator:\n\n\nCode\nfrom pizza import *\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nThe asterisk in the import statement tells Python to copy every function from the module pizza into this program file. Because every function is imported, you can call each function by name without using the dot notation.\n\nHowever, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results!\n\n\n\n4.1.5.4 Using as to Give a Function an Alias\nIf the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique alias — an alternate name similar to a nickname for the function.\n\n\nCode\nfrom pizza import make_pizza as mp\n\nmp(16, 'pepperoni')\nmp(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\n\n\n4.1.5.5 Using as to Give a Module an Alias\nYou can also provide an alias for a module name. Giving a module a short alias, like p for pizza, allows you to call the module’s functions more quickly.\n\n\nCode\nimport pizza as p\n\np.make_pizza(16, 'pepperoni')\np.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\n\n4.1.6 Exercise 2: In this word game, the player is in a land full of dragons. Some dragons are friendly and share their treasure. Other dragons are hungry and eat anyone who enters their cave. The player approaches two caves, one with a friendly dragon and the other with a hungry dragon, but doesn’t know which dragon is in which cave. The player must choose between the two. Please completet the design of game by calling the function from the provided game module.\n\n\n\n\n\n\nCode\n%%writefile word_game.py\nimport random\nimport time\n_____________\n\nplayAgain = 'yes'\n\nwhile playAgain == 'yes':\n    # Display the information of game using the displayIntro() in game module\n    ______________\n    # Read the user input and return the cave number by calling the function chooseCave() in game module\n    caveNumber = ________________\n    # Check whether the cave is safe or not by calling the checkCave() in game module with appropriate arguments\n    ______(_____)\n\n    print('Do you want to play again? (yes or no)')\n    playAgain = input()\n\n\nFunctions are the primary way to categorize your code into logical groups. Since the variables in functions exist in their local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when debugging your code.\nFunctions are a great tool to help you organize your code. You can think of them as black boxes: they have input in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions."
  },
  {
    "objectID": "04_Lists_tuples.html#list",
    "href": "04_Lists_tuples.html#list",
    "title": "5  Lists and Tuples",
    "section": "5.1 List",
    "text": "5.1 List\nOne more topic you’ll need to understand before you can begin writing programs in earnest is the list data type and its cousin, the tuple. Lists and tuples can contain multiple values, which makes writing programs that handle large amounts of data easier. These data types are called containers, meaning they are objects that “contain” other objects. They each have some important distinguishing properties and come with their own set of methods for interacting with objects of each type. List and tuple belong to sequence data types, which means they represent ordered collections of items. They share the same characteristic as string and the range object returned by range() function. Many of the capabilities shown in this chapter apply to all sequence types.\n\nCheckout https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range for more details.\n\nIn a string, the values are characters; in a list, they can be any type. The values in a list are called elements or sometimes items. Items are separated with commas.\n\n\n\n\nsource: https://favtutor.com/blogs/list-vs-dictionary\n\nThere are several ways to create a new list; the simplest is to enclose the elements in square brackets (“[” and ”]”). A list that contains no elements is called an empty list; you can create one with empty brackets.\n\n\nCode\ntype([])\n\n\nlist\n\n\n\n\nCode\ntype([10, 20, 30, 40]), type(['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra'])\n\n\n(list, list)\n\n\nThe first example is a list of four integers and the second is a list of four strings.\n\n5.1.1 Getting Individual Values in a List with Indexes\nYou can reference a list item by writing the list’s name followed by the element’s index (that is, its position number) enclosed in square brackets ([], known as the subscription operator or bracket operator). Remember that the indices start at 0:\n\n\nCode\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[0])\nprint(subjects[3])\n\n\ncalculus\nlinear algebra\n\n\nNote that the first index is 0, the last index is one less than the size of the list; a list of four items has 3 as its last index.\nPython will give you an IndexError error message if you use an index that exceeds the number of values in your list value.\n\n\nCode\nprint(subjects[4])\n\n\nIndexError: list index out of range\n\n\nThe elements of a list don’t have to be the same type. The following list contains a string, a float, an integer, and another list:\n\n\nCode\nspam = ['spam', 2.0, 5, [10, 20]]\n\n\nThe values in these lists of lists can be accessed using multiple indexes:\n\n\nCode\nspam[3][1]\n\n\n20\n\n\n\n\nCode\nspam = [1,3,5,7,9]\nspam[3:]\n\n\n[7, 9]\n\n\nThe first index dictates which items in the outer list to use, and the second indicates the value within the inner list. If you only use one index like spam[3], the program will print the entire list value at that index.\n\n\nCode\nspam[3]\n\n\n7\n\n\n\n5.1.1.1 Negative Indexes\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on.\n\n\nCode\nprint(subjects[-1]) # subjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[-2])\n\n\nlinear algebra\ncomputer programming\n\n\n\n\n5.1.1.2 Getting a List’s Length with the len() Function\nThe len() function will return the number of values that are in a list, just like it can count the number of characters in a string.\n\n\nCode\nlen(subjects)\n\n\n4\n\n\n\n\n5.1.1.3 Getting a sublist from Another List with Slices\nJust as an index can get a single value from a list, a slice can get several values from a list as a new list. A slice is typed between square brackets, like an index, but has two integers separated by a colon.\n\nsubjects[2] is a list with an index.\nsubjects[1:3] is a list with a slice.\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list.\n\n\nCode\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[0:3])\nprint(subjects[1:-1])\n\n\n['calculus', 'introduction to mathematics', 'computer programming']\n['introduction to mathematics', 'computer programming']\n\n\nAs a shortcut, you can leave out one or both indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list.\n\n\nCode\nprint(subjects[:3]) # same as subjects[0:3] \nprint(subjects[1:]) # same as subjects[1:len(s)] \nprint(subjects[:]) # same as s[0:len(s)]\n\n\n['calculus', 'introduction to mathematics', 'computer programming']\n['introduction to mathematics', 'computer programming', 'linear algebra']\n['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n\n\nJust like range(), slicing has the optional third index that can be used to specify the step.\n\n\nCode\nprint(subjects[::2]) # Note the default step is 1\nprint(subjects[::-1]) # Reverse the order of the list\n\n\n['calculus', 'computer programming']\n['linear algebra', 'computer programming', 'introduction to mathematics', 'calculus']\n\n\n\n\n5.1.1.4 Changing Values in a List with Indexes\nUnlike strings, lists are mutable because you can reassign an item in a list. When the bracket operator appears on the left side of an assignment, it identifies the element of the list that will be assigned.\n\n\nCode\nnumbers = [17, 123, 42, 7]\nnumbers[1] = 5\nnumbers\n\n\n[17, 5, 42, 7]\n\n\nThe first element of numbers, which used to be 123, is now 5.\nAll in all, you can think of a list as a relationship between indices and elements. This relationship is called a mapping; each index “maps to” one of the elements.\n\n\n\n5.1.2 List Concatenation and List Replication\nLists can be concatenated and replicated just like strings. The + operator combines two lists to create a new list and the * operator can be used with a list and an integer value to replicate the list.\n\n\nCode\n[1, 2, 3] + ['A', 'B', 'C']\n\n\n[1, 2, 3, 'A', 'B', 'C']\n\n\n\n\nCode\n['X', 'Y', 'Z'] * 3\n\n\n['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']\n\n\n\n5.1.2.1 Removing Values from Lists with del Statements\nThe del statement will delete values at an index in a list. All values in the list after the deleted value will be moved up one index.\n\n\nCode\nt = ['a', 'b', 'c']\ndel t[1] # using index\nprint(t)\n\n\n['a', 'c']\n\n\n\n\n\n5.1.3 List traversal\nIn Chapter 2, you have learned about using for loops to execute a block of code a certain number of times. Technically, a for loop repeats the code block once for each item in a sequence.\n\n\nCode\nfor i in range(4):\n    print(i)\n\n\n0\n1\n2\n3\n\n\n\n\nCode\nprint(range(4))\nlist(range(4))\n\n\nrange(0, 4)\n\n\n[0, 1, 2, 3]\n\n\nThis is because the return value from range(4) is a sequence that Python considers similar to [0, 1, 2, 3]. The following program has the same output as the previous one:\n\n\nCode\nfor i in [0, 1, 2, 3]:\n    print(i)\n\n\n0\n1\n2\n3\n\n\n\n\nCode\nfor subject in subjects: # subjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n  print(subject)\n\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\nThis works well if you only need to read the elements of the list. But you need the indices that you want to write or update the elements. A common way to do that is to combine the functions range() and len():\nA common Python technique is to use range(len(someList)) with a for loop to iterate over the indexes of a list.\n\n\nCode\nfor i in range(len(numbers)): # numbers = [17, 5, 42, 7]\n  print(i, numbers[i])\n  numbers[i] = numbers[i]**2\n\nprint(numbers)\n\n\n0 17\n1 5\n2 42\n3 7\n[289, 25, 1764, 49]\n\n\nThis loop traverses the list and prints each element. len() returns the number of elements in the list. range() returns a list of indices from 0 to n − 1, where n is the length of the list. Each time through the loop, i gets the index of the next element. This is handy since it will iterate through all the indexes, no matter how many items it contains.\n\n5.1.3.1 The in and not in Operators\nYou can determine whether an object is or isn’t in a list with the in and not in operators. These expressions will evaluate to a Boolean value.\n\n\nCode\nprint('howdy' in ['hello', 'hi', 'howdy', 'heyas'])\nprint('English' not in subjects)\n\n\nTrue\nTrue\n\n\n\n\n5.1.3.2 Using the enumerate() Function with Lists\nInstead of using the range(len(someList)) technique with a for loop to obtain the integer index of the items in the list, you can call the enumerate() function instead. On each iteration of the loop, enumerate() will return two values: the index of the item and the item itself.\n\n\nCode\nnumbers = [17, 5, 42, 7]\n\nfor i, number in enumerate(numbers): \n  print(i, number)\n  numbers[i] = number**2\n\nprint(numbers)\n\n\n0 17\n1 5\n2 42\n3 7\n[289, 25, 1764, 49]\n\n\n\n\n5.1.3.3 Loop in Multiple Lists with zip()\nBuilt-in function zip() enables you to iterate over multiple sequences of data at the same time. The function receives as arguments any number of sequences and returns an iterator that produces tuples containing the elements at the same index in each.\n\n\nCode\nnames = ['Bob', 'Sue', 'Amanda']\ngrade_point_averages = [3.5, 4.0, 3.75] \n\nfor name, gpa in zip(names, grade_point_averages):\n    print('Name=', name, 'GPA=', gpa)\n\n\nName= Bob GPA= 3.5\nName= Sue GPA= 4.0\nName= Amanda GPA= 3.75\n\n\nThe above snippet call zip() to produces the tuples ('Bob', 3.5), ('Sue', 4.0) and ('Amanda', 3.75) consisting of the elements at index 0, 1 and 2 of each list, respectively. Note that we unpack (which we will elaborate later on) each tuple into name and gpa and display them.\n\n\nCode\nlist(zip(names, grade_point_averages))\n\n\n[('Bob', 3.5), ('Sue', 4.0), ('Amanda', 3.75)]\n\n\n\n\n\n5.1.4 Methods of the list\nA method, introduced in Chapter 1, is the same as a function, except it is “called on” an object. For example, if a list object were stored in spam, you would call the index() list method on that list like so: spam.index('hello'). The method part comes after the object, separated by a period.\nEach data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a list.\n\n5.1.4.1 Adding elements to Lists with the append() and insert() Methods\nappend() adds a new element to the end of a list:\n\n\nCode\nt = ['a', 'b', 'c']\nt.append('d')\nt # in-place operation!\n\n\n['a', 'b', 'c', 'd']\n\n\nThe previous append() method call adds the argument to the end of the list. The insert() method can insert an element at any index in the list. The first argument to insert() is the index for the new value, and the second argument is the new value to be inserted.\n\n\nCode\nt = ['a', 'b', 'c']\nt.insert(1,'e')\nt # in-place operation!\n\n\n['a', 'e', 'b', 'c']\n\n\n\nNotice that the code is t.append('d') and t.insert(1, 'e'), not t = t.append('d') and t = t.insert(1, 'e'). In fact, the return value of append() and insert() is None, so you definitely wouldn’t want to store this as the new variable value. Rather, the list is modified in-place.\n\nMethods belong to a single data type. The append() and insert()methods are list methods and can be called only on list object, not on other objects such as strings or integers.\n\n\nCode\neggs = 'hello'\neggs.append('world')\n\n\nAttributeError: 'str' object has no attribute 'append'\n\n\n\n\n5.1.4.2 Adding all the elements of a List to the end of List with the extend() Methods\nUse list method extend() to add all the elements of another sequence to the end of a list:\n\n\nCode\ncolor_names = ['orange', 'yellow', 'green']\ncolor_names.extend(['indigo', 'violet']) # equivalent to color_names += ['indigo', 'violet']\n\n\n\n\nCode\ncolor_names\n\n\n['orange', 'yellow', 'green', 'indigo', 'violet']\n\n\n\n\n5.1.4.3 Removing elements from Lists with the remove() Method\nThe remove() method will pass the object to be removed from the list when it is called:\n\n\nCode\nspam = ['cat', 'bat', 'rat', 'elephant']\nspam.remove('bat')\nprint(spam)\n\n\n['cat', 'rat', 'elephant']\n\n\n\nThe del statement is good to use when you know the index of the element you want to remove from the list. The remove() method is useful when you know the element you want to remove from the list.\n\n\n\n5.1.4.4 Sorting the elements in a List with the sort() Method\nLists of numbers or lists of strings can be sorted with the sort() method:\n\n\nCode\nspam = [2, 5, 3.14, 1, -7]\nspam.sort() # The default behavior is sorting in ascending order\nprint(spam)\n\nspam = ['ants', 'cats', 'dogs', 'badgers', 'Elephants']\nspam.sort()\nprint(spam)\n\n\n[-7, 1, 2, 3.14, 5]\n['Elephants', 'ants', 'badgers', 'cats', 'dogs']\n\n\nNote that sort() uses “ASCII order” rather than alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z.\nYou can also pass True for the reverse keyword argument to have sort() sort the values in reverse order.\n\n\nCode\nspam.sort(reverse=True) # Sort in descending order\nprint(spam)\n\n\n['dogs', 'cats', 'badgers', 'ants', 'Elephants']\n\n\n\n\n5.1.4.5 Searching an element in a List with the index() Method\nList objects have an index() method that accepts an argument, and if that argument exists in the list, the index of the argument is returned. If the argument isn’t in the list, then Python produces a ValueError error.\n\n\nCode\nspam = ['hello', 'hi', 'howdy', 'heyas']\nspam.index('hi')\n\n\n1\n\n\n\n\nCode\nspam = ['hello', 'hi', 'howdy', 'heyas']\nspam.index('world')\n\n\nValueError: 'world' is not in list\n\n\nWhen there are duplicates of the elements in the list, the index of its first appearance is returned.\n\n\nCode\nspam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka']\nspam.index('Pooka')\n\n\n1\n\n\n\n\n\n5.1.5 Numerical functions for list\nThere are a number of built-in functions that can be used on lists that allow you to quickly look through a list without writing your own loops:\n\n\nCode\nnums = [3, 41, 12, 9, 74, 15]\nprint(len(nums))\n\n\n6\n\n\n\n\nCode\nprint(max(nums))\nprint(min(nums))\nprint(sum(nums))\n\n\n74\n3\n154\n\n\nCheck out https://docs.python.org/3/tutorial/datastructures.html#more-on-lists for more methods!\n\n\n5.1.6 List Comprehensions\nConsider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10).\n\n\nCode\nsquares = []\nfor value in range(1,11):\n    squares.append(value**2)\nprint(squares)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nBut a list comprehension allows you to generate this same list in just one line of code. A list comprehension combines the for loop and the creation of new elements into one line, and automatically appends each new element!\n\n\nCode\nsquares = [value**2 for value in range(1, 11)]\nprint(squares)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nTo use this syntax\n\nBegin with a descriptive name for the list, such as squares.\nNext, open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression is value**2\nThen, write a for loop to generate the numbers you want to feed into the expression and close the square brackets. In this example, the for loop iterates value in range(1, 11), which feeds the values 1 through 10 into the expression value**2.\n\nNote that no colon is used at the end of the for statement.\n\nThe syntax of list comprehension is similar to the set-builder notation. For instance, preivous example is similar to \\(\\{x^2 | x \\in \\{1,2,...,10\\}\\}\\)\n\nAnother common operation is filtering elements to select only those that match a condition. This typically produces a list with fewer elements than the data being filtered. To do this in a list comprehension, use the if clause. The following includes in list1 only the even values produced by the for clause:\n\n\nCode\nlist1 = [item for item in range(1, 11) if item % 2 == 0]\nlist1\n\n\n[2, 4, 6, 8, 10]\n\n\n\n5.1.7 Exercise 1: Bulls and Cows (or 1A2B) is a code-breaking game. The numerical version of the game is usually played with four digits. On a sheet of paper, the players each write a 4-digit secret number. The digits must all be different. Then, in turn, the players try to guess their opponent’s number, which gives the number of matches. If the matching digits are in their right positions, they are “bulls” (A). If they are in different positions, they are “cows” (B). For example, if the secret number is 4271 and our guess is 1234, then we should get 1 bull and 2 cows. (The bull is “2”, the cows are “4” and “1”.). Please complete the following game design, that the computer will generate a 4-digit number, and we must write a function to read the user’s 4-digit inputs and check the user’s guess against the secret number. Finally, return the message XAXB to the user.\n\n\n\n\n\nsource: https://en.wikipedia.org/wiki/Bulls_and_Cows\n\n\n\nCode\n%%writefile 1A2B.py\n\nimport random\n\n# Generate a random four-digit number\ndef generate_number():\n    digits = list(range(10))\n    random.shuffle(digits) # randomly shuffle the list!\n    return digits[:4]\n\n# Check the user's guess against the secret number\ndef check_guess(guess, secret):\n    # Note that both guess and secret are lists!\n    a = 0 # number of correct digits in the correct position\n    b = 0 # number of correct digits in the wrong position\n    for i,j in zip(__,__): # Iterate over two lists\n        if i == j:\n            a += 1\n        elif __________: # Use operator to determine whether the digit is in secret number or not\n            b += 1\n    return a, b\n\n# Play the game\nprint(\"Welcome to 1A2B!\")\nprint(\"I'm thinking of a four-digit number. Can you guess it?\")\nsecret = generate_number()\nguesses = 0\nwhile True:\n    guess = input(\"Enter your guess, enter 'quit' to give up: \")\n    if guess == 'quit':\n        print(\"The secret number is\", secret)\n        break\n    elif len(guess) != 4 or not guess.isdigit():\n        print(\"Invalid guess. Please enter a four-digit number.\")\n        continue\n    guess = _______ # Use list comprehension to get the 4-digit guess list\n    guesses += 1\n    result = check_guess(guess, secret)\n    print(result[0],'A', result[1], 'B', sep=\"\")\n    if result[0] == 4:\n        print(\"Congratulations, you guessed the number in\", guesses, \"guesses!\")\n        break\n\n\nOverwriting 1A2B.py\n\n\n\n\n5.1.8 Sequence Data Types\nLists aren’t the only data types that represent ordered sequences of values. For example, strings and lists are similar if you consider a string to be a “list” of single text characters. The Python sequence data types include lists, strings, range objects returned by range(), and tuples. Many of the things you can do with lists can also be done with strings and other values of sequence types: indexing; slicing; and using them with for loops, with len(), and with the in and not in operators.\n\n\nCode\n'a' in 'apple'\n\n\nTrue\n\n\n\n\n5.1.9 Mutable and Immutable Data Types\nBut lists and strings are different in an important way. A list object is a mutable data type: it can have elements added, removed, or changed. However, a string is immutable: it cannot be changed. Trying to reassign a single character in a string results in a TypeError error:\n\n\nCode\nname = 'Zophie a cat'\nname[7] = 't'\n\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "04_Lists_tuples.html#tuples",
    "href": "04_Lists_tuples.html#tuples",
    "title": "5  Lists and Tuples",
    "section": "5.2 Tuples",
    "text": "5.2 Tuples\nA tuple is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers. The important difference is that tuples are immutable.\n\nIt is similar to the tuple you encounter in math\n\nAlthough it is not necessary, it is common to enclose tuples in parentheses to help us quickly identify tuples when we look at Python code:\n\n\nCode\ntype(())\n\n\ntuple\n\n\n\n\nCode\nt = ('a', 'b', 'c', 'd', 'e')\ntype(t)\n\n\ntuple\n\n\nTo create a tuple with a single element, you have to include the final comma or use the tuple() function:\n\n\nCode\nt1 = ('a',)\nprint(type(t1))\nt2 = ('a')\nprint(type(t2))\n\n\n&lt;class 'tuple'&gt;\n&lt;class 'str'&gt;\n\n\nIf the argument of tuple() is a sequence (string, list, or tuple), the result is a tuple with the elements of the sequence:\n\n\nCode\nt = tuple('nsysu')\nt\n\n\n('n', 's', 'y', 's', 'u')\n\n\nMost list operators also work on tuples. The bracket operator indexes an element:\n\n\nCode\nprint(t[0])\nprint(t[1:3])\n\n\nn\n('s', 'y')\n\n\nBut if you try to modify one of the elements of the tuple, you get an error:\n\n\nCode\nt[0] = 'A'\n\n\nTypeError: 'tuple' object does not support item assignment\n\n\nYou can use tuples to convey to anyone reading your code that you don’t intend for that sequence of values to change. Use a tuple if you need an ordered sequence of values that never changes.\n\n5.2.1 Unpacking Sequences\nWe have seen the multiple assignment trick in the previous chapter (which is actually unpacking the tuple). In fact, you can unpack any sequence’s elements by assigning the sequence to a comma-separated list of variables.\n\n\nCode\nstudent_tuple = ('Amanda', [98, 85, 87])\n\n\n\n\nCode\nfirst_name, grades = student_tuple\nprint(first_name, grades)\n\n\nAmanda [98, 85, 87]\n\n\nUnpacking is widely used to return multiple values in a function:\n\n\nCode\ndef total_ave(grade):\n    total = sum(grade)\n    ave = total/len(grade)\n    return total, ave\n\ngrades = [85, 70, 100, 90]\ntotal, ave = total_ave(grades)\n\nprint(total, ave)\n\n\n345 86.25"
  },
  {
    "objectID": "04_Lists_tuples.html#references",
    "href": "04_Lists_tuples.html#references",
    "title": "5  Lists and Tuples",
    "section": "5.3 References",
    "text": "5.3 References\nTechnically, in Python, variables store references to the computer memory locations where the values are stored.\n\n\nCode\nspam = 42\ncheese = spam\nprint(id(cheese), id(spam))\nspam = 100\nprint(id(cheese), id(spam))\n\nspam, cheese\n\n\n140731993439296 140731993439296\n140731993439296 140731993441152\n\n\n(100, 42)\n\n\nWhen you assign 42 to the spam variable, you are actually creating the 42 value in the computer’s memory and storing a reference (address) to it in the spam variable. When you copy the value in spam and assign it to the variable cheese, you are actually copying the reference. Both the spam and cheese variables refer to the 42 value in the computer’s memory. When you later change the value in spam to 100, you’re creating a new 100 value and storing a reference to it in spam. This doesn’t affect the value in cheese. Integers are immutable values that don’t change; changing the spam variable is actually making it refer to a completely different value in memory.\nYou can use id() function to verify this behavior. In CPython (the most widely used implementation of Python), the identifier returned by id() is actually the memory address of the object, represented as a Python integer. All values in Python have a unique identity (address) that can be obtained with the id() function.\nBut lists don’t work this way, because list are mutable:\n\n\nCode\nspam = [0, 1, 2, 3, 4, 5]\ncheese = spam        # The reference is being copied, not the list.\nprint(id(cheese), id(spam))\ncheese[1] = 'Hello!' # This changes the list value.\nprint(id(cheese), id(spam))\n\nspam, cheese\n\n\n2790646437440 2790646437440\n2790646437440 2790646437440\n\n\n([0, 'Hello!', 2, 3, 4, 5], [0, 'Hello!', 2, 3, 4, 5])\n\n\nUsing boxes as a metaphor for variables, the following shows what happens when a list is assigned to the spam variable.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nThen, the reference in spam is copied to cheese. Only a new reference was created and stored in cheese, not a new list. Note how both references refer to the same list.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nWhen you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nYou may be wondering why the weird behavior with mutable lists in the previous section doesn’t happen with immutable values like integers or strings. Let us elaborate on this topics.\nLike integer, 'Hello' is a string which is immutable and cannot be changed. If you “change” the string in a variable, a new string object is being made at a different place in memory, and the variable refers to this new string.\n\n\nCode\nbacon = 'Hello'\nprint(id(bacon))\nbacon = bacon + 'World'\nprint(id(bacon))\n\n\n2790646417200\n2790646416176\n\n\nHowever, lists can be modified because they are mutable objects. The append() method doesn’t create a new list object; it changes the existing list object. We call this “modifying the object in-place.”\n\n\nCode\neggs = ['Hello'] # This creates a new list.\nprint(id(eggs))\neggs.append('World')  # append() modifies the list \"in place\".\nprint(id(eggs))       # eggs still refers to the same list as before.\n\n\n2790646499648\n2790646499648\n\n\nIf two variables refer to the same list (like spam and cheese in the previous section) and the list itself changes, both variables are affected because they both refer to the same list. The append(), remove(), sort(), reverse(), and other list methods modify their lists in place.\n\nPython’s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don’t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\n\n5.3.1 Passing References\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries, which we will describe in the next chapter), this means a copy of the reference is used for the parameter.\n\n\nCode\ndef eggs(someParameter):\n    someParameter.append('Hello')\n\nspam = [1, 2, 3]\neggs(spam)\nprint(spam)\n\n\n[1, 2, 3, 'Hello']\n\n\nNotice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place directly. Even though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.\nFor immutable types string and integers, we will create a new object in the function when we modify someParameter. Therefore, the original value will not be modified after the loop.\n\n\nCode\ndef eggs(someParameter):\n    print(id(someParameter))\n    someParameter = someParameter + \"world\" # This will create a new object and assign the new reference to someParameter\n    print(id(someParameter))\n\nspam = \"hello\"\nprint(id(spam))\neggs(spam)\nprint(spam)\n\n\n2790636340272\n2790636340272\n2790646431216\nhello\n\n\n\n\n5.3.2 The copy Module’s copy() and deepcopy() Functions\nPython provides a module named copy that provides both the copy() and deepcopy() functions. copy(), can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference.\n\n\nCode\nimport copy\n\nspam = ['A', 'B', 'C', 'D']\nprint(id(spam))\ncheese = copy.copy(spam)\nprint(id(cheese)) # cheese is a different list with different identity.\ncheese[1] = 42\n\nspam, cheese\n\n\n2790645442048\n2790645869632\n\n\n(['A', 'B', 'C', 'D'], ['A', 42, 'C', 'D'])\n\n\nNow the spam and cheese variables refer to separate lists, which is why only the list in cheese is modified when you assign 42 at index 1.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\n\nIf the list you need to copy contains another list, then use the copy.deepcopy() function instead of copy.copy(). The deepcopy() function will copy these inner lists as well.\n\n\n5.3.3 Exercise 2: Here, we will simulate the process of a simple card game. The game is played with a standard deck of 52 cards, and we will randomly select 40 cards and divide them evenly between two players. Each player gets a hand of 20 cards. The goal of the game is to collect pairs of cards with the same rank (e.g., two aces, two kings, etc.). The player with the most pairs at the end of the game wins.\n\n\n\n\n\n\nCode\nimport random\n\n# Write a function create_deck that creates a list of tuples representing a standard deck of 52 cards. \n# Each tuple should contain two elements: the rank (e.g., \"ace\", \"king\", etc.) \n# and the suit (e.g., \"hearts\", \"spades\", etc.). \ndef create_deck():\n    ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n    suits = ['♣', '♦', '♥', '♠']\n    deck = [(rank, suit) ______] # Use list comprehension to create the deck.\n    return deck\n\n# A function that takes the deck as a parameter and returns two lists, each containing 26 randomly-selected \n# cards from the deck. Use list slicing and the random module to implement this function.\ndef deal_cards(deck):\n    deck = deck[:40]\n    random.shuffle(deck)\n    hand1 = _____  # Split it into 20 cards in each using slice\n    hand2 = _____\n    return hand1, hand2\n\n# Write a function find_pairs that takes a list of cards as a parameter and returns a list of tuples \n# representing the pairs of cards in the list. A pair is defined as two cards with the same rank. \ndef find_pairs(cards):\n    pairs = []\n    for i, card1 in enumerate(cards):\n        for j, card2 in enumerate(cards):\n            if i != j and card1[0] == card2[0] and card1 not in [pair[0] for pair in pairs]\\\n                and card1 not in [pair[1] for pair in pairs] and card2 not in [pair[0] for pair in pairs]\\\n                and card2 not in [pair[1] for pair in pairs]:\n                pairs._____((card1, card2)) # Use a method from the list to add it into the pairs\n    return pairs\n\ndeck = create_deck()\nhand1, hand2 = deal_cards(deck)\npairs1 = find_pairs(hand1)\npairs2 = find_pairs(hand2)\n\nprint(pairs1)\nprint(pairs2)\nif ___________: # Compare the length of the two lists\n    print(\"Player 1 wins!\")\nelif _____________:\n    print(\"Player 2 wins!\")\nelse:\n    print(\"It's a tie!\")\n\n\nLists are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later on, you will see programs using lists to do things that would be difficult or impossible to do without them.\nLists are a sequence data type that is mutable, meaning that their contents can change. Tuples and strings, though also sequence data types, are immutable and cannot be changed. A variable that contains a tuple or string value can be overwritten with a new tuple or string value, but this is not the same thing as modifying the existing value in place — like, say, the append() or remove() methods do on lists. Because tuples are immutable, they don’t provide methods like sort() and reverse(), which modify existing lists. However Python provides the built-in functions sorted() and reversed(), which take any sequence as a parameter and return a new sequence with the same elements in a different order.\nVariables do not store list objects directly; they store references to lists. This is an important distinction when you are copying variables or passing lists as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the list might impact another variable in your program. You can use copy() or deepcopy() if you want to make changes to a list in one variable without modifying the original list. It is noted that slicing also create a new list object."
  },
  {
    "objectID": "05_Dictionaries_sets.html#dictionaries",
    "href": "05_Dictionaries_sets.html#dictionaries",
    "title": "6  Other collections - Dictionaries and Sets",
    "section": "6.1 Dictionaries",
    "text": "6.1 Dictionaries\nWe’ve discussed three built-in sequence collections — strings, lists and tuples. Now, we consider the built-in non-sequence collections — dictionaries and sets. A dictionary is an unordered collection which stores key–value pairs that map immutable keys to values, just as a conventional dictionary maps words to definitions. A set is an unordered collection of unique immutable elements.\nLike a list, a dictionary is a mutable collection of many values, but more general. In a list, the index positions have to be integers; in a dictionary, the indices can be any immutable data type. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. Each key maps to a value. The association of a key and a value is called a key-value pair or sometimes an item.\nA dictionary’s keys must be immutable (such as strings, integers or tuples) and unique (that is, no duplicates). However, multiple keys can have the same value.\n\n\n\n\nsource: https://pynative.com/python-dictionaries/\n\n\nIt is noted that as of Python 3.7, dictionary items maintain the order in which they are inserted into the dictionary. However, dictionaries are considered unordered collections and do not write code that depends on the order of the key–value pairs.\n\nAs an example, we’ll build a dictionary that maps from subjects to grades, so the keys are string while the values are integers. The function dict creates a new dictionary with no items.\n\n\nCode\ntype({}) # {} also treated as dict in Python\n\n\ndict\n\n\n\n\nCode\ngrade = dict()\ntype(grade), grade\n\n\n(dict, {})\n\n\nTo add/update items to the dictionary, you can again use subscript operator (square brackets):\n\n\nCode\ngrade['calculus'] = 85 # Key:'calculus', value: 85\nprint(grade) # Note that key and value are separate by colon\n\n\n{'calculus': 85}\n\n\nYou can create a dictionary that contains multiple items by enclosing in curly braces, {}, a comma-separated list of key–value pairs, each of the form key:value.\n\n\nCode\ngrade = {'calculus':85, 'introduction to mathematics':80, 'computer programming':90, 'linear algebra':95}\ngrade\n\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95}\n\n\nYou can store them using separate lists for subjects and scores, but the following update and maintenance will become tedious:\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nscore = [85, 80, 90, 95]\nYou can now use the keys to look up the corresponding values:\n\n\nCode\nprint(grade['computer programming'])\n\n\n90\n\n\nYou can obtain the number of items using len()\n\n\nCode\nlen(grade)\n\n\n4\n\n\n\nNote that you can’t access items in them using integer indexes like grade[0] because it is unordered collections. (Consider the case when you use 4, 2, 1, 0 as the keys). Therefore, you can’t use slice syntax for dictionaries.\n\nTrying to access a key that does not exist in a dictionary will result in a KeyError error message, much like a list’s “out-of-range” IndexError error message.\n\n\nCode\ngrade['English']\n\n\nKeyError: 'English'\n\n\nTo add or delete an entry, it is similar to list\n\n\nCode\ngrade['English'] = 100\ngrade\n\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95,\n 'English': 100}\n\n\nYou can delete a key–value pair from a dictionary with the del statement:\n\n\nCode\ndel grade['English']\ngrade\n\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95}\n\n\n\n6.1.1 The keys(), values(), and items() Methods\nThere are three dictionary methods that will return list-like values of the dictionary’s keys, values, or both keys and values: keys(), values(), and items(). The values returned by these methods are not true lists, but these data types (dict_keys, dict_values, and dict_items, respectively) can be used in for loops (Just like range object)!\nIf you want a true list from one of these methods, pass its list-like return value to the list() function\n\n\nCode\nsubject = list(grade.keys())\nscore = list(grade.values())\nprint(subject)\nprint(score)\n\n\n['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n[85, 80, 90, 95]\n\n\n\n\nCode\nfor v in grade.values():\n    print(v)\n\n\n85\n80\n90\n95\n\n\nHere, a for loop iterates over each of the values in the grade dictionary. A for loop can also iterate over the keys:\n\n\nCode\nfor k in grade.keys():\n    print(k)\n\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\n\n\nCode\nfor k in grade:\n    print(k)\n\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\n\nNote that by default, it will traverse over the keys!\n\nDictionaries have a method called items() that returns a list of tuples, where each tuple is a key-value pair:\n\n\nCode\nlist(grade.items())\n\n\n[('calculus', 85),\n ('introduction to mathematics', 80),\n ('computer programming', 90),\n ('linear algebra', 95)]\n\n\nCombining items(), multiple assignment, and for, you can see a nice code pattern for traversing the keys and values of a dictionary in a single loop:\n\n\nCode\nfor key, val in grade.items():\n    print(key,val)\n\n\ncalculus 85\nintroduction to mathematics 80\ncomputer programming 90\nlinear algebra 95\n\n\n\n6.1.1.1 Checking Whether a Key or Value Exists in a Dictionary\nRecall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary\n\n\nCode\n'calculus' in grade, 'English' in grade.keys(), 85 in grade.values() \n\n\n(True, False, True)\n\n\n\nAgain, it will check keys by default. Therefore, in the previous example, 'calculus' in grade is essentially a shorter version of writing 'calculus' in grade.keys(). This is always the case: if you ever want to check whether a value is (or isn’t) a key in the dictionary, you can simply use the in (or not in) keyword with the dictionary itself.\n\n\n\n6.1.1.2 Retrieve value uisng get() Method\n\n\nCode\nif 'English' in grade:\n    e_score= grade['English']\n\n\nIt’s tedious to check whether a key exists in a dictionary before accessing that key’s value. Fortunately, dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\n\nCode\npicnicItems = {'apples': 5, 'cups': 2}\nprint('I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.') \nprint('I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.')\n\n\nI am bringing 2 cups.\nI am bringing 0 eggs.\n\n\nBecause there is no ‘eggs’ key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get(), the code would have caused a KeyError message\n\n\nCode\npicnicItems = {'apples': 5, 'cups': 2}\n'I am bringing ' + str(picnicItems['eggs']) + ' eggs.'\n\n\nKeyError: 'eggs'\n\n\n\n\n6.1.1.3 Update value using setdefault() Method\nYou’ll often have to set a value in a dictionary for a certain key only if that key does not already have a value. The code looks something like this:\n\n\nCode\nspam = {'name': 'Pooka', 'age': 5}\nif 'color' not in spam:\n    spam['color'] = 'black'\n\n\nThe setdefault() method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist.\nThe setdefault() method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a string.\n\n\nCode\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    if character not in count:\n        count[character] = 0\n    count[character] = count[character] + 1\n\nprint(count)    \n\n\n{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}\n\n\n\n\nCode\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    count.setdefault(character, 0)\n    count[character] = count[character] + 1\n\nprint(count)    \n\n\n{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}\n\n\nYou can view the execution of this program at https://autbor.com/setdefault. The program loops over each character in the message variable’s string, counting how often each character appears. The setdefault() method ensures that the key is in the count dictionary (with a default value of 0) so the program doesn’t throw a KeyError error when count[character] = count[character] + 1 is executed!\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time.\n\n\n\n6.1.2 Pretty Printing\nIf you import the pprint module into your programs, you’ll have access to the pprint() function that will “pretty print” a dictionary’s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides.\n\n\nCode\nimport pprint\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    count.setdefault(character, 0)\n    count[character] = count[character] + 1\n\npprint.pprint(count)\n\n\n{' ': 13,\n ',': 1,\n '.': 1,\n 'A': 1,\n 'I': 1,\n 'a': 4,\n 'b': 1,\n 'c': 3,\n 'd': 3,\n 'e': 5,\n 'g': 2,\n 'h': 3,\n 'i': 6,\n 'k': 2,\n 'l': 3,\n 'n': 4,\n 'o': 2,\n 'p': 1,\n 'r': 5,\n 's': 3,\n 't': 6,\n 'w': 2,\n 'y': 1}\n\n\nYou can view the execution of this program at https://autbor.com/pprint/. This time, when the program is run, the output looks much cleaner, with the keys sorted. The pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries.\n\n6.1.2.1 Dictionary Comprehensions\nDictionary comprehensions provide a convenient notation for quickly generating dictionaries, often by mapping one dictionary to another. For example, in a dictionary with unique values, you can reverse the key–value pairs:\n\n\nCode\nmonths = {'January': 1, 'February': 2, 'March': 3}\n\n\n\n\nCode\nmonths2 = {number:name for name, number in months.items()}\nmonths2\n\n\n{1: 'January', 2: 'February', 3: 'March'}\n\n\nCurly braces delimit a dictionary comprehension, and the expression to the left of the for specifies a key–value pair of the form key:value. The comprehension iterates through months.items(), unpacking each key–value pair tuple into the variables name and number. The expression number:name reverses the key and value, so the new dictionary maps the month numbers to the month names.\nA dictionary comprehension also can map a dictionary’s values to new values. The following comprehension converts a dictionary of names and lists of grades into a dictionary of names and grade-point averages. The variables k and v commonly mean key and value:\n\n\nCode\ngrades = {'Sue': [98, 87, 94], 'Bob': [84, 95, 91]}\n\n\n{'Bob': [84, 95, 91], 'Sue': [98, 87, 94]}\n\n\n\n\nCode\ngrades2 = {k:sum(v)/len(v) for k, v in grades.items()}\ngrades2\n\n\n{'Sue': 93.0, 'Bob': 90.0}\n\n\n\nNote the above is nested structure, with a list in a dictionary!\n\n\n\n\n6.1.3 Using Data Structures to Model Real-World Things\nA tic-tac-toe board looks like a large hash symbol (#) with nine slots that can each contain an X, an O, or a blank. To represent the board with a dictionary, you can assign each slot a key, as shown in below:\n\n\n\n\n1\n2\n3\n\n\n\n\n4\n5\n6\n\n\n7\n8\n9\n\n\n\n\nYou can use string values to represent what’s in each slot on the board: ‘X’, ‘O’, or ’ ’ (a space). Thus, you’ll need to store nine strings. You can use a dictionary of values for this. The string value with the key ‘3’ can represent the top-right corner, the string value with the key ‘7’ can represent the bottom-left corner, the string value with the key ‘5’ can represent the middle, and so on. This dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named board.\n\n\nCode\nboard = {'1': ' ', '2': ' ', '3': ' ',\n         '4': ' ', '5': ' ', '6': ' ',\n         '7': ' ', '8': ' ', '9': ' '}\n\n\nA board where player O has won by placing Os across the top might look like this:\n\n\nCode\nboard = {'1': 'O', '2': 'O', '3': 'O',\n         '4': 'X', '5': 'X', '6': ' ',\n         '7': ' ', '8': ' ', '9': 'X'}\nprint(board)\n\n\n{'1': 'O', '2': 'O', '3': 'O', '4': 'X', '5': 'X', '6': ' ', '7': ' ', '8': ' ', '9': 'X'}\n\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter5/\n\nOf course, the player should see only what is printed to the screen, not the contents of variables. Let’s create a function to print the board dictionary onto the screen:\n\n\nCode\ndef printBoard(board):\n    \"\"\"\n    The function that prints out the board in a square shape\n    \"\"\"\n    print(board['1'] + '|' + board['2'] + '|' + board['3'])\n    print('-+-+-')\n    print(board['4'] + '|' + board['5'] + '|' + board['6'])\n    print('-+-+-')\n    print(board['7'] + '|' + board['8'] + '|' + board['9'])\n\nprintBoard(board)\n\n\nO|O|O\n-+-+-\nX|X| \n-+-+-\n | |X\n\n\nThe printBoard() function can handle any tic-tac-toe data structure you pass it!\nNow let’s add code that allows the players to enter their moves.\n\n\nCode\nboard = {'1': ' ', '2': ' ', '3': ' ',\n         '4': ' ', '5': ' ', '6': ' ',\n         '7': ' ', '8': ' ', '9': ' '}\n\nboard['1'] = 'O'  # Update the board\nprintBoard(board)\nboard['5'] = 'X' \nprintBoard(board)\n\n\nO| | \n-+-+-\n | | \n-+-+-\n | | \nO| | \n-+-+-\n |X| \n-+-+-\n | | \n\n\nWe can also check whether player has won the game or not using the following code:\n\n\nCode\np = 'O' # Check whether 'O' has won the game or not\n\n((board['1'] == board['2'] == board['3'] == p) or  # Across top\n(board['4'] == board['5'] == board['6'] == p) or  # Across middle\n(board['7'] == board['8'] == board['9'] == p) or  # Across boardottom\n(board['1'] == board['4'] == board['7'] == p) or  # Down left\n(board['2'] == board['5'] == board['8'] == p) or  # Down middle\n(board['3'] == board['6'] == board['9'] == p) or  # Down right\n(board['3'] == board['5'] == board['7'] == p) or  # Diagonal\n(board['1'] == board['5'] == board['9'] == p))  # Diagonal\n\n\nFalse\n\n\n\nNote that by enclosing the condiations with (), we do not have to add \\ for multipline commands.\n\n\n\n6.1.4 &gt; Exercise 1: Tic-tac-toe is a classic pencil-and-paper game played on a 3 × 3 grid. Players take turns placing their ‘X’ or ‘O’ marks, trying to get three in a row. Try to complete the following game design by complete three functions getBlankBoard(), isValidSpace() and isBoardFull().\n\n\nCode\n%%writefile ttt.py\n\ndef printBoard(board):\n    \"\"\"\n    The function that prints out the board in a square shape\n    \"\"\"\n    print(board['1'] + '|' + board['2'] + '|' + board['3'])\n    print('-+-+-')\n    print(board['4'] + '|' + board['5'] + '|' + board['6'])\n    print('-+-+-')\n    print(board['7'] + '|' + board['8'] + '|' + board['9'])\n\n\ndef updateBoard(board, space, mark):\n    \"\"\"Sets the space on the board to mark.\"\"\"\n    board[space] = mark\n\ndef isWinner(board, player):\n    \"\"\"Return True if player is a winner on this TTTBoard.\"\"\"\n    # Shorter variable names used here for readablility:\n    b, p = board, player\n    # Check for 3 marks across 3 rows, 3 columns, and 2 diagonals.\n    return ((b['1'] == b['2'] == b['3'] == p) or  # Across top\n            (b['4'] == b['5'] == b['6'] == p) or  # Across middle\n            (b['7'] == b['8'] == b['9'] == p) or  # Across bottom\n            (b['1'] == b['4'] == b['7'] == p) or  # Down left\n            (b['2'] == b['5'] == b['8'] == p) or  # Down middle\n            (b['3'] == b['6'] == b['9'] == p) or  # Down right\n            (b['3'] == b['5'] == b['7'] == p) or  # Diagonal\n            (b['1'] == b['5'] == b['9'] == p))    # Diagonal\n\ndef getBlankBoard():\n    \"\"\"Create a new, blank tic-tac-toe board.\"\"\"\n    # Map of space numbers: 1|2|3\n    #                       -+-+-\n    #                       4|5|6\n    #                       -+-+-\n    #                       7|8|9\n    # Keys are '1' through '9', the values are 'X', 'O', or ' ':\n    # Initialize all spaces of the board as blank string ' ' using loop or dictionary complehention\n    ALL_SPACES = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    ______________________________\n    return board\n\ndef isValidSpace(board, space):\n    \"\"\"Returns True if the space on the board is a valid space number (1-9)\n    and the space is blank.\"\"\"\n    ALL_SPACES = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    return ____________ and ________________\n\ndef isBoardFull(board):\n    \"\"\"Return True if every space on the board has been taken.\"\"\"\n    for v in ________:  # Traverse over the board to see if there is blank space\n        if v == ' ':\n            return False  # If any space is blank, return False.\n    return True  # No spaces are blank, so return True\n\n\n\n# The logic of the game\nprint('Welcome to Tic-Tac-Toe!')\ngameBoard = getBlankBoard()  # Create a TTT board dictionary.\ncurrentPlayer, nextPlayer = 'X', 'O'  # X goes first, O goes next.\n\nwhile True:  # Main game loop.\n    # 1. Display the board on the screen:\n    printBoard(gameBoard)\n\n    # 2. Keep asking the player until they enter a number 1-9:\n    move = None\n    while not isValidSpace(gameBoard, move):\n        print('What is ' + currentPlayer + '\\'s move? (1-9)')\n        move = input('&gt; ')\n    updateBoard(gameBoard, move, currentPlayer)  # Make the move.\n\n    # 3. Check if the game is over:\n    if isWinner(gameBoard, currentPlayer):  # Check for a winner.\n        printBoard(gameBoard)\n        print(currentPlayer + ' has won the game!')\n        break\n    elif isBoardFull(gameBoard):  # Check for a tie.\n        print(printBoard(gameBoard))\n        print('The game is a tie!')\n        break\n    # 4. Switch turns to the next player using multiple assignment:\n    currentPlayer, nextPlayer = nextPlayer, currentPlayer\nprint('Thanks for playing!')\n\n\nOverwriting ttt.py\n\n\n\n\n6.1.5 Nested Dictionaries and Lists\n\n6.1.5.1 A List of Dictionaries\nConsider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien:\n\n\nCode\nalien_0 = {'color': 'green', 'points': 5}\n\n\nThe alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a screen full of aliens. How can you manage a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien.\n\n\nCode\naliens = []\n# Make 30 green aliens.\nfor alien_number in range(30):\n    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}\n    aliens.append(new_alien)\n# Show the first 5 aliens.\nfor alien in aliens[:5]:\n    print(alien)\nprint(\"...\")\n# Show how many aliens have been created.\nprint(f\"Total number of aliens: {len(aliens)}\")\n\n\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n...\nTotal number of aliens: 30\n\n\nThese aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progresses. When it’s time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this:\n\n\nCode\nfor alien in aliens[:3]:\n    if alien['color'] == 'green':\n        alien['color'] = 'yellow'\n        alien['speed'] = 'medium'\n        alien['points'] = 10\n\naliens[:10]\n\n\n[{'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'}]"
  },
  {
    "objectID": "05_Dictionaries_sets.html#sets",
    "href": "05_Dictionaries_sets.html#sets",
    "title": "6  Other collections - Dictionaries and Sets",
    "section": "6.2 Sets",
    "text": "6.2 Sets\nA set is an unordered collection of unique values. Sets may contain only immutable objects, like strings, ints, floats and tuples that contain only immutable elements.\nThe following code creates a set of strings named colors:\n\n\nCode\ncolors = {'red', 'orange', 'yellow', 'green', 'red', 'blue'} # Similar to set in math\ncolors\n\n\n{'blue', 'green', 'orange', 'red', 'yellow'}\n\n\nNotice that the duplicate string 'red' was ignored (without causing an error). An important use of sets is duplicate elimination, which is automatic when creating a set. Also, the resulting set’s values may not be displayed in the same order as they were listed! Though the color names are displayed in sorted order, sets are unordered. You should not write code that depends on the order of their elements!\n\nNote that we also use curly bracket to create a set!\n\nThough sets are iterable, they are not sequences and do not support indexing and slicing with square brackets, [].\n\n\nCode\ncolors[0]\n\n\nTypeError: 'set' object is not subscriptable\n\n\nYou can determine the number of items in a set with the built-in len() function:\n\n\nCode\nlen(colors)\n\n\n5\n\n\nYou can check whether a set contains a particular value using the in and not in operators:\n\n\nCode\n'red' in colors, 'purple' not in colors\n\n\n(True, True)\n\n\nSets are iterable, so you can process each set element with a for loop:\n\n\nCode\nfor color in colors: # {'blue', 'green', 'orange', 'red', 'yellow'}\n    print(color, end=' ')\n\n\ngreen blue red yellow orange \n\n\nSets are unordered, so there’s no significance to the iteration order!\n\n6.2.1 Creating a Set with the Built-In set() Function\nYou can create a set from another collection of values by using the built-in set() function — here we create a list that contains several duplicate integer values and use that list as set’s argument:\n\n\nCode\nnumbers = list(range(10)) + list(range(5))\nnumbers\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4]\n\n\n\n\nCode\nset(numbers)\n\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nIf you need to create an empty set, you must use the set() function with empty parentheses, rather than empty braces, {}, which represent an empty dictionary:\n\n\nCode\nset()\n\n\nset()\n\n\n\nPython displays an empty set as set() to avoid confusion with Python’s string representation of an empty dictionary ({}).\n\n\n\n6.2.2 Set Operators and Methods\nSets are mutable — you can add and remove elements, but set elements must be immutable. Therefore, a set cannot have other sets as elements.\n\n\nCode\n{6,5,'a'}\n\n\n{5, 6, 'a'}\n\n\n\n\nCode\n{7,3,{3,5,7}}\n\n\nTypeError: unhashable type: 'set'\n\n\n\n\nCode\n{7,3,[3,5,7]}\n\n\nTypeError: unhashable type: 'list'\n\n\n\n6.2.2.1 Methods for Adding and Removing Elements\nHere we first discuss operators and methods that modify an existing set.\nSet method update() performs a union operation modifying the set in-place — the argument can be any iterable:\n\n\nCode\nnumbers = {1, 3, 5}     \nnumbers.update(range(10)) \nnumbers\n\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nSet method add() inserts its argument if the argument is not already in the set; otherwise, the set remains unchanged:\n\n\nCode\nnumbers.add(17)\nnumbers.add(3)\nnumbers\n\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 17}\n\n\nSet method remove() removes its argument from the set — a KeyError occurs if the value is not in the set:\n\n\nCode\nnumbers.remove(3)\nnumbers\n\n\n{0, 1, 2, 4, 5, 6, 7, 8, 9, 17}\n\n\n\n\nCode\nnumbers.remove(11)\n\n\nKeyError: 11\n\n\nMethod discard() also removes its argument from the set but does not cause an exception if the value is not in the set.\n\n\nCode\nnumbers.discard(1)\nnumbers\n\n\n{2, 4, 5, 6, 7, 8, 9, 17}\n\n\n\n\nCode\nnumbers.discard(0)\n\n\n\n\n\n6.2.3 Mathematical Set Operations\nThe operators and methods presented in this section each result in a new set!\n\n6.2.3.1 Union\nThe union of two sets is a set consisting of all the unique elements from both sets. You can calculate the union with the | operator or with the set union() method:\n\n\nCode\n{1, 3, 5} | {2, 3, 4}\n\n\n{1, 2, 3, 4, 5}\n\n\n\n\nCode\n{1, 3, 5}.union([20, 20, 3, 40, 40])\n\n\n{1, 3, 5, 20, 40}\n\n\nThe operands of the binary set operators, like |, must both be sets. The corresponding set methods may receive any iterable object as an argument — we passed a list. When a mathematical set method receives a non-set iterable argument, it first converts the iterable to a set, then applies the mathematical operation.\n\n\n6.2.3.2 Intersection\nThe intersection of two sets is a set consisting of all the unique elements that the two sets have in common. You can calculate the intersection with the & operator or with the set intersection() method:\n\n\nCode\n{1, 3, 5} & {2, 3, 4}\n\n\n{3}\n\n\n\n\nCode\n{1, 3, 5}.intersection([1, 2, 2, 3, 3, 4, 4])\n\n\n{1, 3}\n\n\n\n\n6.2.3.3 Difference\nThe difference between two sets is a set consisting of the elements in the left operand that are not in the right operand. You can calculate the difference with the - operator or with the set difference() method:\n\n\nCode\n{1, 3, 5} - {2, 3, 4}\n\n\n{1, 5}\n\n\n\n\nCode\n{1, 3, 5, 7}.difference([2, 2, 3, 3, 4, 4])\n\n\n{1, 5, 7}\n\n\n\n\n6.2.3.4 Symmetric Difference\nThe symmetric difference between two sets is a set consisting of the elements of both sets that are not in common with one another. You can calculate the symmetric difference with the ^ operator or with the set symmetric_difference method:\n\n\nCode\n{1, 3, 5} ^ {2, 3, 4}\n\n\n{1, 2, 4, 5}\n\n\n\n\nCode\n{1, 3, 5, 7}.symmetric_difference([2, 2, 3, 3, 4, 4])\n\n\n{1, 2, 4, 5, 7}\n\n\n\n\n6.2.3.5 Disjoint\nTwo sets are disjoint if they do not have any common elements. You can determine this with the set isdisjoint() method:\n\n\nCode\n{1, 3, 5}.isdisjoint({2, 4, 6})\n\n\nTrue\n\n\n\n\nCode\n{1, 3, 5}.isdisjoint({4, 6, 1})\n\n\nFalse\n\n\n\n\n\n6.2.4 Set Comprehensions\nLike dictionary comprehensions, you define set comprehensions in curly braces. Let’s create a new set containing only the unique even values in the list numbers:\n\n\nCode\nnumbers = [1, 2, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 10]\nevens = {item for item in numbers if item % 2 == 0}\n\nevens\n\n\n{2, 4, 6, 8, 10}\n\n\n\n\n6.2.5 Sorting the set and dictionary\nAs we mentioned last week, data types like tuples don’t provide methods like sort(). However Python provides the built-in function sorted(), which takes any sequence as a parameter and returns a new container with the same elements in a different order. You can also apply sorted to the set, but the returning container will be list.\n\n\nCode\nhelp(sorted)\n\n\nHelp on built-in function sorted in module builtins:\n\nsorted(iterable, /, *, key=None, reverse=False)\n    Return a new list containing all items from the iterable in ascending order.\n    \n    A custom key function can be supplied to customize the sort order, and the\n    reverse flag can be set to request the result in descending order.\n\n\n\n\n\nCode\nRANKS = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n\ndef rank_key(card):\n    return RANKS.index(card)\n\nori_set = {\"A\", \"2\", \"7\", \"4\", \"Q\"}\nprint(sorted(ori_set))\nsorted_list = sorted(ori_set, key=rank_key) \n# Each element will be replaced by the output of rank_key() and sorts!\nprint(sorted_list)\n\n\n['2', '4', '7', 'A', 'Q']\n['A', '2', '4', '7', 'Q']\n\n\nNote that we have changed the behavior of the sorted() function by providing the custom key that allows us to sort the data in a specific order using the predefined list and the index() function.\nIf you would like to sort the dictionary, you need to use the items() method (Otherwise, it will only return keys). The returning container will again be a list:\n\n\nCode\ngrade = {'calculus':85, 'introduction to mathematics':80, 'introduction to computer science':90, 'linear algebra':95}\nsorted_list = sorted(grade.items())\nprint(sorted_list)\n\n\n[('calculus', 85), ('introduction to computer science', 90), ('introduction to mathematics', 80), ('linear algebra', 95)]\n\n\nIf you would like to sort by the value, use the following code:\n\n\nCode\ndef value_key(x):\n    return x[1]\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'computer programming':90, 'linear algebra':95}\nsorted_dict = sorted(grade.items(), key=value_key)\nprint(sorted_dict)\n\n\n[('introduction to mathematics', 80), ('calculus', 85), ('computer programming', 90), ('linear algebra', 95)]\n\n\n\n\n6.2.6 &gt; Exercise 2: Try to design a program that counts the number of unique characters in a string. Be sure to exclude the punctuation and white space and the character with upper and lower cases are treated as different characters.\n\n\n\n\nsource: https://realpython.com/python-encodings-guide/\n\n\n\nCode\nimport string\n\n# You can obtain all the punctuations using the following attribute\nstring.punctuation\n\n\n'!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'\n\n\n\n\nCode\n# Sample text\ntext = \"The quick brown fox jumped over the lazy dog. The dog didn't seem to mind!\"\n\n# Create a set of punctuation characters\npunctuation = set(string.punctuation)\n    \n# Create a set of all characters included in the text\nall_chars = _____________\n    \n# Find the difference between the two sets to get the non-punctuation characters\nnon_punctuation_chars = ____________________________\n# Also remove the whitespace\n_____________________________\n    \n# Count the number of non-punctuation characters\nnum_unique_chars = len(non_punctuation_chars)\n\nprint(\"Number of unique characters:\", num_unique_chars)\n\n# Sanity check\nassert num_unique_chars == 27\n\n\nNumber of unique characters: 27\n\n\nIn this chapter, we discussed Python’s dictionary and set collections. They are both unorder, mutable and do not allow duplicates.\nWe said what a dictionary is and presented several examples. We showed the syntax of key–value pairs and showed how to use them to create dictionaries with comma-separated lists of key–value pairs in curly braces, {}. You also created dictionaries with dictionary comprehensions. You used square brackets, [], to retrieve the value corresponding to a key, and to insert and update key–value pairs. You also used the dictionary method update to change a key’s associated value. You iterated through a dictionary’s keys, values and items.\nYou created sets of unique immutable values. You combined sets with set operators and methods, changed sets’ values with the mutable set operations and created sets with set comprehensions. You saw that sets are mutable.\nA short comparison of the containers is shown below:\n\n\n\n\n\n\n\n\n\n\nFeature\nList\nTuple\nDictionary\nSet\n\n\n\n\nMutable (Can be modified in place)\nYes\nNo\nYes (keys are immutable)\nYes\n\n\nIterable (Can be use in for loop)\nYes\nYes\nYes\nYes\n\n\nOrdered (Can access by index, slicing)\nYes\nYes\nNo\nNo\n\n\nDuplicate Values\nAllowed\nAllowed\nNot in keys\nNot allowed"
  },
  {
    "objectID": "06_Manipulating_string.html#string",
    "href": "06_Manipulating_string.html#string",
    "title": "7  Manipulating Strings",
    "section": "7.1 String",
    "text": "7.1 String\nText is one of the most common forms of data your programs will handle. You already know how to concatenate two string together with the + operator, but you can do much more than that! You can extract partial strings from string just like sequence, add or remove spacing, convert letters to lowercase or uppercase, and check that strings are formatted correctly!\nThere are several ways to create a new string; the simplest is to enclose the elements in single or double quotes:\n\n\nCode\ntype(''), type(\"\")\n\n\n(str, str)\n\n\n\nOne benefit of using double quotes is that the string can have a single quote character in it.\n\n\n\nCode\nprint(\"I'am fine\")\n\n\nI'am fine\n\n\nA string is a sequence that maps index to case sensitive characters and thus belongs to sequence data type. Anything that we can apply to the sequence can also be applied to string. For instance, you can access the items (characters) one at a time with the bracket operator:\n\n\nCode\nfruit = 'banana'\nfruit[1]\n\n\n'a'\n\n\nSo “b” is the 0th letter (“zero-th”) of “banana”, “a” is the 1th letter (“one-th”), and “n” is the 2th (“two-th”) letter.\n\n\n\n\nsource: https://www.py4e.com/html3/06-strings\n\nlen() can be used to return the number of characters in a string:\n\n\nCode\nlen(fruit)\n\n\n6\n\n\nWe can use negative indices, which count backward from the end of the string.\n\n\nCode\nfruit[-1], fruit[-2]\n\n\n('a', 'n')\n\n\nSlicing also works on string to extract a substring from the original string. Remember that we can slice sequences using [start:stop:step]. The operator [start:stop] returns the part of the string from the “start-th” character to the “stop-th” character, including the first but excluding the last with step=1. If we omit the first index (before the colon), the slice starts at the beginning of the string. If we omit the second index, the slice goes to the end of the string:\n\n\nCode\ns = 'Cool-Python'\n\nprint(s[:5]) #same as s[0:5] \nprint(s[5:]) #same as s[5:len(s)] \nprint(s[::2]) #same as s[0:len(s):2]\nprint(s[::]) #same as s[:] and s[0:len(s):1] =&gt; copy the string\nprint(s[::-1]) #same as s[-1:-(len(s)+1):-1] =&gt; reverse the string\n\n\nCool-\nPython\nCo-yhn\nCool-Python\nnohtyP-looC\n\n\nStrings are “immutable”, which means that it cannot be modified:\n\n\nCode\ns = \"hello\"\ns[0] = 'y' \n\n\nTypeError: 'str' object does not support item assignment\n\n\nThe “object” in this case, is the string and the “item” is the character you tried to assign. The best you can do is create a new string that is a variation on the original:\n\n\nCode\nprint(id(s))\ns = 'y' + s[1:len(s)]\nprint(id(s))\nprint(s)\n\n\n1956771186608\n1956805647664\nyello\n\n\nA lot of computations involve processing a string one character at a time. Often they start at the beginning, select each character in turn, do something to it, and continue until the end. The traversal of string is just like we see before:\n\n\nCode\ns\n\n\n'yello'\n\n\n\n\nCode\n# Test if s contains 'o'\nfor char in s: # Retrieve item (character) one by one\n    if char == 'o':\n        print(\"There is an o\")\n        break\n\n\nThere is an o\n\n\nThe in and not in operators can be used with strings just like with list. An expression with two strings joined using in or not in will evaluate to a Boolean True or False:\n\n\nCode\nprint('Hello' in 'Hello, World')\nprint('cats' not in 'cats and dogs')\n\n\nTrue\nFalse\n\n\n\n7.1.1 Escape Characters\nAn escape character lets you use characters that are otherwise impossible to put into a string. An escape character consists of a backslash (\\) followed by the character you want to add to the string. (Despite consisting of two characters, it is commonly referred to as a singular escape character.) For example, the escape character for a single quote is \\'. You can use this inside a string that begins and ends with single quotes\n\n\nCode\nspam = 'Say hi to Bob\\'s mother.'\nspam\n\n\n\"Say hi to Bob's mother.\"\n\n\nPython knows that since the single quote in Bob\\'s has a backslash, it is not a single quote meant to end the string. The escape characters \\' and \\\" let you put single quotes and double quotes inside your strings, respectively.\n\n\n\n\nEscape character\nPrints as\n\n\n\n\n\\'\nSingle quote\n\n\n\\\"\nDouble quote\n\n\n\\\\\nBackslash\n\n\n\\t\nTab\n\n\n\\n\nNewline (line break)\n\n\n\n\n\n\nCode\nprint(\"Hello there!\\nHow are you?\\n\\tI\\'m doing fine.\")\n\n\nHello there!\nHow are you?\n    I'm doing fine.\n\n\nWhile you can use the \\n escape character to put a newline into a string, it is often easier to use multiline strings. A multiline string in Python begins and ends with either three single quotes or three double quotes. Any quotes, tabs, or newlines in between the “triple quotes” are considered part of the string.\n\n\nCode\nprint('''Hello there,\nHow are you?\n        I'm doing fine\n''')\n\n\nHello there,\nHow are you?\n        I'm doing fine\n\n\n\nNotice that the single quote character in I'm does not need to be escaped. Escaping single and double quotes is optional in multiline strings.\n\n7.1.1.1 Raw Strings\nYou can place an r before the beginning quotation mark of a string to make it a raw string. A raw string completely ignores all escape characters and prints any backslash that appears in the string.\n\n\nCode\nprint(r'That is Carol\\'s cat.')\n\n\nThat is Carol\\'s cat.\n\n\nBecause this is a raw string, Python considers the backslash as part of the string and not as the start of an escape character. Raw strings are helpful if you are typing strings that contain many backslashes, such as the strings used for Windows file paths like r'C:\\Users\\Al\\Desktop'.\n\n\n\n7.1.2 Putting Strings Inside Other Strings\nPutting strings inside other strings is a common operation in programming. So far, we’ve been using the + operator and string concatenation to do this:\n\n\nCode\nname = 'Al'\nage = 33\nlanguage = 'Python'\nprint(\"\\nHey! I'm \" + name + \", \" + str(age)+ \" old and I love \" + language + \" Programing\")\n\n\n\nHey! I'm Al, 33 old and I love Python Programing\n\n\nHowever, this requires a lot of tedious typing. A simpler approach is to use string interpolation. The format operator, % allows us to construct strings, replacing parts of the strings with the data stored in variables. When applied to integers, % is the modulus operator. But when the first operand is a string, % is the format operator.\nThe first operand is the format string, which contains one or more format specifiers that specify how the second operand is formatted. The result is a string. For example, the format specifiers %d means that the second operand should be formatted as an integer (“d” stands for “decimal”). One benefit is that str() doesn’t have to be called to convert values to strings:\n\n\n\n\nsource: https://towardsdatascience.com/python-string-interpolation-829e14e1fc75\n\n\n\nCode\nprint(\"\\nHey! I'm %s, %d years old and I love %s Programing\"%(name,age,language))   # Like the printf in C\n\n\nWe can have more control over the formatting, for instance:\n\n\n\n\nsource: https://refactored.ai/microcourse/notebook?path=content%2F02-Python_for_Data_Scientists%2F03-Data_Structures_in_python%2F01-Basic_data_types_and_operators.ipynb\n\n\n\nCode\na = 32\nb = 32.145\nprint('a=%4d, b=%6.2f' % (a,b))\n\n\n\n\nCode\na = 32\nb = 32.145\nprint(f'{a:4d},{b:6.2f}')\n\n\n  32, 32.15\n\n\nBy default, Python right-aligns numbers and left-aligns other values such as strings. The numbers after % is the total field width and the field width for the decimal part (separated by .). For values with fewer characters than the field width, the remaining character positions are filled with spaces. The %f is used to format floating points and note that variable b has been rounded.\nPython 3.6 introduced f-strings (The f is for format), which is similar to string interpolation except that braces are used instead of %s, with the expressions placed directly inside the braces. Like raw strings, f-strings have an f prefix before the starting quotation mark. (Note that it is even possible to do inline arithmetic)\n\n\nCode\nprint(f\"\\nHey! I'm {name}, {age+2} years old and I love {language} Programing\") \n\n\nWe can have more control with the f-string besides the field width, like specifying left, right and center alignment with &lt;, &gt; and ^. Note now the format specifiers are placed after the variable separated by a colon:\n\n\nCode\nprint(f'[{a:&lt;15d}]')\nprint(f'[{b:^9.2f}]')\n\n\nIn addition, you can use + before the field width specifies that a positive number should be preceded by a +. A negative number always starts with a -. To fill the remaining characters of the field with 0s rather than spaces, place a 0 before the field width (and after the + if there is one):\n\n\nCode\nprint(f'[{a:+10d}]')\nprint(f'[{a:+010d}]')\n\n\nSee https://docs.python.org/3/library/string.html#formatspec for more details.\n\nYet another is the format() method, see https://realpython.com/python-string-formatting/#toc for more details.\n\n\n\n7.1.3 Exercise 1: Assuming we are designing a word game called “The Mysterious Island” and we need to print the statistics of the player each time the game begins. Try to complete the following function that receives the variables from the game and displays the information that right aligns with each other using the f-string:\nPlayer1 Stats:\nHealth:     100/100\nExperience:   0/150\nGold:   50.00/60.00\n\n\nPlayer2 Stats:\nHealth:      60/100\nExperience: 120/150\nGold:   40.00/60.00\nHint: You can first calculate the maximal width required for each row.\n\n\n\n\n\nCode\ndef print_stats(player_name, health, experience, gold):\n    print(f\"{player_name} Stats:\")\n    print(f\"Health:____/100\")\n    print(f\"Experience:______/150\")\n    print(f\"Gold:_____/60.00\")\n\n\n\n\nCode\ngame_title = \"The Mysterious Island\"\n\nwelcome_message = f'Welcome to \"{game_title}\" adventure!\\n\\n'\n# 1. Print the welcome_message\nprint(welcome_message)\n\n# 2. Use string and number formatting to print out the statistics\nplayer_name = \"Player1\"\nhealth = 100\nexperience = 0\ngold = 50.000\n\nprint_stats(player_name, health, experience, gold)\n\nprint(\"\\n\")\n\nplayer_name = \"Player2\"\nhealth = 60\nexperience = 120\ngold = 40.0\n\nprint_stats(player_name, health, experience, gold)\n\n\n\n\n7.1.4 String method\nStrings are an example of Python objects. An object contains both data (the actual string itself) and methods, which are effective functions that are built into the object and are available to any instance of the object.\nPython has a function called dir(), which lists the methods available for an object.\n\n\nCode\ndir(s)\n\n\nWhile the dir() function lists the methods, and you can use help() to get some simple documentation on a method, a better source of documentation for string methods would be https://docs.python.org/library/stdtypes.html#string-methods.\n\n7.1.4.1 The upper(), lower() Methods\nThe upper() and lower() string methods return a new string where all the letters in the original string have been converted to uppercase or lowercase:\n\n\nCode\nspam = 'Hello, world!'\nspam = spam.upper()\nprint(spam)\nspam = spam.lower()\nprint(spam)\n\n\nNote that these methods do not change the string itself but return new string values. If you want to change the original string, you have to call upper() or lower() on the string and then assign the new string to the variable where the original was stored. This is why you must use spam = spam.upper() to change the string in spam instead of simply spam.upper(). (This is just like if a variable eggs contains the value 10. Writing eggs + 3 does not change the value of eggs, but eggs = eggs + 3 does.). These data types are immutable and can not be modified in-place.\nThe upper() and lower() methods are helpful if you need to make a case-insensitive comparison. For example, the strings 'great' and 'GREat' are not equal to each other. But in the following small program, it does not matter whether the user types Great, GREAT, or grEAT, because the string is first converted to lowercase.\n\n\nCode\nprint('How are you?')\nfeeling = input()\nif feeling.lower() == 'great':\n    print('I feel great too.')\nelse:\n    print('I hope the rest of your day is good.')\n\n\n\n\n7.1.4.2 The isX() Methods\nThere are several other string methods that have names beginning with the word is. These methods return a Boolean value that describes the nature of the string. Here are some common isX() string methods:\n\nisupper()/islower() Returns True if the string has at least one letter and all the letters are uppercase or lowercase\nisalpha() Returns True if the string consists only of letters and isn’t blank\nisalnum() Returns True if the string consists only of letters and numbers and is not blank\nisdecimal() Returns True if the string consists only of numeric characters and is not blank\nisspace() Returns True if the string consists only of spaces, tabs, and newlines and is not blank\nistitle() Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters\n\n\n\nCode\nprint('Hello, world!'.islower()) \nprint('hello, world!'.islower())\nprint('hello'.isalpha())\nprint('hello123'.isalnum())\nprint('hello123'.isdecimal())\nprint(' '.isspace())\nprint('This Is Title Case'.istitle())\n\n\nThe isX() string methods are helpful when you need to validate user input. For example, the following program repeatedly asks users for their age and a password until they provide valid input:\n\n\nCode\nwhile True:\n    print('Enter your age:')\n    age = input()\n    if age.isdecimal():\n        break\n    print('Please enter a number for your age.')\n\nwhile True:\n    print('Select a new password (letters and numbers only):')\n    password = input()\n    if password.isalnum():\n        break\n    print('Passwords can only have letters and numbers.')\n\n\nIn the first while loop, we ask the user for their age and store their input in age. If age is a valid (decimal) value, we break out of this first while loop and move on to the second, which asks for a password. Otherwise, we inform the user that they need to enter a number and again ask them to enter their age. In the second while loop, we ask for a password, store the user’s input in password, and break out of the loop if the input is alpha­numeric. If it wasn’t, we’re not satisfied, so we tell the user the password needs to be alphanumeric and again ask them to enter a password.\n\n\n7.1.4.3 The startswith() and endswith() Methods\nThe startswith() and endswith() methods return True if the string they are called on begins or ends (respectively) with the string passed to the method; otherwise, they return False:\n\n\nCode\nprint('Hello, world!'.startswith('Hello'))\nprint('abc123'.endswith('12'))\n\n\n\n\n7.1.4.4 The replace() methods\nThe replace() function is like a “search and replace” operation in a word processor:\n\n\nCode\ngreet = 'Hello Bob'\nnstr = greet.replace('Bob','Jane')\nprint(nstr)\n\n\n\n\n7.1.4.5 The join() and split() Methods\nThe join() method is useful when you have a list of strings that need to be joined together into a single string. The join() method is called on a string, gets passed a list of strings, and returns a string. The returned string is the concatenation of each string in the passed-in list.\n\n\nCode\nprint(', '.join(['cats', 'rats', 'bats']))     #Separated by comma\nprint(' '.join(['My', 'name', 'is', 'Simon'])) #Separated by white space\n\n\n\n\nCode\n' and '.join(['cats', 'rats', 'bats'])\n\n\n'cats and rats and bats'\n\n\nNotice that the string join() calls on is inserted between each string of the list argument. For example, when join(['cats', 'rats', 'bats']) is called on the ', ' string, the returned string is 'cats, rats, bats'.\nThe split() method does the opposite: It’s called on a string and returns a list of strings.\n\n\nCode\n'My name is Simon'.split()\n\n\nBy default, the string ‘My name is Simon’ is split wherever whitespace characters such as the space, tab, or newline characters are found. These whitespace characters are not included in the strings in the returned list. You can pass a delimiter string to the split() method to specify a different string to split upon:\n\n\nCode\n'cats, rats, bats'.split(',')\n\n\nA common use of split() is to split a multiline string along the newline characters:\n\n\nCode\nspam = '''Dear Alice,\nHow have you been? I am fine.\nThere is a container in the fridge\nthat is labeled \"Milk Experiment.\"\n\nPlease do not drink it.\nSincerely,\nBob'''\n\nspam.split('\\n')\n\n\nPassing split() the argument '\\n' lets us split the multiline string stored in spam along the newlines and return a list in which each item corresponds to one line of the string.\n\n\n7.1.4.6 Removing Whitespace with the strip(), lstrip() and rstrip() Methods\nSometimes you may want to strip off whitespace characters (space, tab, and newline) from the left side, right side, or both sides of a string. The strip() string method will return a new string without any whitespace characters at the beginning or end. The lstrip() and rstrip() methods will remove whitespace characters from the left and right ends, respectively.\n\n\nCode\nspam = '    Hello, World    \\n'\nspam.strip()\n\n\n'Hello, World'\n\n\n\n\nCode\nspam.lstrip()\n\n\n\n\nCode\nspam.rstrip()\n\n\n\n\n\n7.1.5 Exercise 2: When editing the markdown document, you can create a bulleted list by putting each list item on its own line and placing a - in front. But say you have a really large list to which you want to add bullet points. You could just type those - at the beginning of each line, one by one. Or you could automate this task with a short Python program! For example, if I have following text:\nLists of resources\nLists of books\nLists of videos\nLists of blogs\nAfter running the program, the text should contain the following:\n- Lists of resources\n- Lists of books\n- Lists of videos\n- Lists of blogs\n\n\n\n\n\nCode\ntext = \"\"\"Lists of resources\nLists of books\nLists of videos\nLists of blogs\"\"\"\n\n# 1. Separate lines into list using string method.\nlines = text.________\n\n# 2. Add -\nfor i, line in enumerate(lines):    # loop through all indexes for \"lines\" list\n    lines[i] = ________             # add - to each string in \"lines\" list\n\n# 3. Use string method to conctenate list of strings back to string\ntext = _____________\nprint(text)\n\n\nText is a common form of data, and Python comes with many helpful string methods to process the text stored in string. You will make use of indexing, slicing, and string methods in almost every Python program you write. The programs you are writing now don’t seem too sophisticated—they don’t have graphical user interfaces with images and colorful text. So far, you’re displaying text with print() and letting the user enter text with input(). However, another way to manipulate large amounts of text is by reading and writing files directly off the hard drive. You’ll learn how to do this with Python later on.\nThat just about covers all the basic concepts of Python programming! You’ll continue to learn new concepts throughout the rest of this course, but you now know enough to start writing some useful programs that can automate tasks. If you’d like to see a collection of short, simple Python programs built from the basic concepts you’ve learned so far, check out https://github.com/asweigart/pythonstdiogames/. Try copying the source code for each program by hand and then make modifications to see how they affect the behavior of the program. Once you have an understanding of how the program works, try re-creating the program yourself from scratch. You don’t need to re-create the source code exactly; just focus on what the program does rather than how it does it."
  },
  {
    "objectID": "07_Files.html#reading-from-a-file",
    "href": "07_Files.html#reading-from-a-file",
    "title": "8  Files and Exceptions",
    "section": "8.1 Reading from a File",
    "text": "8.1 Reading from a File\nNow that you’ve mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable.\nAn incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file.\n\n8.1.1 Reading the Contents of a File\nTo begin, we need a file with a few lines of text in it. Let’s start with a file that contains pi to 30 decimal places:\n\n\nCode\n%%writefile pi_digits.txt\n3.1415926535\n  8979323846\n  2643383279\n\n\nHere’s a program that opens this file, reads it, and prints the contents of the file to the screen:\n\n\nCode\nfile_object = open('pi_digits.txt')\nprint(file_object.read())\nfile_object.close()\n\n\n3.1415926535\n  8979323846\n  2643383279\n\n\n\nTo do any work with a file, even just printing its contents, you first need to open the file to access it. The open() function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that’s currently being executed is stored. The open() function returns an object representing the file. Here, open('pi_digits.txt') returns an object representing pi_digits.txt. Python assigns this object to file_object, which we’ll work with later in the program.\n\n\nCode\n# A recommended way:\nwith open('pi_digits.txt') as file_object: #  file_object = open('pi_digits.txt')\n    contents = file_object.read()          #  We do not have to call file_object.close()\nprint(contents.strip())\n\n\n3.1415926535\n  8979323846\n  2643383279\n\n\nThe keyword with closes the file once access to it is no longer needed. Notice how we call open() in this program but not close(). You could open and close the file by calling open() and close(), but if a bug in your program prevents the close() method from being executed, the file may never close! This may seem trivial, but improperly closed files can cause data to be lost or corrupted.\nOnce we have a file object representing pi_digits.txt, we use the read() method in the second line of our program to read the entire contents of the file and store it as one long string in contents. Since read() returns an empty string when it reaches the end of the file; this empty string shows up as a blank line. If you want to remove the extra blank line, you can use strip() in the call to print().\n\nIt’s not always easy to know exactly when you should close a file, but with the structure shown here, Python will figure that out for you. All you have to do is open the file and work with it as desired, trusting that Python will close it automatically when the with block finishes execution.\n\n\n\n8.1.2 File Paths\nSometimes, depending on how you organize your work, the file you want to open won’t be in the same directory as your program file. To get Python to open files from a directory other than the one where your program file is stored, you need to provide a file path , which tells Python to look in a specific location on your system. A relative file path will tell Python to look for a given location relative to the directory where the currently running program file is stored. For example, you’d write:\nwith open('text_files/filename.txt') as file_object:\nThis line tells Python to look for the desired .txt file in the folder text_files and assumes that text_files is located in the current directory.\n\nWindows systems use a backslash (\\) instead of a forward slash (/) when displaying file paths, but you can still use forward slashes in your code.\n\n\n\nCode\n!mkdir text_files\n\n\n\n\nCode\n%%writefile text_files/pi_digits2.txt\n3.1415926535\n  8979323846\n  2643383279\n\n\nWriting text_files/pi_digits2.txt\n\n\n\n\nCode\nwith open('text_files/pi_digits2.txt') as file_object:\n    contents = file_object.read()\nprint(contents.strip())\n\n\n3.1415926535\n  8979323846\n  2643383279\n\n\nYou can also tell Python exactly where the file is on your computer regardless of where the program that’s being executed is stored. This is called an absolute file path. Absolute paths are usually longer than relative paths, so it’s helpful to assign them to a variable and then pass that variable to open():\nfile_path = '/home/phonchi/other_files/text_files/filename.txt'\nwith open(file_path) as file_object:\n\n\n8.1.3 Reading Line by Line\nWhen you’re reading a file, you’ll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. You can use a for loop on the file object to examine each line from a file one at a time:\n\n\nCode\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object: # file_object is also iterable!\n    for line in file_object:\n        print(line.strip())\n\n\n3.1415926535\n8979323846\n2643383279\n\n\nTo examine the file’s contents, we work through each line in the file by looping over the file object. Since there is a newline in each line of file and the print function adds its own newline each time we call it, so we will end up with two newline characters at the end of each line: one from the file and one from print(). Using strip() on each line in the print() call eliminates these extra blank lines.\n\n\n8.1.4 Making a List of Lines from a File\nWhen you use with, the file object returned by open() is only available inside the with block that contains it. If you want to retain access to a file’s contents outside the with block, you can store the file’s lines in a list inside the block and then work with that list!\n\n\nCode\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n    lines = file_object.readlines()\n\nprint(lines) # List of strings\npi_string = ''\nfor line in lines:\n    pi_string += line.strip()\n    \nprint(pi_string)\nprint(len(pi_string)) # The string is 32 characters long because it also includes the leading 3 and a decimal point\n\n\n['3.1415926535\\n', '  8979323846\\n', '  2643383279\\n']\n3.141592653589793238462643383279\n32\n\n\nThe readlines() method takes each line from the file and stores it in a list. This list is then assigned to lines, which we can continue to work with after the with block ends. Here, we create a variable, pi_string, to hold the digits of pi. We then create a loop that adds each line of digits to pi_string and removes the newline character from each line.\n\nWhen Python reads from a text file, it interprets all text in the file as a string. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the int() function or convert it to a float using the float() function.\n\n\n\n8.1.5 Writing to a File\nOne of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program finishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later!\n\n8.1.5.1 Writing to an Empty File\nTo write text to a file, you need to call open() with a second argument telling Python that you want to write to the file\n\n\nCode\nfilename = 'programming.txt'\n\nwith open(filename, 'w') as file_object:\n    file_object.write(\"We love programming!\")\n\n\nThe call to open() in this example has two arguments. The first argument is still the name of the file we want to open. The second argument, ‘w’, tells Python that we want to open the file in write mode. You can open a file in read mode (‘r’), write mode (‘w’), append mode (‘a’), or a mode that allows you to read and write to the file ( ‘r+’). If you omit the mode argument, Python opens the file in read-only mode by default. Here, we use the write() method on the file object to write a string to the file.\n\nPython can only write strings to a text file. If you want to store numerical data in a text file, you’ll have to convert the data to string format first using the str() function.\n\n\nThe open() function automatically creates the file you’re writing to if it doesn’t already exist. However, be careful opening a file in write mode (‘w’) because if the file does exist, Python will erase the contents of the file before returning the file object.\n\n\n\nCode\nwith open(filename, 'w') as file_object:\n    print(\"12\")\n\n\n12\n\n\nWhile reading through a file, the system maintains a file-position pointer(index) representing the location of the next character to read. Therefore, the following code snippet will allow you to append it to the end of the file.\n\n\nCode\nyear = 2023\n\nwith open(filename, 'r+') as file_object:\n    spam = file_object.readlines()\n    print(file_object.tell())\n    print(len(\"We love programming!\"))\n    file_object.write(str(year))\n\n\n20\n20\n\n\nThe tell() function will return the current position of the file-position pointer. We can also use seek() to change the position. Checkout more details about file-position pointer here.\n\n\n\n8.1.6 Appending to a File\nIf you want to add content to a file instead of writing over existing content, you can also open the file in append mode. When you open a file in append mode, Python doesn’t erase the contents of the file before returning the file object. Any lines you write to the file will be added at the end of the file. If the file doesn’t exist yet, Python will create an empty file for you.\n\n\nCode\nfilename = 'programming.txt'\n\nwith open(filename, 'a') as file_object:\n    file_object.write(\"\\nWe also love finding meaning in large datasets.\\n\")\n    file_object.write(\"We love creating apps that can run in a browser.\\n\")\n\n\nThe write() function doesn’t add any newlines to the text you write. So we need to add newline characters if we would like to. There is also a writelines() function that can write list of strings into files."
  },
  {
    "objectID": "07_Files.html#storing-data",
    "href": "07_Files.html#storing-data",
    "title": "8  Files and Exceptions",
    "section": "8.2 Storing Data",
    "text": "8.2 Storing Data\nMany of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for visualization. Whatever the focus of your program is, you’ll store the information users provide in data structures such as lists and dictionaries. When users close a program, you’ll almost always want to save the information they entered. A simple way to do this involves storing your data using the json module.\nThe json module allows you to dump simple Python data structures into a file and load the data from that file the next time the program runs. You can also use json to share data between different programming languages. It’s a useful and portable format.\n\n8.2.0.1 Using json.dump() and json.load()\nThe json.dump() function takes two arguments: a piece of data to store and a file object it can use to store the data.\n\n\nCode\nimport json\n\nnumbers = [2, 3, 5, 7, 11, 13]\nfilename = 'numbers.json'\n\nwith open(filename, 'w') as f:\n    json.dump(numbers, f)\n\n\nNow we’ll write a program that uses json.load() to read the list back into memory\n\n\nCode\nfilename = 'numbers.json'\nwith open(filename) as f:\n    numbers = json.load(f)\n    \nprint(numbers)\n\n\n[2, 3, 5, 7, 11, 13]"
  },
  {
    "objectID": "07_Files.html#exceptions",
    "href": "07_Files.html#exceptions",
    "title": "8  Files and Exceptions",
    "section": "8.3 Exceptions",
    "text": "8.3 Exceptions\nPython uses special objects called exceptions to manage errors that arise during a program’s execution. Whenever an error makes Python unsure of what to do next, it creates an exception object. If we write code that handles the exception, the program will continue running. If you don’t handle the exception, the program will halt and show a traceback, which includes a report of the exception that was raised.\nExceptions are handled with try-except blocks. A try-except block tells Python what to do if an exception is raised. When we use try-except blocks, our programs will continue running even if things go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that we write!\n\n8.3.1 Handling the ZeroDivisionError Exception\n\n\nCode\nprint(5/0)\n\n\nZeroDivisionError: division by zero\n\n\nThe error reported at the first line in the traceback, ZeroDivisionError, is an exception object. Python creates this kind of object in response to a situation where it can’t do what we ask. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program.\nWhen we think an error may occur, you can write a try-except block to handle the exception that might be raised. We tell Python to try running some code and tell it what to do if the code results in a particular kind of exception.\n\n\nCode\ntry:\n    print(5/0)\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\n\n\nYou can't divide by zero!\n\n\nWe put print(5/0), the line that caused the error, inside a try block. If the code in a try block works, Python skips over the except block. If the code in the try block causes an error, Python looks for an except block whose error matches the one that was raised and ran the code in that block. In this example, the user sees a friendly error message instead of a traceback.\n\n\nCode\ntry:\n    print(5/0)\nexcept:\n    print(\"Exceptions occur!\")\n\n\nExceptions occur!\n\n\nIf you do not add any exception type, it will capture all exceptions!\n\n\n8.3.2 Using Exceptions to Prevent Crashes\nHandling errors correctly is especially important when the program has more work to do after the error occurs. Let’s create a simple calculator that does only division:\n\n\nCode\n%%writefile division_calculator.py\nprint(\"Give me two numbers, and I'll divide them.\")\nprint(\"Enter 'q' to quit.\")\n\nwhile True:\n    first_number = input(\"\\nFirst number: \")\n    if first_number == 'q':\n        break\n    second_number = input(\"Second number: \")\n    if second_number == 'q':\n        break\n    try:\n        answer = int(first_number) / int(second_number)\n    except ZeroDivisionError:\n        print(\"You can't divide by 0!\")\n    else: # Only executed if try block is succeed\n        print(answer)\n    finally: # Always executed\n        print(\"\\nGive me two numbers, and I'll divide them.\")\n        print(\"Enter 'q' to quit.\")\n\n\nOverwriting division_calculator.py\n\n\nHere, the error may occur on the line that performs the division, so that’s where we’ll put the try-except block. This example also includes an else block. Any code that depends on the try block executing successfully goes into the else block. In addition, the finally clause is guaranteed to execute, regardless of whether its try suite executes successfully or an exception occurs.\nWe ask Python to try to complete the division operation in a try block, which includes only the code that might cause an error. The program continues to run, and the user never sees a traceback.\n\n\n8.3.3 Handling the FileNotFoundError Exception\nOne common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename may be misspelled, or the file may not exist at all\n\n\nCode\nfilename = 'alice.txt'\nwith open(filename) as f: # Note it is in read mode\n    contents = f.read()\n\n\nFileNotFoundError: [Errno 2] No such file or directory: 'alice.txt'\n\n\n\n\nCode\nfilename = 'alice.txt'\ntry:\n    with open(filename) as f:\n        contents = f.read()\nexcept FileNotFoundError:\n    print(f\"Sorry, the file {filename} does not exist.\")\n\n\nSorry, the file alice.txt does not exist.\n\n\nIn this example, the code in the try block produces a FileNotFoundError, so Python looks for an except block that matches that error. Python then runs the code in that block, and the result is a friendly error message instead of a traceback.\n\n\n8.3.4 Exercise 1: Assuming we are designing a word game called “The Mysterious Island” and we need to load the statistics of the player and enemies each time the game begins. Try to complete the following functions load_data() and save_data() so that you can load the JSON file if it does not exist using the exception handling techniques you just learned.\n\n\n\n\n\nCode\nimport random\nimport time\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\ndef battle(player, enemy):\n    slow_print(f\"You encounter a {enemy['name']} with {enemy['hp']} HP!\")\n    while player['hp'] &gt; 0 and enemy['hp'] &gt; 0:\n        choice = input(\"Do you want to attack or escape? (a/e): \")\n        if choice.lower() == 'a':\n            player_damage = max(random.randint(player['attack']//2, player['attack']), 1)\n            enemy_damage = max(random.randint(enemy['attack']//2, enemy['attack']), 1)\n            slow_print(f\"You deal {player_damage} damage to the {enemy['name']}!\")\n            enemy['hp'] -= player_damage\n            if enemy['hp'] &lt;= 0:\n                break\n            slow_print(f\"The {enemy['name']} deals {enemy_damage} damage to you!\")\n            player['hp'] -= enemy_damage\n        elif choice.lower() == 'e':\n            escape_chance = random.randint(1, 10)\n            if escape_chance &lt;= 2:\n                slow_print(\"You successfully escape from the battle!\")\n                return\n            else:\n                slow_print(\"You failed to escape!\")\n                enemy_damage = max(random.randint(enemy['attack']//2, enemy['attack']), 1)\n                slow_print(f\"The {enemy['name']} deals {enemy_damage} damage to you!\")\n                player['hp'] -= enemy_damage\n        else:\n            slow_print(\"Invalid choice! Try again.\")\n    if player['hp'] &lt;= 0:\n        slow_print(\"You were defeated!\")\n        print(\"Game over!\")\n        return False\n    else:\n        slow_print(f\"You defeated the {enemy['name']}!\")\n\ndef load_data():\n    # Perform exception handling, if this is the first time you load the game\n    _____:\n        with open('game_data.json', 'r') as f:\n            data = ____________________ # Read the data here using load()\n    __________________________:\n        data = {\n            \"player\": {\n                \"name\": \"Player\",\n                \"hp\": 50,\n                \"attack\": 10\n            },\n            \"enemies\": [\n                {\n                    \"name\": \"Slime\",\n                    \"hp\": 10,\n                    \"attack\": 5\n                },\n                {\n                    \"name\": \"Goblin\",\n                    \"hp\": 25,\n                    \"attack\": 8\n                },\n                {\n                    \"name\": \"Dragon\",\n                    \"hp\": 80,\n                    \"attack\": 15\n                }\n            ]\n        }\n        save_data(data)\n    return data\n\ndef save_data(data):\n    with open('game_data.json', 'w') as f:\n        ______________# Save the data so that you can play again using dump()\n\ndata = load_data()\nplayer = data['player']\nenemies = data['enemies']\nflag = True\n\nfor enemy in enemies:\n    flag = battle(player, enemy)\n\nif flag != False: \n    print(\"Congratulations!\")\n\n\nYou encounter a Slime with 10 HP!\nYou deal 7 damage to the Slime!\nThe Slime deals 2 damage to you!\nInvalid choice! Try again.\nYou deal 9 damage to the Slime!\nYou defeated the Slime!\nYou encounter a Goblin with 25 HP!\nYou deal 6 damage to the Goblin!\nThe Goblin deals 8 damage to you!\nYou deal 7 damage to the Goblin!\nThe Goblin deals 5 damage to you!\nYou deal 7 damage to the Goblin!\nThe Goblin deals 4 damage to you!\nYou deal 10 damage to the Goblin!\nYou defeated the Goblin!\nYou encounter a Dragon with 80 HP!\nYou failed to escape!\nThe Dragon deals 13 damage to you!\nYou failed to escape!\nThe Dragon deals 9 damage to you!\nYou failed to escape!\nThe Dragon deals 15 damage to you!\nYou were defeated!\nGame over!\n\n\nIn this chapter, you learned how to work with files. You learned to read an entire file at once and read through a file’s contents one line at a time. You learned to write to a file and append text onto the end of a file. You learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program. Finally, You read about exceptions and how to handle the exceptions you’re likely to see in your programs."
  },
  {
    "objectID": "08_09_OOP.html#creating-and-using-a-class",
    "href": "08_09_OOP.html#creating-and-using-a-class",
    "title": "9  Object Oriented Programming and Classes",
    "section": "9.1 Creating and Using a Class",
    "text": "9.1 Creating and Using a Class\nIn the first lecture, we have mentioned that everything in Python is an object, so you’ve been using objects constantly. Object Oriented Programming (OOP) is a programming paradigm that allows you to group variables and functions together into new data types, called classes, from which you can create objects. When you write a class, you define the general behavior that a whole category of objects can have.\nWhen you create individual objects from the class, each object is automatically equipped with the general behavior; you can then give each object whatever unique traits you desire. Making an object from a class is called instantiation, and you work with instances of a class. In this chapter you’ll specify the kind of information that can be stored in instances, and you’ll define actions that can be taken with these instances. You’ll also write classes that extend the functionality of existing classes, so similar classes can share common functionality, and you can do more with less code. You’ll store your classes in modules and import classes written by other programmers into your own program files.\nYou’ve already used lots of classes created by other people (int, str, float, list, dict, etc). In this chapter you’ll learn how to create your own custom classes.\n\nLearning about OOP will help you see the world as a programmer does. Knowing the logic behind classes will train you to think logically, so you can write programs that effectively address almost any problem you encounter.\n\nYou can model almost anything using classes. Let’s start by writing a simple class, Dog, that represents a dog—not one dog in particular, but any dog. What do we know about most pet dogs? Well, they all have a name and an age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they’re common to most dogs.\n\n9.1.0.1 Creating the Dog Class\nEach instance created from the Dog class will store a name and an age, and we’ll give each dog the ability to sit() and roll_over():\n\n\nCode\nclass Dog:\n    \"\"\"A simple attempt to model a dog.\"\"\"\n    def __init__(self, name, age):\n        \"\"\"Initialize name and age attributes.\"\"\"\n        self.name = name\n        self.age = age\n    def sit(self):\n        \"\"\"Simulate a dog sitting in response to a command.\"\"\"\n        print(f\"{self.name} is now sitting.\")\n    def roll_over(self):\n        \"\"\"Simulate rolling over in response to a command.\"\"\"\n        print(f\"{self.name} rolled over!\")\n\n\nWe first define a class called Dog. By convention, capitalized names refer to classes in Python. There are no parentheses in the class definition because we’re creating this class from scratch. We then write a docstring describing what this class does.\n\n\n9.1.0.2 The __init__() Method\nA function that’s part of a class is a method. Everything you learned about functions applies to methods as well; the only practical difference for now is the way we’ll call methods. The __init__() method is a special method that Python runs automatically whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python’s default method names from conflicting with your method names.\nWe define the __init__() method to have three parameters: self, name, and age. The self parameter is required in the method definition, and it must come first, before the other parameters. It must be included in the definition because when Python calls this method later (to create an instance of Dog), the method call will automatically pass the self argument. Every method call associated with an instance automatically passes self, which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of Dog, Python will call the __init__() method from the Dog class. We’ll pass Dog() a name and an age as arguments; self is passed automatically, so we don’t need to pass it. The two variables defined in the body of the __init__() method each have the prefix self. Any variable prefixed with self is available to every method in the class, and we’ll also be able to access these variables through any instance created from the class. The line self.name = name takes the value associated with the parameter name and assigns it to the variable name, which is then attached to the instance being created. The same process happens with self.age = age. Variables that are accessible through instances like this are called attributes.\nThe Dog class has two other methods defined: sit() and roll_over(). Because these methods don’t need additional information to run, we just define them to have one parameter, self. The instances we create later will have access to these methods. In other words, they’ll be able to sit and roll over.\n\n\n9.1.0.3 Making an Instance from a Class\n\n\nCode\nmy_dog = Dog('Willie', 6) # This is known as constructor expression\n\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"My dog is {my_dog.age} years old.\")\n\n\nMy dog's name is Willie.\nMy dog is 6 years old.\n\n\nHere, we tell Python to create a dog whose name is ‘Willie’ and whose age is 6 which is known as constructor expression. When Python reads this line, it calls the __init__() method in Dog with the arguments ‘Willie’ and 6. The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog. To access the attributes of an instance, you use dot notation. After we create an instance from the class Dog, we can use dot notation to call any method defined in Dog.\n\n\nCode\nmy_dog.sit()\nmy_dog.roll_over()\n\n\nWillie is now sitting.\nWillie rolled over!\n\n\nTo call a method, give the name of the instance (in this case, my_dog) and the method you want to call, separated by a dot agian.\n\n\n9.1.0.4 Creating Multiple Instances\n\n\nCode\nmy_dog = Dog('Willie', 6) \nyour_dog = Dog('Lucy', 3)\n\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"My dog is {my_dog.age} years old.\")\nmy_dog.sit()\n\nprint(f\"\\nYour dog's name is {your_dog.name}.\")\nprint(f\"Your dog is {your_dog.age} years old.\")\nyour_dog.sit()\n\n\nMy dog's name is Willie.\nMy dog is 6 years old.\nWillie is now sitting.\n\nYour dog's name is Lucy.\nYour dog is 3 years old.\nLucy is now sitting.\n\n\nIn this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions.\n\n\n9.1.1 Working with Classes and Instances\nOnce you write a class, you’ll spend most of your time working with instances created from that class. One of the first tasks you’ll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.\n\n9.1.1.1 The Car Class\n\n\nCode\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n\n2024 Audi A4\n\n\nIn the Car class, we define the __init__() method with the self parameter first, just like we did with the Dog class. We also give it three other parameters: make, model, and year. The __init__() method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new Car instance, we’ll need to specify a make, model, and year for our instance. We define a method called get_descriptive_name() that puts a car’s year, make, and model into one string neatly describing the car. To work with the attribute values in this method, we use self.make, self.model, and self.year.\nWhen an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, where they are assigned a default value. In the above example, an attribute called odometer_reading that always starts with a value of 0. Finally, there is a method read_odometer() that helps us read each car’s odometer.\nOutside of the class, we make an instance from the Car class and assign it to the variable my_new_car. Then we call get_descriptive_name() to show what kind of car we have! Our car starts with a mileage of 0:\n\n\nCode\nmy_new_car = Car('audi', 'a4', 2024) \nprint(my_new_car.get_descriptive_name())\nmy_new_car.read_odometer()\n\n\n2024 Audi A4\nThis car has 0 miles on it.\n\n\nNot many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.\n\n\n9.1.1.2 Modifying Attribute Values\nYou can change an attribute’s value in three ways: you can change the value directly through an instance, set the value through a method, or increment the value (add a certain amount to it) through a method. The simplest way to modify the value of an attribute is to access the attribute directly through an instance.\n\n\nCode\nmy_new_car.odometer_reading = 23\nmy_new_car.read_odometer()\n\n\nThis car has 23 miles on it.\n\n\nIt can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally.\n\n\nCode\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\"\n        Set the odometer reading to the given value.\n        Reject the change if it attempts to roll the odometer back.\n        \"\"\"\n        if mileage &gt;= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n            \n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\n    def fill_gas_tank(self):\n        \"\"\"Filling the gas tank.\"\"\"\n        print(\"The gas tank is now full!\")\n\n\nThe only modification to Car is the addition of update_odometer(). This method takes in a mileage value and assigns it to self.odometer_reading. It also checks that the new reading makes sense before modifying the attribute. If the value provided for mileage is greater than or equal to the existing mileage, self.odometer_reading, you can update the odometer reading to the new mileage. If the new mileage is less than the existing mileage, you’ll get a warning that you can’t roll back an odometer! In addition, we also define new method increment_odometer() takes in a number of miles, and adds this value to self.odometer_reading. Finally, a method fill_gas_tank() is also added to the class.\n\n\nCode\nmy_new_car = Car('audi', 'a4', 2024)\nprint(my_new_car.get_descriptive_name())\n\nmy_new_car.update_odometer(23)\nmy_new_car.read_odometer()\n\nmy_new_car.fill_gas_tank()\nmy_new_car.increment_odometer(100)\nmy_new_car.read_odometer()\n\n\n2024 Audi A4\nThis car has 23 miles on it.\nThe gas tank is now full!\nThis car has 123 miles on it.\n\n\n\nYou can use methods like this to control how users of your program update values such as an odometer reading, but anyone with access to the program can still set the odometer reading to any value by accessing the attribute directly. Effective security takes extreme attention to detail in addition to basic checks like those shown here.\n\n\n\n9.1.1.3 __repr__ and __str__ method\nNotice that when you evalueate the my_new_car it will return a message that returns the address of the object:\n\n\nCode\nmy_new_car\n\n\n&lt;__main__.Car at 0x26d1f4c6ad0&gt;\n\n\nYou can change this behavior by adding a special function __repr__:\n\n\nCode\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"{self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\"\n        Set the odometer reading to the given value.\n        Reject the change if it attempts to roll the odometer back.\n        \"\"\"\n        if mileage &gt;= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n            \n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\n    def fill_gas_tank(self):\n        \"\"\"Filling the gas tank.\"\"\"\n        print(\"The gas tank is now full!\")\n\n    def __repr__(self):\n        return f'Car(make={self.make}, model={self.model}, year={self.year})'\n    \n    def __str__(self):\n        return self.get_descriptive_name()\n\n\n\n\nCode\nmy_new_car = Car('audi', 'a4', 2024)\nmy_new_car\n\n\nCar(make=audi, model=a4, year=2024)\n\n\nThe Python documentation indicates that __repr__ returns the “official” string representation of the object. we also define the __str__ special method. This method is called implicitly when you convert an object to a string with the built-in function str(), such as when you print an object or call str() explicitly.\n\n\nCode\nprint(my_new_car)\n\n\n2024 Audi A4\n\n\n\n\n\n9.1.2 Inheritance\nYou don’t always have to start from scratch when writing a class. If the class you’re writing is a specialized version of another class you wrote, you can use inheritance which is call “is a” releationship. When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class, and the new class is the child class. The child class can inherit any or all of the attributes and methods of its parent class, but it’s also free to define new attributes and methods of its own.\n\n9.1.2.1 The __init__() Method for a Child Class\nWhen you’re writing a new class based on an existing class, you’ll often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let’s model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote earlier. Then we’ll only have to write code for the attributes and behaviors specific to electric cars.\n\n\nCode\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery_size = 40\n   \n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n\nWhen you create a child class, the parent class must be part of the current file and must appear before the child class in the file. We then define the child class, ElectricCar. The name of the parent class must be included in parentheses in the definition of a child class. The __init__() method takes in the information required to make a Car instance. The super() function is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car, which gives an ElectricCar instance all the attributes defined in that method. The name super comes from a convention of calling the parent class a superclass (base class) and the child class a subclass (derived class). We make an instance of the ElectricCar class and assign it to my_leaf.\n‘leaf’, and 2024.\nWe also add new attribute that is specific to electric cars (a battery) and a method to report on this attribute. We’ll store the battery size and write a method that prints a description of the battery. This attribute/method will be associated with all instances created from the ElectricCar class but won’t be associated with any instances of Car.\n\n\nCode\nmy_leaf = ElectricCar('nissan', 'leaf', 2024) \nprint(my_leaf.get_descriptive_name())\nmy_leaf.describe_battery()\n\n\n2024 Nissan Leaf\nThis car has a 40-kWh battery.\n\n\nWhen we need to know the type of an object, we can pass the object to the built-in type() function. But if we’re doing a type check of an object, it’s a better idea to use the more flexible isinstance() built-in function. The isinstance() function will return True if the object is of the given class or a subclass of the given class.\n\n\nCode\ntype(my_leaf)\n\n\n__main__.ElectricCar\n\n\n\n\nCode\nisinstance(my_leaf, ElectricCar)\n\n\nTrue\n\n\n\n\nCode\nisinstance(my_leaf, Car)\n\n\nTrue\n\n\n\n\n9.1.2.2 Overriding Methods from the Parent Class\nYou can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Say the class Car had a method called fill_gas_tank(). This method is meaningless for an all-electric vehicle, so you might want to override this method. Here’s one way to do that:\n\n\nCode\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery_size = 40\n   \n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n    def fill_gas_tank(self):\n        \"\"\"Electric cars don't have gas tanks.\"\"\"\n        print(\"This car doesn't have a gas tank!\")\n\n\nNow if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead.\n\nWhen you use inheritance, you can make your child classes retain what you need and override anything you don’t need from the parent class.\n\n\n\n9.1.2.3 Instances as Attributes\nWhen modeling something from the real world in code, you may find that you’re adding more and more detail to a class. You’ll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together; this approach is called composition which is sometimes referred to as the “has a” releationship.\nFor example, if we continue adding detail to the ElectricCar class, we might notice that we’re adding many attributes and methods specific to the car’s battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery. Then we can use a Battery instance as an attribute in the ElectricCar class:\n\n\nCode\nclass Battery:\n    \"\"\"A simple attempt to model a battery for an electric car.\"\"\"\n\n    def __init__(self, battery_size=40):\n        \"\"\"Initialize the battery's attributes.\"\"\"\n        self.battery_size = battery_size\n\n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n        \n    def get_range(self):\n        \"\"\"Print a statement about the range this battery provides.\"\"\"\n        if self.battery_size == 40:\n            range = 150\n        elif self.battery_size == 65:\n            range = 225\n        print(f\"This car can go about {range} miles on a full charge.\")\n\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery = Battery()\n\n\nWe define a new class called Battery that doesn’t inherit from any other class. The __init__() method has one parameter, battery_size, in addition to self. This is an optional parameter that sets the battery’s size to 40 if no value is provided. The method describe_battery() has been moved to this class as well. A new method get_range() performs some simple analysis is also added. If the battery’s capacity is 40 kWh, get_range() sets the range to 150 miles, and if the capacity is 65 kWh, it sets the range to 225 miles.\nIn the ElectricCar class, we now add an attribute called self.battery. This tells Python to create a new instance of Battery (with a default size of 40) and assign that instance to the attribute self.battery. Any ElectricCar instance will now have a Battery instance created automatically. We create an electric car and assign it to the variable my_leaf. When we want to describe the battery, we need to work through the car’s battery attribute:\n\n\nCode\nmy_leaf = ElectricCar('nissan', 'leaf', 2024)\nprint(my_leaf.get_descriptive_name())\nmy_leaf.battery.describe_battery()\nmy_leaf.battery.get_range()\n\n\n2024 Nissan Leaf\nThis car has a 40-kWh battery.\nThis car can go about 150 miles on a full charge.\n\n\n\n\n\n9.1.3 Encapsulation - Properties for data access\nMost object-oriented programming languages enable you to encapsulate (or hide) an object’s data from the code. Such data in these languages is said to be private data. Python does not have private data. Instead, you use naming conventions to design classes that encourage correct use. By convention, Python programmers know that any attribute name beginning with an underscore (_) is for a class’s internal use only. Code should use the class’s methods and the class’s properties to interact with each object’s internal-use data attributes. Attributes whose identifiers do not begin with an underscore (_) are considered publicly accessible for use.\n\nHowever, even when we use these conventions, attributes are always accessible.\n\nLet’s develop a Time class that stores the time in 24-hour clock format with hours in the range 0–23, and minutes and seconds each in the range 0–59. For this class, we’ll provide properties, which look like data attributes but control the manner in which they get and modify an object’s data.\n\n\nCode\nclass Time:\n    \"\"\"Class Time with read-write properties.\"\"\"\n\n    def __init__(self, hour=0, minute=0, second=0):\n        \"\"\"Initialize each attribute.\"\"\"\n        self.hour = hour  # 0-23, note that this line calls the setter method hour\n        self.minute = minute  # 0-59\n        self.second = second  # 0-59\n\n    @property #getter\n    def hour(self):\n        \"\"\"Return the hour.\"\"\"\n        return self._hour\n\n    @hour.setter #setter, the name should be the same as getter\n    def hour(self, hour):\n        \"\"\"Set the hour.\"\"\"\n        if not (0 &lt;= hour &lt; 24):\n            raise ValueError(f'Hour ({hour}) must be 0-23')\n\n        self._hour = hour\n\n    @property\n    def minute(self):\n        \"\"\"Return the minute.\"\"\"\n        return self._minute\n\n    @minute.setter\n    def minute(self, minute):\n        \"\"\"Set the minute.\"\"\"\n        if not (0 &lt;= minute &lt; 60):\n            raise ValueError(f'Minute ({minute}) must be 0-59')\n\n        self._minute = minute\n\n    @property\n    def second(self):\n        \"\"\"Return the second.\"\"\"\n        return self._second\n\n    @second.setter\n    def second(self, second):\n        \"\"\"Set the second.\"\"\"\n        if not (0 &lt;= second &lt; 60):\n            raise ValueError(f'Second ({second}) must be 0-59')\n\n        self._second = second\n\n    def set_time(self, hour=0, minute=0, second=0):\n        \"\"\"Set values of hour, minute, and second.\"\"\"\n        self.hour = hour\n        self.minute = minute\n        self.second = second\n\n\nClass Time’s __init__ method specifies hour, minute and second parameters, each with a default argument of 0. The statements containing self.hour, self.minute and self.second appear to create hour, minute and second attributes for the new Time object. However, these statements actually call methods that implement the class’s hour, minute and second properties (lines 13–47). Those methods then create attributes named _hour, _minute and _second that are meant for use only inside the class!\nLines 10–21 define a publicly accessible read-write property named hour that manipulates a data attribute named _hour. The single-leading-underscore (_) naming convention indicates that we should not access _hour directly. Properties look like data attributes to programmers working with Time objects. However, notice that properties are implemented as methods. Each property defines a getter method which gets (that is, returns) a data attribute’s value and can optionally define a setter method which sets a data attribute’s value.\nThe @property decorator precedes the property’s getter method, which receives only a self parameter. Behind the scenes, a decorator adds code to the decorated function — in this case to make the hour function work with attribute syntax. The getter method’s name is the property name. This getter method returns the _hour data attribute’s value. The following code expression invokes the getter method:\n\n\nCode\nwake_up = Time(hour=6, minute=30)\nwake_up.hour\n\n\n6\n\n\nA decorator of the form @property_name.setter (in this case, @hour.setter) precedes the property’s setter method. The method receives two parameters — self and a parameter hour representing the value being assigned to the property. If the hour parameter’s value is valid, this method assigns it to the self object’s _hour attribute; otherwise, the method raises a ValueError. The following code expression invokes the setter by assigning a value to the property:\n\n\nCode\nwake_up.hour = 8\n\n\nA read-write property has both a getter and a setter. A readonly property has only a getter. We provide method set_time as a convenient way to change all three attributes with a single method call. Lines 49–53 invoke the setters for the hour, minute and second properties.\n\n\nCode\nwake_up.set_time(hour=7, minute=45)\n\n\nClass Time’s properties and methods define the class’s public interface—that is, the set of properties and methods programmers should use to interact with objects of the class. Just like private attribute, not all methods need to serve as part of a class’s interface. Some serve as utility methods used only inside the class and are not intended to be part of the class’s public interface used by others. Such methods should be named with a single leading underscore. In other object-oriented languages like C++, Java and C#, such methods typically are implemented as private methods.\n\n9.1.3.1 Simulating “Private” Attributes\nIn programming languages such as C++, Java and C#, classes state explicitly which class members are publicly accessible. Class members that may not be accessed outside a class definition are private and visible only within the class that defines them. Python programmers often use “private” attributes for data or utility methods that are essential to a class’s inner workings but are not part of the class’s public interface.\nRather than _hour, we can name the attribute __hour with two leading underscores. This convention indicates that __hour is “private” and should not be accessible to the class’s clients.\n\n\nCode\nclass PrivateClass:\n    \"\"\"Class with public and private attributes.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the public and private attributes.\"\"\"\n        self.public_data = \"public\"  # public attribute\n        self.__private_data = \"private\"  # private attribute\n\n\n\n\nCode\nmy_object = PrivateClass()\nmy_object.public_data\n\n\n'public'\n\n\nwhen we attempt to access __private_data directly, we get an AttributeError indicating that the class does not have an attribute by that name:\n\n\nCode\nmy_object.__private_data\n\n\nAttributeError: 'PrivateClass' object has no attribute '__private_data'\n\n\n\nEven with double-underscore (__) naming, we can still access and modify __private_data, because we know that Python renames attributes simply by prefixing their names with ‘_ClassName’\n\n\n\nCode\nprint(my_object._PrivateClass__private_data)\nmy_object._PrivateClass__private_data = 'modified'\nprint(my_object._PrivateClass__private_data)\n\n\nprivate\nmodified\n\n\n\n\n\n9.1.4 Class Methods\nClass methods are associated with a class rather than with individual objects, like regular methods are. You can recognize a class method in code when you see two markers: the @classmethod decorator before the method’s def statement and the use of cls as the first parameter, as shown in the following example.\n\n\nCode\nclass ExampleClass:\n    def exampleRegularMethod(self):\n        print('This is a regular method.')\n\n    @classmethod\n    def exampleClassMethod(cls):\n        print('This is a class method.')\n\n# Call the class method without instantiating an object:\nExampleClass.exampleClassMethod()\n\nobj = ExampleClass()\n# Given the above line, these two lines are equivalent:\nobj.exampleClassMethod()\nobj.__class__.exampleClassMethod()\n\n\nThis is a class method.\nThis is a class method.\nThis is a class method.\n\n\nThe cls parameter acts like self except self refers to an object, but the cls parameter refers to an object’s class. This means that the code in a class method cannot access an individual object’s attributes or call an object’s regular methods. Class methods can only call other class methods or access class attributes. We use the name cls because class is a Python keyword, and just like other keywords, such as if, while, or import, we can’t use it for parameter names. We often call class attributes through the class object, as in ExampleClass.exampleClassMethod(). But we can also call them through any object of the class, as in obj.exampleClassMethod().\nClass methods aren’t commonly used. The most frequent use case is to provide alternative constructor methods besides __init__(). For example, what if a constructor function could accept either a string of data the new object needs or a string of a filename that contains the data the new object needs? We don’t want the list of the __init__() method’s parameters to be lengthy and confusing. Instead let’s use class methods to return a new object. For example, let’s create an AsciiArt class.\n\n\nCode\n%%writefile face.txt\n _______\n|  . .  |\n| \\___/ |\n|_______|\n\n\nWriting face.txt\n\n\n\n\nCode\nclass AsciiArt:\n    def __init__(self, characters):\n        self._characters = characters\n\n    @classmethod\n    def fromFile(cls, filename):\n        with open(filename) as fileObj:\n            characters = fileObj.read()\n            return cls(characters)\n\n    def display(self):\n        print(self._characters)\n\n    # Other AsciiArt methods would go here...\n\nface1 = AsciiArt(' _______\\n' +\n                 '|  . .  |\\n' +\n                 '| \\\\___/ |\\n' +\n                 '|_______|')\nface1.display()\n\nface2 = AsciiArt.fromFile('face.txt')\nface2.display()\n\n\n _______\n|  . .  |\n| \\___/ |\n|_______|\n _______\n|  . .  |\n| \\___/ |\n|_______|\n\n\n\nThe AsciiArt class has an __init__() method that can be passed the text characters of the image as a string. It also has a fromFile() class method that can be passed the filename string of a text file containing the ASCII art. Both methods create AsciiArt objects.\n\n9.1.4.1 Class Attributes\nA class attribute is a variable that belongs to the class rather than to an object. We create class attributes inside the class but outside all methods, just like we can create global variables in a .py file but outside all functions. Here’s an example of a class attribute named count, which keeps track of how many CreateCounter objects have been created:\n\n\nCode\nclass CreateCounter:\n    count = 0 # This is a class attribute.\n\n    def __init__(self):\n        CreateCounter.count += 1\n\nprint('Objects created:', CreateCounter.count)  # Prints 0.\na = CreateCounter()\nb = CreateCounter()\nc = CreateCounter()\nprint('Objects created:', CreateCounter.count)  # Prints 3.\n\n\nObjects created: 0\nObjects created: 3\n\n\nThe CreateCounter class has a single class attribute named count. All CreateCounter objects share this attribute rather than having their own separate count attributes. This is why the CreateCounter.count += 1 line in the constructor function can keep count of every CreateCounter object created.\n\n\n9.1.4.2 Static Methods\nA static method doesn’t have a self or cls parameter. Static methods are effectively just functions, because they can’t access the attributes or methods of the class or its objects. Rarely, if ever, do you need to use static methods in Python. If you do decide to use one, you should strongly consider just creating a regular function instead.\nWe define static methods by placing the @staticmethod decorator before their def statements. Here is an example of a static method.\n\n\nCode\nclass ExampleClassWithStaticMethod:\n    @staticmethod\n    def sayHello():\n        print('Hello!')\n\n# Note that no object is created, the class name precedes sayHello():\nExampleClassWithStaticMethod.sayHello()\n\n\nHello!\n\n\n\nStatic methods are more common in other languages that don’t have Python’s flexible language features. Python’s inclusion of static methods imitates the features of other languages but doesn’t offer much practical value.\n\nYou’ll rarely need class methods, class attributes, and static methods. They’re also prone to overuse. If you’re thinking, “Why can’t I just use a function or global variable instead?” this is a hint that you probably don’t need to use a class method, class attribute, or static method. The only reason we cover them is so you can recognize them when you encounter them in code.\n\n\n\n9.1.5 Polymorphism\nPolymorphism allows objects of one type to be treated as objects of another type. For example, the len() function returns the length of the argument passed to it. You can pass a string to len() to see how many characters it has, but you can also pass a list or dictionary to len() to see how many items or key-value pairs it has, respectively. This form of polymorphism is called generic functions or parametric polymorphism, because it can handle objects of many different types. Polymorphism also refers to ad hoc polymorphism or operator overloading, where operators (such as + or *) can have different behavior based on the type of objects they’re operating on. For example, the + operator does mathematical addition when operating on two integer or float values, but it does string concatenation when operating on two strings.\nIn Python, we can achieve method polymorphism by defining a method in a base class and then overriding it in the derived classes. Each derived class can then provide its own implementation of the method. For example:\n\n\nCode\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\n\ndef speak(animal):\n    print(animal.speak())\n\nanimals = [Dog(\"Rufus\"), Cat(\"Whiskers\"), Dog(\"Buddy\")]\n\n# method polymorphism\nfor animal in animals:\n    print(animal.name + \": \" + animal.speak())\n\n# object polymorphism\nfor animal in animals:\n    speak(animal)\n\n\nRufus: Woof!\nWhiskers: Meow!\nBuddy: Woof!\nWoof!\nMeow!\nWoof!\n\n\nIn this example, the Animal class defines the speak method as a pass statement, meaning it does nothing. However, both Dog and Cat classes override the method with their own implementation of the method. The speak() function accepts any object that implements the speak() method, meaning it can handle animals of different types. Here, we can pass both Dog and Cat objects to the speak() function, as they both inherit the speak() method from the Animal class.\n\n9.1.5.1 Operator overloading\nPython has several special method names that begin and end with double underscores, abbreviated as dunder. These methods are called dunder methods, special methods, or magic methods. You’re already familiar with the __init__() dunder method name, but Python has several more. We often use them for operator overloading — that is, adding custom behaviors that allow us to use objects of our classes with Python operators, such as + or &gt;=. Other dunder methods let objects of our classes work with Python’s built-in functions, such as len(). These methods are documented online in the official Python documentation at https://docs.python.org/3/reference/datamodel.html#special-method-names.\n\n\nCode\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\np1 = Point(1, 2)\np2 = Point(3, 4)\np3 = p1 + p2\nprint(p3.x, p3.y)  # Output: 4 6\n\n\n4 6\n\n\nIn this example, we define the __add__ method in the Point class to implement the addition of two Point objects. When we use the + operator with two Point objects, the __add__ method is called automatically to perform the addition.\n\n\n\n9.1.6 Data Class\nData classes are among Python 3.7’s most important new features. They help you build classes faster by using more concise notation and by autogenerating “boilerplate” code that’s common in most classes. For instance,\n\nA data class autogenerates __init__, __repr__ and __eq__, saving you time.\nA data class can autogenerate the special methods that overload the &lt;, &lt;=, &gt; and &gt;= comparison operators.\nWhen you change data attributes defined in a data class, then use it in a script or interactive session, the autogenerated code updates automatically. So, you have less code to maintain and debug.\nThe required variable annotations for class attributes and data attributes enable you to take advantage of static code analysis tools. So, you might be able to eliminate additional errors before they can occur at execution time.\nSome static code analysis tools and IDEs can inspect variable annotations and issue warnings if your code uses the wrong type. This can help you locate logic errors in your code before you execute it. In an end-of-chapter exercise, we ask you to use the static code analysis tool MyPy to demonstrate such warnings.\n\nCheckout https://docs.python.org/3/library/dataclasses.html for more details."
  },
  {
    "objectID": "10_11_NumPy.html#numpy",
    "href": "10_11_NumPy.html#numpy",
    "title": "10  Array-Oriented Programming with NumPy",
    "section": "10.1 NumPy",
    "text": "10.1 NumPy\nThe NumPy (Numerical Python) library first appeared in 2006 and is the preferred Python array implementation. It offers a high-performance, richly functional n-dimensional array type called ndarray, which from this point forward we’ll refer to by its synonym, array. Operations on arrays are up to two orders of magnitude faster than those on lists. Many Python libraries depend on NumPy. Many popular data science libraries such as Pandas, SciPy (Scientific Python) and Keras (for deep learning) are built on or depend on NumPy.\nIn this chapter, we explore array’s basic capabilities. Lists can have multiple dimensions. You generally process multi-dimensional lists with nested loops or list comprehensions with multiple for clauses. A strength of NumPy is “array-oriented programming,” which uses functional-style programming with internal iteration to make array manipulations concise and straightforward, eliminating the kinds of bugs that can occur with the external iteration of explicitly programmed loops.\nIn Python the types are dynamically inferred and we do not have to allocate the memory by ourself, this type flexibility also points to is the fact that Python variables are more than just their values; they also contain extra information about the type and the size of the value!\n\n\n\n\nsource: https://jakevdp.github.io/PythonDataScienceHandbook/figures/cint_vs_pyint.png\n\nSimilary, the list in Python is very flexible that can store heterogeneous objects. But this flexibility comes at a cost: to allow these flexible types, each item in the list must contain its own type, size, and other information. Every element is a complete Python object. In the special case that all variables are of the same type, much of this information is redundant, so it can be much more efficient to store the data in a fixed-type array. The difference between a dynamic-type list and a fixed-type (NumPy-style) array is illustrated:\n\n\n\n\nsource: https://jakevdp.github.io/PythonDataScienceHandbook/figures/array_vs_list.png\n\nAt the implementation level, the array essentially contains a single pointer to one contiguous block of data. The Python list, on the other hand, contains a pointer to a block of pointers, each of which in turn points to a full Python object like the Python integer we saw earlier.\n\nThe advantage of the list is flexibility: because each list element is a full structure containing both data and type information, the list can be filled with data of any desired type. Fixed-type NumPy-style arrays lack this flexibility, but are much more efficient for storing and manipulating data.\n\nThe ndarray object of the NumPy package not only provides efficient storage of array-based data, but adds to this efficient operations on that data."
  },
  {
    "objectID": "10_11_NumPy.html#creating-array-s-from-existing-data",
    "href": "10_11_NumPy.html#creating-array-s-from-existing-data",
    "title": "10  Array-Oriented Programming with NumPy",
    "section": "10.2 Creating array s from Existing Data",
    "text": "10.2 Creating array s from Existing Data\nThe NumPy documentation recommends importing the numpy module as np so that you can access its members with “np.”\n\n\nCode\nimport numpy as np\n\n\nThe numpy module provides various functions for creating arrays. Here we use the array function, which receives collection of elements and returns a new array containing the argument’s elements. Let’s pass a list:\n\n\nCode\nnumbers = np.array([2, 3, 5, 7, 11])\nnumbers, type(numbers)\n\n\n(array([ 2,  3,  5,  7, 11]), numpy.ndarray)\n\n\nThe array function copies its argument’s contents into the array. Note that the type is numpy.ndarray, but all arrays are output as “array.”\n\nWhen outputting an array, NumPy separates each value from the next with a comma and a space and right-aligns all the values using the same field width. It determines the field width based on the value that occupies the largest number of character positions. In this case, the value 11 occupies the two character positions, so all the values are formatted in two-character fields. That’s why there’s a leading space between the [ and 2.\n\n\n10.2.1 Multidimensional Arguments\nThe array function copies its argument’s dimensions. Let’s create an array from a two row-by-three-column list:\n\n\nCode\nnp.array([[1, 2, 3], [4, 5, 6]])\n\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\nNumPy auto-formats arrays, based on their number of dimensions, aligning the columns within each row.\n\n10.2.1.1 array Attributes\nThe array function determines an array’s element type from its argument’s elements. You can check the element type with an array’s dtype attribute:\n\n\nCode\nintegers = np.array([[1, 2, 3], [4, 5, 6]])\nfloats = np.array([0.0, 0.1, 0.2, 0.3, 0.4])\n\nintegers.dtype, floats.dtype\n\n\n(dtype('int32'), dtype('float64'))\n\n\nAs you’ll see in the next section, various array-creation functions receive a dtype keyword argument so you can specify an array’s element type. For performance reasons, NumPy is written in the C programming language and uses C’s data types. By default, NumPy stores integers as the NumPy type int64 values — which correspond to 64-bit (8-byte) integers (long int) in C — and stores floating-point numbers as the NumPy type float64 values — which correspond to 64-bit (8-byte) floating-point values (double) in C. In our examples, most commonly you’ll see the types int64, float64, bool and object for non-numeric data (such as strings). The complete list of supported types is at https://docs.scipy.org/doc/numpy/user/basics.types.html.\nThe attribute ndim contains an array’s number of dimensions and the attribute shape contains a tuple specifying an array’s dimensions:\n\n\nCode\nprint(integers.ndim)\nprint(floats.ndim)\n\n\n2\n1\n\n\n\n\nCode\nprint(integers.shape)\nprint(floats.shape)\n\n\n(2, 3)\n(5,)\n\n\nHere, integers has 2 rows and 3 columns (6 elements) and floats is one-dimensional containing 5 floating number.\nYou can view an array’s total number of elements with the attribute size and the number of bytes required to store each element with itemsize:\n\n\nCode\nprint(integers.size)\nprint(integers.itemsize)\nprint(floats.size)\nprint(floats.itemsize)\n\n\n6\n4\n5\n8\n\n\nNote that integers’ size is the product of the shape tuple’s values — two rows of three elements each for a total of six elements. In each case, itemsize is 8 because integers contains int64 values and floats contains float64 values, which each occupy 8 bytes.\n\n\n\n10.2.2 Filling array with Specific Values\nNumPy provides functions zeros, ones and full for creating arrays containing 0s, 1s or a specified value, respectively. By default, zeros and ones create arrays containing float64 values. We’ll show how to customize the element type momentarily. The first argument to these functions must be an integer or a tuple of integers specifying the desired dimensions. For an integer, each function returns a one-dimensional array with the specified number of elements:\n\n\nCode\nnp.zeros(5)\n\n\narray([0., 0., 0., 0., 0.])\n\n\nFor a tuple of integers, these functions return a multidimensional array with the specified dimensions. You can specify the array’s element type with the zeros and ones function’s dtype keyword argument:\n\n\nCode\nnp.ones((2, 4), dtype=np.int64)\n\n\narray([[1, 1, 1, 1],\n       [1, 1, 1, 1]], dtype=int64)\n\n\nThe array returned by full contains elements with the second argument’s value and type:\n\n\nCode\nnp.full((3, 5), 13)\n\n\narray([[13, 13, 13, 13, 13],\n       [13, 13, 13, 13, 13],\n       [13, 13, 13, 13, 13]])\n\n\n\n\n10.2.3 Creating array from Ranges\n\n10.2.3.1 Creating Integer Ranges with arange\nLet’s use NumPy’s arange function to create integer ranges — similar to using built-in function range. In each case, arange first determines the resulting array’s number of elements, allocates the memory, then stores the specified range of values in the array:\n\n\nCode\nnp.arange(5)\n\n\narray([0, 1, 2, 3, 4])\n\n\n\n\nCode\nnp.arange(5, 10)\n\n\narray([5, 6, 7, 8, 9])\n\n\n\n\nCode\nnp.arange(10, 1, -2)\n\n\narray([10,  8,  6,  4,  2])\n\n\n\nThough you can create arrays by passing ranges as arguments, always use arange as it’s optimized for arrays\n\n\n\n10.2.3.2 Creating Floating-Point Ranges with linspace\nYou can produce evenly spaced floating-point ranges with NumPy’s linspace function. The function’s first two arguments specify the starting and ending values in the range, and the ending value is included in the array. The optional keyword argument num specifies the number of evenly spaced values to produce — this argument’s default value is 50:\n\n\nCode\nnp.linspace(0.0, 1.0, num=5)\n\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n\n\n\n\n10.2.3.3 Reshaping an array\nYou also can create an array from a range of elements, then use array method reshape to transform the one-dimensional array into a multidimensional array. Let’s create an array containing the values from 1 through 20, then reshape it into four rows by five columns:\n\n\nCode\nnp.arange(1, 21).reshape(4, 5)\n\n\narray([[ 1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10],\n       [11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20]])\n\n\nNote the chained method calls in the preceding snippet. First, arange produces an array containing the values 1–20. Then we call reshape on that array to get the 4-by-5 array that was displayed. You can reshape any array, provided that the new shape has the same number of elements as the original. So a six-element one-dimensional array can become a 3-by-2 or 2-by-3 array, and vice versa!\nWhen displaying an array, if there are many items, NumPy drops the middle rows, columns or both from the output. The following snippets generate 100,000 elements.\n\n\nCode\nnp.arange(1, 100001).reshape(100, 1000)\n\n\narray([[     1,      2,      3, ...,    998,    999,   1000],\n       [  1001,   1002,   1003, ...,   1998,   1999,   2000],\n       [  2001,   2002,   2003, ...,   2998,   2999,   3000],\n       ...,\n       [ 97001,  97002,  97003, ...,  97998,  97999,  98000],\n       [ 98001,  98002,  98003, ...,  98998,  98999,  99000],\n       [ 99001,  99002,  99003, ...,  99998,  99999, 100000]])\n\n\nThe above case shows the first and last three of the 100 rows, and the first and last three of the 1000 columns. The notation ... represents the missing data.\n\n\n\n10.2.4 List vs. array Performance: Introducing %timeit\nMost array operations execute significantly faster than corresponding list operations. To demonstrate, we’ll use the %timeit magic command, which times the average duration of operations.\n\n\nCode\nimport random\n\n\nHere, let’s use the random module’s randint() function with a list comprehension to create a list of six million die rolls and time the operation using %timeit:\n\n\nCode\n%timeit rolls_list = [random.randint(1, 6) for i in range(0, 6_000_000)]\n\n\n2.19 s ± 29.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\nBy default, %timeit executes a statement in a loop, and it runs the loop seven times. If you do not indicate the number of loops, %timeit chooses an appropriate value\n\nNow, let’s use the randint() function from the numpy.random module to create an array\n\n\nCode\n%timeit rolls_array = np.random.randint(1, 7, 6_000_000)\n\n\n43 ms ± 872 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)"
  },
  {
    "objectID": "10_11_NumPy.html#indexing-and-slicing",
    "href": "10_11_NumPy.html#indexing-and-slicing",
    "title": "10  Array-Oriented Programming with NumPy",
    "section": "10.3 Indexing and Slicing",
    "text": "10.3 Indexing and Slicing\nOne-dimensional arrays can be indexed and sliced using the same syntax and techniques we demonstrated in the “Lists and Tuples” chapter. Here, we focus on array-specific indexing and slicing capabilities.\nTo select an element in a two-dimensional array, specify a tuple containing the element’s row and column indices in square brackets:\n\n\nCode\ngrades = np.array([[87, 96, 70], [100, 87, 90],\n                   [94, 77, 90], [100, 81, 82]])\ngrades\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\n\n\nCode\ngrades[0, 1]  # row 0, column 1\n\n\n96\n\n\nTo select a single row, specify only one index in square brackets:\n\n\nCode\ngrades[1]\n\n\narray([100,  87,  90])\n\n\nTo select multiple sequential rows, use slice notation:\n\n\nCode\ngrades[0:2]\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nTo select multiple non-sequential rows, use a list of row indices:\n\n\nCode\ngrades[[1, 3]]\n\n\narray([[100,  87,  90],\n       [100,  81,  82]])\n\n\nYou can select subsets of the columns by providing a tuple specifying the row(s) and column(s) to select. Each can be a specific index, a slice or a list. Let’s select only the elements in the first column:\n\n\nCode\ngrades[:, 0]\n\n\narray([ 87, 100,  94, 100])\n\n\nThe 0 after the comma indicates that we’re selecting only column 0. The : before the comma indicates which rows within that column to select. In this case, : is a slice representing all rows. You can select consecutive columns using a slice:\n\n\nCode\ngrades[:, 1:3]\n\n\narray([[96, 70],\n       [87, 90],\n       [77, 90],\n       [81, 82]])\n\n\nor specific columns using a list of column indices:\n\n\nCode\ngrades[:, [0, 2]]\n\n\narray([[ 87,  70],\n       [100,  90],\n       [ 94,  90],\n       [100,  82]])\n\n\n\n10.3.1 Views: Shallow Copies\nViews are objects “see” the data in other objects, rather than having their own copies of the data. Views are also known as shallow copies. Various array methods and slicing operations produce views of an array’s data. The array method view returns a new array object with a view of the original array object’s data. First, let’s create an array and a view of that array:\n\n\nCode\nnumbers = np.arange(1, 6)\nnumbers2 = numbers.view()\n\n\nWe can use the built-in id() function to see that numbers and numbers2 are different objects:\n\n\nCode\nid(numbers), id(numbers2)\n\n\n(2050186483472, 2050186488944)\n\n\nTo prove that numbers2 views the same data as numbers, let’s modify an element in numbers, then display both arrays:\n\n\nCode\nnumbers[1] *= 10\nnumbers\n\n\narray([ 1, 20,  3,  4,  5])\n\n\n\n\nCode\nnumbers2\n\n\narray([ 1, 20,  3,  4,  5])\n\n\nSimilarly, changing a value in the view also changes that value in the original array:\n\n\nCode\nnumbers2[1] /= 10\nnumbers, numbers2\n\n\n(array([1, 2, 3, 4, 5]), array([1, 2, 3, 4, 5]))\n\n\nSlices also create views. Let’s make numbers2 a slice that views only the first three elements of numbers:\n\n\nCode\nnumbers2 = numbers[0:3]\nnumbers2\n\n\narray([1, 2, 3])\n\n\nAgain, we can confirm that numbers and numbers2 are different objects with id():\n\n\nCode\nid(numbers), id(numbers2)\n\n\n(2050186483472, 2050186489712)\n\n\nNow, let’s modify an element both arrays share, then display them. Again, we see that numbers2 is a view of numbers:\n\n\nCode\nnumbers[1] *= 20\nnumbers\n\n\narray([ 1, 40,  3,  4,  5])\n\n\n\n\nCode\nnumbers2\n\n\narray([ 1, 40,  3])\n\n\n\n\n10.3.2 Deep Copies\nThough views are separate array objects, they save memory by sharing element data from other arrays. However, when sharing mutable values, sometimes it’s necessary to create a deep copy with independent copies of the original data. This is especially important in multi-core programming, where separate parts of your program could attempt to modify your data at the same time, possibly corrupting it.\nThe array method copy returns a new array object with a deep copy of the original array object’s data. First, let’s create an array and a deep copy of that array:\n\n\nCode\nnumbers = np.arange(1, 6)\nnumbers2 = numbers.copy()\n\n\nTo prove that numbers2 has a separate copy of the data in numbers, let’s modify an element in numbers, then display both arrays:\n\n\nCode\nnumbers[1] *= 10\nnumbers\n\n\narray([ 1, 20,  3,  4,  5])\n\n\n\n\nCode\nnumbers2\n\n\narray([1, 2, 3, 4, 5])\n\n\n\nIf you need deep copies of other types of Python objects, pass them to the copy module’s deepcopy() function.\n\n\n\n10.3.3 Reshaping and Transposing\nWe’ve used array method reshape() to produce two-dimensional arrays from one-dimensional ranges. NumPy provides various other ways to reshape arrays.\nThe array methods reshape() and resize() both enable you to change an array’s dimensions. Method reshape() returns a view (shallow copy) of the original array with the new dimensions. It does not modify the original array:\n\n\nCode\ngrades = np.array([[87, 96, 70], [100, 87, 90]])\ngrades\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\n\n\nCode\ngrades.reshape(1, 6)\n\n\narray([[ 87,  96,  70, 100,  87,  90]])\n\n\n\n\nCode\ngrades\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nMethod resize() modifies the original array’s shape:\n\n\nCode\ngrades.resize(1, 6)\ngrades\n\n\narray([[ 87,  96,  70, 100,  87,  90]])\n\n\nYou can take a multidimensional array and flatten it into a single dimension with the methods flatten() and ravel(). Method flatten deep copies the original array’s data:\n\n\nCode\ngrades = np.array([[87, 96, 70], [100, 87, 90]])\ngrades\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\n\n\nCode\nflattened = grades.flatten()\nflattened\n\n\narray([ 87,  96,  70, 100,  87,  90])\n\n\n\n\nCode\ngrades\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nMethod ravel() produces a view of the original array, which shares the grades array’s data!\n\n\nCode\nraveled = grades.ravel()\nraveled\n\n\narray([ 87,  96,  70, 100,  87,  90])\n\n\n\n\nCode\nraveled[0] = 100\ngrades\n\n\narray([[100,  96,  70],\n       [100,  87,  90]])\n\n\nYou can quickly transpose an array’s rows and columns, so the rows become the columns and the columns become the rows. The T attribute returns a transposed view (shallow copy) of the array. The original grades array represents two students’ grades (the rows) on three exams (the columns). Let’s transpose the rows and columns to view the data as the grades on three exams (the rows) for two students (the columns):\n\n\nCode\ngrades.T\n\n\narray([[100, 100],\n       [ 96,  87],\n       [ 70,  90]])\n\n\nTransposing does not modify the original array:\n\n\nCode\ngrades\n\n\narray([[100,  96,  70],\n       [100,  87,  90]])\n\n\nYou can combine arrays by adding more columns or more rows — known as horizontal stacking and vertical stacking. Let’s create another 2-by-3 array of grades:\n\n\nCode\ngrades2 = np.array([[94, 77, 90], [100, 81, 82]])\ngrades2\n\n\narray([[ 94,  77,  90],\n       [100,  81,  82]])\n\n\nLet’s assume grades2 represents three additional exam grades for the two students in the grades array. We can combine grades and grades2 with NumPy’s hstack() (horizontal stack) function by passing a tuple containing the arrays to combine. The extra parentheses are required because hstack() expects one argument:\n\n\nCode\nnp.hstack((grades, grades2))\n\n\narray([[100,  96,  70,  94,  77,  90],\n       [100,  87,  90, 100,  81,  82]])\n\n\nNext, let’s assume that grades2 represents two more students’ grades on three exams. In this case, we can combine grades and grades2 with NumPy’s vstack() (vertical stack) function:\n\n\nCode\nnp.vstack((grades, grades2))\n\n\narray([[100,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\n\n\n10.3.4 NumPy Calculation Methods\nAn array has various methods that perform calculations using its contents. By default, these methods ignore the array’s shape and use all the elements in the calculations. For example, calculating the mean of an array totals all of its elements regardless of its shape, then divides by the total number of elements. You can perform these calculations on each dimension as well. For example, in a two-dimensional array, you can calculate each row’s mean and each column’s mean.\n\n\nCode\ngrades = np.array([[87, 96, 70], [100, 87, 90],\n                    [94, 77, 90], [100, 81, 82]])\ngrades\n\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\nWe can use methods to calculate sum(), min(), max(), mean(), std() (standard deviation) and var() (variance) — each is a functional-style programming reduction:\n\n\nCode\nprint(grades.sum())\nprint(grades.min())\nprint(grades.max())\nprint(grades.mean())\nprint(grades.std())\nprint(grades.var())\n\n\n1054\n70\n100\n87.83333333333333\n8.792357792739987\n77.30555555555556\n\n\n\n10.3.4.1 Calculations by Row or Column\nMany calculation methods can be performed on specific array dimensions, known as the array’s axes. These methods receive an axis keyword argument that specifies which dimension to use in the calculation, giving you a quick way to perform calculations by row or column in a two-dimensional array.\nAssume that you want to calculate the average grade on each exam, represented by the columns of grades. Specifying axis=0 performs the calculation on all the row values within each column:\n\n\nCode\ngrades.mean(axis=0)\n\n\narray([95.25, 85.25, 83.  ])\n\n\nSo 95.25 above is the average of the first column’s grades (87, 100, 94 and 100), 85.25 is the average of the second column’s grades (96, 87, 77 and 81) and 83 is the average of the third column’s grades (70, 90, 90 and 82). Similarly, specifying axis=1 performs the calculation on all the column values within each individual row. To calculate each student’s average grade for all exams, we can use:\n\n\n\n\nsource: https://scipy-lectures.org/_images/reductions.png\n\n\n\nCode\ngrades.mean(axis=1)\n\n\narray([84.33333333, 92.33333333, 87.        , 87.66666667])\n\n\nThis produces four averages—one each for the values in each row. So 84.33333333 is the average of row 0’s grades (87, 96 and 70), and the other averages are for the remaining rows. See https://numpy.org/doc/stable/reference/arrays.ndarray.html for more methods.\nThe sub-module numpy.linalg implements basic linear algebra, such as solving linear systems, singular value decomposition, etc. However, it is not guaranteed to be compiled using efficient routines, and thus we recommend the use of scipy.linalg which will introduce in later chapter."
  },
  {
    "objectID": "10_11_NumPy.html#array-operators",
    "href": "10_11_NumPy.html#array-operators",
    "title": "10  Array-Oriented Programming with NumPy",
    "section": "10.4 array Operators",
    "text": "10.4 array Operators\nNumPy provides many operators which enable you to write simple expressions that perform operations on entire arrays. First, let’s perform element-wise arithmetic with arrays and numeric values by using arithmetic operators and augmented assignments. Element-wise operations are applied to every element, so snippet below multiplies every element by 2 and cubes every element. Each returns a new array containing the result:\n\n\nCode\nnumbers = np.arange(1, 6) # array([1,2,3,4,5])\nnumbers * 2\n\n\narray([ 2,  4,  6,  8, 10])\n\n\n\n\nCode\nnumbers ** 3\n\n\narray([  1,   8,  27,  64, 125], dtype=int32)\n\n\nAugmented assignments modify every element in the left operand in place!\n\n\nCode\nnumbers += 10\nnumbers\n\n\narray([11, 12, 13, 14, 15])\n\n\n\n10.4.1 Broadcasting\nNormally, the arithmetic operations require as operands two arrays of the same size and shape. When one operand is a single value, called a scalar, NumPy performs the elementwise calculations as if the scalar were an array of the same shape as the other operand, but with the scalar value in all its elements. This is called broadcasting. Snippets above use this capability. For example, numbers * 2 is equivalent to numbers * [2, 2, 2, 2, 2]\nBroadcasting also can be applied between arrays of different sizes and shapes, enabling some concise and powerful manipulations. We’ll show more examples of broadcasting later in the chapter when we introduce NumPy’s universal functions.\n\n10.4.1.1 Arithmetic Operations Between arrays\nYou may perform arithmetic operations and augmented assignments between arrays of the same shape. Let’s multiply the one-dimensional arrays numbersand numbers2 (created below) that each contain five elements:\n\n\nCode\nnumbers2 = np.linspace(1.1, 5.5, 5) # array([ 1.1,  2.2,  3.3,  4.4,  5.5])\nnumbers * numbers2\n\n\narray([12.1, 26.4, 42.9, 61.6, 82.5])\n\n\nThe result is a new array formed by multiplying the arrays element-wise in each operand — 11 * 1.1, 12 * 2.2, 13 * 3.3, etc. Arithmetic between arrays of integers and floating-point numbers results in an array of floating-point numbers.\n\n\nCode\nc = np.ones((3, 3))\nc * c \n\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\nNote that the above operation is not matrix multiplication, to perform matrix multiplication use the dot() method!\n\n\nCode\nc.dot(c)\n\n\narray([[3., 3., 3.],\n       [3., 3., 3.],\n       [3., 3., 3.]])\n\n\nWe can similarly extend broadcasting to arrays of higher dimension. Observe the result when we add a one-dimensional array to a two-dimensional array:\n\n\nCode\na = np.array([0, 1, 2])\nM = np.ones((3, 3))\nM + a\n\n\narray([[1., 2., 3.],\n       [1., 2., 3.],\n       [1., 2., 3.]])\n\n\nHere the one-dimensional array a is stretched, or broadcasted, across the second dimension in order to match the shape of M.\n\n\n10.4.1.2 Rules of Broadcasting\nBroadcasting in NumPy follows a strict set of rules to determine the interaction between the two arrays:\n\nRule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.\nRule 2: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.\nRule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is raised.\n\n\n\n\n\nsource: https://scipy-lectures.org/_images/numpy_broadcasting.png\n\nNow let’s take a look at an example where both arrays need to be broadcast:\n\n\nCode\na = np.arange(3).reshape((3, 1))\nb = np.arange(3)\na + b\n\n\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\nWe’ll start by determining the shapes of the arrays:\n\na.shape is (3,1)\nb.shape is (3,)\n\nRule 1 says we must pad the shape of b with ones:\n\na.shape is (3,1)\nb.shape becomes (1,3)\n\nAnd rule 2 tells us that we must upgrade each of these 1s to match the corresponding size of the other array:\n\na.shape is (3,3)\nb.shape becomes (3,3)\n\nNow because the results match, these shapes are compatible!\nNext, let’s take a look at an example in which the two arrays are not compatible!\n\n\nCode\nM = np.ones((3, 2))\na = np.arange(3)\n\n\nWe’ll start by determining the shapes of the arrays:\n\nM.shape is (3,2)\na.shape is (3,)\n\nRule 1 says we must pad the shape of a with ones:\n\na.shape is (3,2)\nb.shape becomes (1,3)\n\nBy rule 2, the first dimension of a is then stretched to match that of M:\n\nM.shape is (3,2)\na.shape becomes (3,3)\n\nNow we hit rule 3 — the final shapes do not match, so these two arrays are incompatible, as we can observe by attempting this operation:\n\n\nCode\nM + a\n\n\nValueError: operands could not be broadcast together with shapes (3,2) (3,) \n\n\n\n\n10.4.1.3 Comparing arrays\nYou can compare arrays with individual values and with other arrays. Comparisons are performed element-wise. Such comparisons produce arrays of Boolean values in which each element’s True or False value indicates the comparison result:\n\n\nCode\nnumbers &gt;= 13 # numbers = array([11, 12, 13, 14, 15])\n\n\narray([False, False,  True,  True,  True])\n\n\nThe above implicitly used broadcating!\n\n\nCode\nnumbers2 &lt; numbers # numbers2 = array([ 1.1,  2.2,  3.3,  4.4,  5.5])\n\n\narray([ True,  True,  True,  True,  True])\n\n\n\n\nCode\nnumbers == numbers2\n\n\narray([False, False, False, False, False])\n\n\n\n\nCode\nnumbers == numbers\n\n\narray([ True,  True,  True,  True,  True])"
  },
  {
    "objectID": "10_11_NumPy.html#universal-functions",
    "href": "10_11_NumPy.html#universal-functions",
    "title": "10  Array-Oriented Programming with NumPy",
    "section": "10.5 Universal Functions",
    "text": "10.5 Universal Functions\nNumPy offers dozens of standalone universal functions (or ufuncs) that perform various element-wise operations (which means it applies the same operation to each element in the array). Each performs its task using one or two array or array-like (such as lists) arguments. Some of these functions are called when you use operators like + and * on arrays. Each returns a new array containing the results.\n\n10.5.1 The Slowness of Loops\nComputation on NumPy arrays can be very fast, or it can be very slow. The key to making it fast is to use vectorized operations, generally implemented through NumPy’s universal functions (ufuncs). The relative sluggishness of Python generally manifests itself in situations where many small operations are being repeated; for instance, looping over arrays to operate on each element. For example, imagine we have an array of values and we’d like to compute the reciprocal of each. A straightforward approach might look like this:\n\n\nCode\ndef compute_reciprocals(values):\n    output = np.empty(len(values))\n    for i in range(len(values)):\n        output[i] = 1.0 / values[i]\n    return output\n\nvalues = np.random.randint(1, 10, 5)\ncompute_reciprocals(values)\n\n\narray([0.14285714, 0.14285714, 0.25      , 0.16666667, 0.2       ])\n\n\nBut if we measure the execution time of this code for a large input, we see that this operation is very slow\n\n\nCode\nbig_array = np.random.randint(1, 10, 1_000_000)\n%timeit compute_reciprocals(big_array)\n\n\n1.22 s ± 9.99 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\nIt turns out that the bottleneck here is not the operations themselves, but the type checking and function dispatches that Python must do at each cycle of the loop. Each time the reciprocal is computed, Python first examines the object’s type and does a dynamic lookup of the correct function to use for that type. If we were working in compiled code instead, this type specification would be known before the code executed and the result could be computed much more efficiently.\nFor many types of operations, NumPy provides a convenient interface into just this kind of statically typed, compiled routine. This is known as a vectorized operation. For simple operations like the element-wise division here, vectorization is as simple as using Python arithmetic operators directly on the array object. This vectorized approach is designed to push the loop into the compiled layer that underlies NumPy,leading to much faster execution.\n\nVectorization in NumPy refers to the practice of performing operations on entire arrays of data, rather than on individual elements. This is accomplished by applying an operation to the entire array, instead of looping through each element of the array one at a time.\n\n\n\nCode\nprint(1.0 / values)\n\n\n[0.14285714 0.14285714 0.25       0.16666667 0.2       ]\n\n\nLooking at the execution time for our big array, we see that it completes orders of magnitude faster than the Python loop:\n\n\nCode\n%timeit (1.0 / big_array)\n\n\n2.21 ms ± 58.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\nVectorized operations in NumPy are implemented via ufuncs, whose main purpose is to quickly execute repeated operations on values in NumPy array.\n\n10.5.1.1 Exploring NumPy’s Ufuncs\nLet’s add two arrays with the same shape, using the add universal function:\n\n\nCode\nnumbers2 = np.arange(1, 7) * 10 # array([10, 20, 30, 40, 50, 60])\nnp.add(numbers, numbers2) # equivalent to numbers + numbers2\n\n\narray([11, 24, 39, 56, 75, 96])\n\n\n\n\n10.5.1.2 Broadcasting with Universal Functions\nLet’s use the multiply universal function to multiply every element of numbers2 by the scalar value 5:\n\n\nCode\nnp.multiply(numbers2, 5) # equivalent to numbers2 * 5\n\n\narray([ 50, 100, 150, 200, 250, 300])\n\n\nLet’s reshape numbers2 into a 2-by-3 array, then multiply its values by a one-dimensional array of three elements:\n\n\nCode\nnumbers3 = numbers2.reshape(2, 3)\nnumbers4 = np.array([2, 4, 6])\nnumbers3, numbers4\n\n\n(array([[10, 20, 30],\n        [40, 50, 60]]),\n array([2, 4, 6]))\n\n\n\n\nCode\nnp.multiply(numbers3, numbers4) # Equivalent to numbers3 * numbers4\n\n\narray([[ 20,  80, 180],\n       [ 80, 200, 360]])\n\n\nThis works because numbers4 has the same length as each row of numbers3, so NumPy can apply the multiply operation by treating numbers4 as if it were the following array:\narray([[2, 4, 6],\n       [2, 4, 6]])\nIf a universal function receives two arrays of different shapes that do not support broadcasting, a ValueError occurs. You can view the broadcasting rules at https://numpy.org/doc/stable/user/basics.broadcasting.html.\n\nVectorization and ufunc functions are closely related to broadcasting in NumPy, as they are often used together to perform element-wise operations on arrays of different shapes. By combining vectorization, ufunc functions, and broadcasting, you can efficiently perform complex arithmetic operations on arrays in NumPy.\n\nThere are other special ufunc. Let’s create an array and calculate the square root of its values, using the sqrt universal function:\n\n\nCode\nnumbers = np.array([1, 4, 9, 16, 25, 36])\nnp.sqrt(numbers)\n\n\narray([1., 2., 3., 4., 5., 6.])\n\n\n\n\n10.5.1.3 Create Your Own Vectorizing functions\nTo get good performance we should try to avoid looping over elements in our vectors and matrices, and instead use vectorized algorithms. The first step in converting a scalar algorithm to a vectorized algorithm is to make sure that the functions we write work with vector inputs.\n\n\nCode\ndef Theta(x):\n    \"\"\"\n    Scalar implemenation of the Heaviside step function.\n    \"\"\"\n    if x &gt;= 0:\n        return 1\n    else:\n        return 0\n\n\n\n\nCode\nTheta_vec = np.vectorize(Theta)\nTheta_vec(np.array([-3,-2,-1,0,1,2,3]))\n\n\narray([0, 0, 0, 1, 1, 1, 1])\n\n\nYou can view the complete list, their descriptions and more information about universal functions at https://numpy.org/doc/stable/reference/ufuncs.html\n\n\n\n10.5.2 Type casting\nSince NumPy arrays are statically typed, the type of an array does not change once created. But we can explicitly cast an array of some type to another using the astype() functions (see also the similar asarray() function). This always creates a new array of a new type:\n\n\nCode\nM = np.random.rand(5,5)\nM.dtype\n\n\ndtype('float64')\n\n\n\n\nCode\nM2 = M.astype(np.int64)\nM2\n\n\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0]], dtype=int64)\n\n\nSee https://scipy-lectures.org/intro/numpy/elaborate_arrays.html for more details."
  },
  {
    "objectID": "10_11_NumPy.html#file-io",
    "href": "10_11_NumPy.html#file-io",
    "title": "10  Array-Oriented Programming with NumPy",
    "section": "10.6 File I/O",
    "text": "10.6 File I/O\nNumPy has its own binary format, not portable but with efficient I/O. This is useful when storing and reading back array data. Use the functions numpy.save() and numpy.load().\n\n\nCode\nnp.save(\"random-matrix.npy\", M)\nM2 = np.load(\"random-matrix.npy\")\nM2\n\n\narray([[0.63296042, 0.27197126, 0.2261708 , 0.1958696 , 0.9284412 ],\n       [0.27045565, 0.16168923, 0.06145811, 0.91101895, 0.03550733],\n       [0.52027297, 0.5984186 , 0.08252073, 0.80356072, 0.76129669],\n       [0.20675944, 0.47959083, 0.28455249, 0.03627423, 0.4218361 ],\n       [0.11976237, 0.47007539, 0.26740034, 0.51019782, 0.77871332]])\n\n\nIn summary:\nTo make the code faster using NumPy\n\nVectorizing for loops: Find tricks to avoid for loops using NumPy arrays.\nIn place operations: a *= 3 instead of a = 3*a\nUse views instead of copies whenever possible\nBroadcasting: Use broadcasting to do operations on arrays\n\nPython objects: - High-level objects: integers, floating-point - Containers: lists (costless append), dictionaries (fast lookup) - Python lists are very general. They can contain any kind of object and are dynamically typed - However, they do not support mathematical functions such as matrix and dot multiplications. Implementing such functions for Python lists would not be very efficient because of the dynamic typing\nNumPy provides:\n\nExtension package to Python for multi-dimensional arrays\nNumpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created\nBecause of the static typing, fast implementation of mathematical functions such as multiplication and addition of NumPy arrays can be implemented in a compiled language (C and Fortran is used). Moreover, Numpy arrays are memory efficient"
  }
]