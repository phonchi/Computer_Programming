[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer Programming",
    "section": "",
    "text": "Preface\nThis is the companion book for the course computer programming open in the Department of Applied Mathematics, National Sun Yat-sen University. It aims for students who need a basic understanding of procedural programming and object-oriented programming concepts using Python 3. We will have hands-on exercises and quizzes to help you get familiar with each topic, and students will exercise logical thinking and programming skills for dealing with scientific problems.\nThe book is based on several well-known books and resources, including:\n\nAutomate the Boring Stuff with Python, 2nd Edition\nBeyond the Basic Stuff with Python\nScipy Lecture Notes\nPython Data Science Handbook"
  },
  {
    "objectID": "01_Python.html#introduction",
    "href": "01_Python.html#introduction",
    "title": "1  Python Basics",
    "section": "1.1 Introduction",
    "text": "1.1 Introduction\nA programming language is a computer system created to allow humans to precisely express algorithms to the computer using a higher level of abstraction. Python is one of the top ten most-used languages, and remains popular in developing web applications, in scientific computation, and as an introductory language for students. Organizations that use Python range from Google to NASA, DropBox to Industrial Light & Magic, and across the spectrum of casual, scientific, and artistic computer users.\nPython emphasizes readability, and includes elements of the imperative, object-oriented, and functional programming paradigms, which will be explored later on. Python is an interpreted language, which for beginners means that Python instructions can be typed into an interactive prompt, or can be stored in a plain text file (called a “script”) and run later. These instructions are evaluated and the commands are executed by the Python interpreter in something called the shell.\n\n1.1.1 Hello, Python\nA command, often called a statement, instructs the interpreter to do something. The first program described in many programming Language introductions is “Hello, World”. This simple program outputs a nominal greeting, demonstrating how a particular language produces a result, and also how a language represents text.\n\nprint('Hello, World!')\n\nHello, World!\n\n\nThere are several aspects to note even in this simple Python statement. * First, print() is a built-in function, a pre-defined operation that Python can use to produce output, a result of the program that will be made visible to the user. The print is followed by opening and closing parentheses; what comes between those parentheses is the value or arguments to be printed.\n\nSecond, fixed values such as numbers, letters, and strings, are called constants or simple data type because their value does not change. String constants use single quotes ' or double quotes \" in Python. The quotation marks in front of the capital 'H' and after the exclamation point denotes the beginning and end of a string of characters that will be treated as a value in Python.\n\nProgramming languages carry out their instructions very precisely. If a user makes subtle changes to the message between the starting and finishing quotation marks within the print statement, the resultant printed text will change accordingly. Notice that it is possible for statements to span more than one line using \\ .\n\nprint('Hello,\\\n World')\n\nHello, World\n\n\n\nIn Jupyter Notebook, the print function can even be omitted if the statement you want to print is the last statement in the code.\n\n\n'hi python'\n'Hello, World!'\n\n'Hello, World!'\n\n\n\n1.1.1.1 Using string methods like a word processor\nOne of the simplest tasks you can do with strings is to change the case of the words in a string.\n\nprint('hi python'.title())\n\n'Hi Python'\n\n\nIn this example, we have the lowercase string ‘hi python’. The method title() appears after the string in the print() call. A method is an action that Python can perform on a piece of data. The dot (.) after the string tells Python to make the title() method act on the string. Every method is followed by a set of parentheses that can accept arguments just like a function.\nThere are also other useful methods for string\n\nprint('hi python'.upper())   # change a string to all uppercase \nprint('Hello World'.lower()) # change a string to all lowercase \nprint(' hi python '.strip()) # remove extra whitespace on the right and left sides of a string\n\nHI PYTHON\nhello world\nhi python\n\n\nThese example statements introduce another language feature. The # symbol denotes the beginning of a comment, a human-readable notation to the Python code that will be ignored by the computer when executed. A high-level description at the top of a script introduces a human reader to the overall purpose and methodology used in the script. All of the characters to the right of the # until the end of the line are ignored by Python.\n\n1.1.2 Exercise 1: Complete the following items to make sure you correctly set up the environment.\n\nOpen the explorer on the left-hand side\nConnect to the Python environment\nCreate a new code cell below and write a code snippet that prints out “finish”. Execute the cell.\nCreate a new script called “finish.py” and write a code snippet that prints out “finish”. Execute the script.\n\n\n\n\n\n1.1.3 Operators and Expressions\nBesides string, numbers are often used in programming. Python’s built-in operators allow numeric values to be manipulated and combined in a variety of familiar ways. Note that in Python, 2 + 3 is called an expression, which consists of values/operands (such as 2 or 3) and operators (such as +), and they are special statements! An expression is a combination of operators and operands that is interpreted to produce some other value.\n\n1.1.3.1 Using operand like a calculator\n\n# Integer\nprint(3+4)       # Prints “7”, which is 3 plus 4.\nprint(5-6)       # Prints “-1”, which is 5 minus 6\nprint(7*8)       # Prints “56”, which is 7 times 8\nprint(45/4)      # Prints “11.25”, which is 45 divided by 4, / is float(true) division\nprint(2**10)     # Prints “1024”, which is 2 to the 10th power\n\n7\n-1\n56\n11.25\n1024\n\n\n\nNote that we used ** to signify exponentiation, which can be somewhat surprising given that the caret symbol, ^, is often used for this purpose in some other programming languages. In Python, the caret operator belongs to XOR bitwise Boolean operations.\n\nWhen an operation such as forty-five divided by four produces a non-integer result, such as 11.25, Python implicitly switches to a floating-point representation. When purely integer answers are desired, a different set of operators can be used.\n\nprint(45//4)     # Prints “11”, which is 45 integer divided by 4, // is floor(integer) division\nprint(45%4)      # Prints “1”, because 4 * 11 + 1 = 45\n\n11\n1\n\n\nThe double slash signifies the integer floor division operator, while the percentage symbol signifies the modulus, or remainder operator. Taken together, we can read these calculations as, “Four goes into forty-five eleven times, with a remainder of one.”\nString values also can be combined and manipulated in some intuitive ways.\n\ns = 'hello' + 'world'\nt = s * 4\nprint(t)    # Prints “helloworldhelloworldhelloworldhelloworld”\n\nhelloworldhelloworldhelloworldhelloworld\n\n\nThe plus operator concatenates string values, while the multiplication operator replicates string values."
  },
  {
    "objectID": "01_Python.html#variables",
    "href": "01_Python.html#variables",
    "title": "1  Python Basics",
    "section": "1.2 Variables",
    "text": "1.2 Variables\nA variable is like a box in the computer’s memory where you can store value. If you want to use the result of an evaluated expression later in your program, you can save it inside a variable. You’ll store values in variables with an assignment statement. An assignment statement consists of a variable name, an equal sign, and the value to be stored. In Python, every single thing is stored as an object. A Python variable is actually a reference to an object!\n\n\n\n\nsource: https://runestone.academy/ns/books/published/cpp4python/AtomicData/AtomicData.html\n\n\nvarName = 100\n\nA variable is initialized (or created) the first time a value is stored in it. After that, you can use it in statements with other variables and values. When a variable is assigned a new value, the old value is forgotten. This is called overwriting the variable.\n\nspam = 'Hello'   # 'Hello' is a string object\nprint(spam)      # spam is a variable, it is just a reference or tag\nspam = 'Goodbye' # 'Goodbye' is another string object\nprint(spam)\n\nHello\nGoodbye\n\n\n\nIt’s much better to think of variables as labels that you can assign to values. You can also say that a variable references a certain value.\n\nThe naming of variables is largely up to the user in Python. Python’s simple rules are that variable names must begin with an alphabet letter or the underscore character, and may consist of an arbitrary number of letters, digits, and the underscore character (A-z, 0-9, and _ ). While a variable named m may be sufficient for a two line example script, experienced programmers strive to give meaningful, descriptive variable names in their scripts.\n\n\n\n\n\n\n\nValid variable names\nInvalid variable names\n\n\n\n\ncurrent_balance\ncurrent-balance (hyphens are not allowed)\n\n\ncurrentBalance\ncurrent balance (spaces are not allowed)\n\n\naccount4\n4account (can’t begin with a number)\n\n\n_42\n42 (can’t begin with a number)\n\n\nTOTAL_SUM\nTOTAL_$UM (special characters like $ are not allowed)\n\n\nhello\n‘hello’ (special characters like ’ are not allowed)\n\n\n\nPython variable names are case-sensitive, meaning that capitalization matters. A variable named size is treated as distinct from variables named Size or SIZE. A small number of keywords, names that are reserved for special meaning in Python, cannot be used as variable names. You can view this list by accessing the built-in Python help system.\n\nhelp('keywords')\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nVariables can be used to store all of the types of data values that Python is able to represent.\n\nmy_string = 'characters'\nmy_Boolean = True # True/False\nmy_integer = 5\nmy_floating_point = 26.2\nmy_complex = 2+1j # Note that 1 can not be omitted\n\n# You can condense the above statements into one line separated by ;\nmy_string = 'characters'; my_Boolean = True; my_integer = 5; my_floating_point = 26.2; my_complex = 2+1j\n\n\n### Multiple Assignment!\n# You can also assign values to more than one variable using just a single line of code!\nmy_string, my_Boolean, my_integer, my_floating_point, my_complex = 'characters',  True, 5, 26.2, 2+1j\n\n\nprint(10)\nprint(3.14)\nprint(2e10)   # scientific notation\nprint(12_000) # you can group digits using underscores to make large numbers more readable\nprint(3+2j)\n\n10\n3.14\n20000000000.0\n12000\n(3+2j)\n\n\nNote that when you’re writing long numbers, you can group digits using underscores to make large numbers more readable. In addition, print() can be used to print any numerical number including those in scientific notation.\n\n1.2.1 Data types\nIn Python variables and constants have a type. We can ask Python what type something is by using the type() function\n\ntype('Hello, World!'), type(False), type(4), type(3.2), type(3+5j)\n\n(str, bool, int, float, complex)\n\n\n\ntype(my_string),  type(my_Boolean), type(my_integer), type(my_floating_point), type(my_complex)\n\n(str, bool, int, float, complex)\n\n\nYou can convert object of one type to another using cast by str(), float(), int(), etc.\n\nfloat(3)\n\n3.0\n\n\n\nint(3.9)\n\n3\n\n\n\nint('3')\n\n3\n\n\n\nstr(3)\n\n'3'\n\n\nPython ord() and chr() are built-in functions. They are used to convert a character to an int and vice versa. Python ord() and chr() functions are exactly opposite of each other.\nPython ord() function takes string argument of a single Unicode character and return its integer Unicode code point value. Let’s look at some examples of using ord() function.\n\nx = ord('A')\nprint(x)\n\n65\n\n\nPython chr() function takes integer argument and return the string representing a character at that code point.\n\ny = chr(65)\nprint(y)\n\nA\n\n\n\n1.2.1.1 Conversion\nThere are two types of type conversion in Python.\n\nImplicit Conversion - automatic type conversion. Python always converts smaller data types to larger data types to avoid the loss of data.\nExplicit Conversion - manual type conversion\n\n\n5 + 4.2 # Implicit conversion\n\n9.2\n\n\nIn Python, complex &gt; float &gt; int &gt; bool\n\nint(4.7) + 3 # Explicit conversion\n\n7\n\n\n\n\n\n1.2.2 Debugging\nProgramming languages are not very forgiving for beginners, and a great deal of time learning to write software can be spent trying to find bugs, or errors in the code. Locating such bugs and correcting them is thus known as debugging. There are three major classes of bug that we create in software: syntax errors (mistakes in the symbols that have been typed), semantic errors (mistakes in the meaning of the program), and runtime errors (mistakes that occur when the program is executed.)\nSyntax errors are the most common for novices, and include simple errors such as forgetting one of the quote marks at the beginning or ending of a text string, failing to close open parentheses, or misspelling the function name print(). The Python interpreter will generally try to point these errors out when it encounters them, displaying an offending line number and a description of the problem. With some practice, a beginner can quickly learn to recognize and interpret common error cases. As examples:\n\nprint(5 + )\n\nSyntaxError: invalid syntax (Temp/ipykernel_24072/2298961889.py, line 1)\n\n\nThis expression is missing a value between the addition operator and the closing parenthesis.\n\nprint(mystring)\n\nNameError: name 'mystring' is not defined\n\n\nIn this case it found a name error and reports that the variable being printed has not been defined. Python can’t identify the variable name provided.\n\npront(5)\n\nNameError: name 'pront' is not defined\n\n\nLike calling someone by the wrong name, misspelling the name of a known function or variable can result in confusion and embarrassment.\nSemantic errors are flaws in the algorithm, or flaws in the way the algorithm is expressed in a language. Examples might include using the wrong variable name in a calculation, or getting the order of arithmetic operations wrong in a complex expression. Python follows the standard rules for operator precedence, so in an expression like total_pay = 40 + extra_hours * pay_rate, the multiplication will be performed before the addition, incorrectly calculating the total pay. (Unless your pay rate happens to be $1/hour.) Use parenthesis to properly specify the order of operations in complex expressions, thereby avoiding both semantic errors and code that may be harder to understand (e.g., total_pay = (40 + extra_hours) * pay_rate).\nFinally, runtime errors at this level might include unintentionally dividing by zero or using a variable before you have defined it. Python reads statements from top to bottom, and it must see an assignment statement to a variable before that variable is used in an expression.\n\n5/0\n\nZeroDivisionError: division by zero"
  },
  {
    "objectID": "01_Python.html#the-first-program",
    "href": "01_Python.html#the-first-program",
    "title": "1  Python Basics",
    "section": "1.3 The first program",
    "text": "1.3 The first program\nWhile the interactive shell is good for running Python instructions one at a time, sometimes you have to use a script, to write entire Python programs. In this case, you’ll type the instructions into the file editor.\n\n%%writefile hello.py\n\"\"\"\nThis program says hello and asks for your name.\nIt also ask the age of you.\n\"\"\"\n\nprint('Hello, world!')\nmyName = input('What is your name? ') # ask for their name\nprint('It is good to meet you, ' + myName)\nprint('The length of your name is:\\n' + str(len(myName)))\nmyAge = input('What is your age? ') # ask for their age\nprint('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nWriting hello.py\n\n\nOnce you’ve entered your source code, the ipython magic %%writefile will save it so that you won’t have to retype it each time you start. You can then use another magic %run to execute the python script.\n\n%run hello.py\n\nHello, world!\nIt is good to meet you, phonchi\nThe length of your name is:\n7\nYou will be 33 in a year.\n\n\n\n1.3.1 Dissecting Your Program\nWith your new program open in the file editor, let’s take a quick tour of the Python instructions it uses by looking at what each line of code does.\n\nThe first line is the comment that tells others your intention of this program or the authorship of the program. Here it uses the multiline comment by using the triple quotes. The line print('Hello, world!') means “Print out the text in the string ‘Hello, world!’.” When Python executes this line, you say that Python is calling the print() function and the string value is being passed to the function. A value that is passed to a function call is an argument. When you write a function name, the opening and closing parentheses at the end identify it as the name of a function.\nThe input() function waits for the user to type some text on the keyboard and press ENTER. The myName = input() function call evaluates to a string equal to the user’s text, and the line of code assigns the myName variable to this string value.\nThe following call to print('It is good to meet you, ' + myName) is an expression. 'It is good to meet you, ' and myName between the parentheses are concatenated together via the operand + and printed out.\nYou can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string. If you want to concatenate an integer such as 29 with a string to pass to print(), you’ll need to get the value ‘29’, which is the string form of 29. The str() function can be passed an integer value and will evaluate to a string value version of the integer. Besides, there is a \\n in the statement print('The length of your name is:\\n' + str(len(myName))). The string starts with the backslash has a special escape meaning and \\n means adding a newline.\nThe int() function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. The myAge variable contains the value returned from input(). You can use the int(myAge) code to return an integer value of the string in myAge. This integer value is then added to 1 in the expression int(myAge) + 1. The result of this addition is passed to the str() function: str(int(myAge) + 1). The string value returned is then concatenated with the strings 'You will be ' and ' in a year.' to evaluate one large string value. This large string is finally passed to print() to be displayed on the screen.\n\n\n1.3.2 Exercise 2: Write a script that inputs a five-digit integer from the user. Separate the number into its individual digits. Print them separated by three spaces each. For example, if the user types in the number 42339, the script should print 4 \\(~~\\) 2 \\(~~\\) 3 \\(~~\\) 3 \\(~~\\) 9\n\nHint: Use floor division (//) and remainder (%) to isolate the digits.\n\n# Your answer here\n# x=42339\n# Get the user's input from their keyboard and convert it to integer:\nx = _____('Enter a 5 digit integer')\n# Get the last digit by remainder\ndigits4 = \n# Perform floor division and get the remainig digits\nx = \n#....\n\n# Print out the results\n____(digits0,'   ',digits1,'   ',digits2,'   ',digits3,'   ',digits4)\n\n4     2     3     3     9"
  },
  {
    "objectID": "01_Python.html#the-zen-of-python",
    "href": "01_Python.html#the-zen-of-python",
    "title": "1  Python Basics",
    "section": "1.4 The zen of Python",
    "text": "1.4 The zen of Python\n\nimport this\n\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\n\nYou can compute expressions with a calculator or enter string concatenations with a word processor. You can even do string replication easily by copying and pasting text. But once you know how to handle the programing elements, you will be able to instruct Python to operate on large amounts of data automatically for you to replace these tasks.\nDon’t try to write perfect code; write code that works, and then decide whether to improve your code for that project or move on to something new. But as you continue to the next chapters and start digging into more involved topics, try to keep this philosophy of simplicity and clarity in mind.\n\nYou can also refer PEP8 which is a reference document that provides guidelines and best practices on how to write Python code."
  },
  {
    "objectID": "02_Flow_control.html#introduction",
    "href": "02_Flow_control.html#introduction",
    "title": "2  Flow Control",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nLast week, we learned the basics of individual instructions and that a program is just a series of instructions. But programming’s real strength isn’t just running one instruction after another. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you rarely want your programs to start from the first line of code and simply execute every line straight to the end. Flow control statements can decide which Python instructions to execute under which conditions.\nThese flow control statements directly correspond to the symbols in a flowchart. A flowchart usually has more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps (states) are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\n\n\nBut before you learn about flow control statements, you first need to learn how to represent those yes and no options and understand how to write those branching points as Python code. To that end, let’s explore Boolean values, comparison operators, and Boolean operators.\n\n2.1.1 Boolean expressions\nA boolean expression is an expression that is either true or false. The following examples use the operator ==, which compares two operands and produces True if they are equal and False otherwise:\n\n5 == 5, 5 == 6\n\nTrue and False are special values that belong to the class bool; they are not strings:\n\ntype(True), type(False)\n\nThe == operator is one of the comparison operators or relational operators; the others are:\n\n\n\n\nMeaning\n\n\n\n\nx != y\nx is not equal to y\n\n\nx &gt; y\nx is greater than y\n\n\nx &lt; y\nx is less than y\n\n\nx &gt;= y\nx is greater than or equal to y\n\n\nx &lt;= y\nx is less than or equal to y\n\n\nx is y\nx is the same as y\n\n\nx is not y\nx is not the same as y\n\n\n\n\nThe Python symbols are different from the mathematical symbols for the same operations. A common error is to use a single equal sign = instead of a double equal sign ==. Remember that = is used in the assignment statement and == is a comparison operator. There is no such thing as =&lt; or =&gt;.\n\nThese operators evaluate to True or False depending on the values you give them and, therefore, can be used in the decision point as a condition statement.\n\nprint(42==42)\nprint(42==42.0)         # It will compare its value!\nprint(42=='42')         # int/float are always different from string\nprint(2!=3)\nprint('hello'=='Hello') # Python is case sensitive\nprint(42 &lt; 100)\nprint(42 &gt;= 100)\n\n\n\n2.1.2 Boolean (Logical) Operators\nThe three Boolean operators (and, or, and not) are used to operate on Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let’s explore these operators in detail.\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nTrue and True\nTrue\n\n\nTrue and False\nFalse\n\n\nFalse and True\nFalse\n\n\nFalse and False\nFalse\n\n\n\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nTrue or True\nTrue\n\n\nTrue or False\nTrue\n\n\nFalse or True\nTrue\n\n\nFalse or False\nFalse\n\n\n\n\n\n\nExpression\nEvaluates to . . .\n\n\n\n\nnot True\nFalse\n\n\nnot False\nTrue\n\n\n\n\nprint((4 &lt; 5) and (5 &lt; 6))\nprint((6 &lt; 5) or (9 &lt; 6))\nprint((1 == 2) or (2 == 2))\nprint(not (1==3) and (3==4))\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. The Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the not operators first, then the and operators, and then the or operators."
  },
  {
    "objectID": "02_Flow_control.html#elements-of-flow-control",
    "href": "02_Flow_control.html#elements-of-flow-control",
    "title": "2  Flow Control",
    "section": "2.2 Elements of Flow Control",
    "text": "2.2 Elements of Flow Control\nIt can be shown that all programs could be written using three forms of control—namely, sequential execution, the selection statement and the repetition statement. This is the idea behind structured programming.\nFlow control statements often start with a part called the condition and are always followed by a block of code called the clause or body. The Boolean expressions you’ve seen so far could all be considered conditions, which are the same thing as expressions; the condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False. A flow control statement decides what to do based on whether its condition is True or False.\n\n2.2.1 Blocks of Code\nLines of Python code can be grouped together in blocks. You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.\n\nBlocks begin when the indentation increases.\nBlocks can contain other blocks.\nBlocks end when the indentation decreases to zero or to a containing block’s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let’s find the blocks in part of a small game program, shown here:\n\nname = 'Mary'\npassword = 'swordfish'\nif name == 'Mary':\n    print('Hello, Mary')\n    if password == 'swordfish':\n        print('Access granted.')\n    else:\n        print('Wrong password.')\n\nYou can view the execution of this program at https://autbor.com/blocks/. The first block of code starts at the line print('Hello, Mary') and contains all the lines after it. Inside this block is another block, which has only a single line in it: print('Access Granted.'). The third block is also one line long: print('Wrong password.').\nAn IndentationError occurs if you have more than one statement in a block and those statements do not have the same indentation:\n\nname = 'Mary'\npassword = 'swordfish'\nif name == 'Mary':\n  print('Hello, Mary')\n    if password == 'swordfish':\n        print('Access granted.')\n    else:\n        print('Wrong password.')\n\n\nIt is recomend to use four white spaces as the indentation\n\n\n\n2.2.2 Conditional execution\nThe control statement affords us a mechanism for jumping from one part of a program to another. In higher-level languages like Python, this enables what is called control structures, syntax patterns that allow us to express algorithms more succinctly. One example of this is the if-statement. An if statement’s body (that is, the block following the if statement) will execute if the statement’s condition is True. The body is skipped if the condition is False.\nIn Python, an if statement consists of the following:\n\nThe if keyword\nA condition (that is, an expression that evaluates to True or False)\nA colon\nStarting on the next line, an indented block of code (called the if body)\n\nThe boolean expression after the if statement is called the condition. We end the if statement with a colon character (:) and the line(s) after the if statement are indented. If the logical condition is true, then the indented statement gets executed. If the logical condition is false, the indented statement is skipped.\n\nname = 'Mary'\nif name == 'Alice':\n    print('Hi, Alice.')\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nA second form of the if statement is alternative execution, in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:\n\nif name == 'Alice':\n    print('Hi, Alice.')\nelse:\n    print('Hello, stranger.')\n\nYou can also write the above code in one line using the ternary conditional operator:\n\nprint('Hi, Alice.') if name == 'Alice' else print('Hello, stranger.') # Note that we do not have colon in between!\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nSince the condition must either be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution.\nSometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:\n\nname = 'Carol'\nage = 3000\nif name == 'Alice':\n    print('Hi, Alice.')\nelif age &lt; 12:\n    print('You are not Alice, kidd.')\nelse:\n    print('You are neither Alice nor a little kid.')\n\nYou can view the execution of this program at https://autbor.com/littlekid/. In plain English, this type of flow control structure would be “If the first condition is true, do this. Else, if the second condition is true, do that.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\n\n2.2.3 Exercise 1: Write a code that allows the user to input row and column. The program prints ‘black’ or ‘white’ depending on the color of the specified row and column of the chessboard. Chess boards are 8 x 8 spaces in size, and the rows and columns in this program begin at 0 and end at 7. If the inputs for a row or column are outside the 0 to 7 range, it should print ‘out of board’!\n\n\n\n\n\nsource: https://inventwithpython.com/pythongently/images/image011.png\n\n\nrow = int(input(\"Enter row\"))\ncolumn = int(input(\"Enter column\"))\n# If the column and row is out of bounds, print out of board:\nif column ____ or column ___ or row ___ or row ____:\n    print('out of board')\n# If the even/oddness of the column and row match, print 'white':\n____ column % _ == row % _:\n    print('white')\n# If they don't match, then print 'black':\n____:\n    print('black')\n\n\n\n2.2.4 Loops and Iterations\nYou can make a block of code execute over and over again using a while statement. The code in a while body will be executed as long as the while statement’s condition is True. In code, a while statement always consists of the following:\n\nThe while keyword\nA condition (that is, an expression that evaluates to True or False)\nA colon\nStarting on the next line, an indented block of code (called the while body)\n\n\nspam = 0\nwhile spam &lt; 5:\n    print('Hello, world.')\n    spam += 1 # equivalent to spam = spam + 1\n\n\nAugmented assignments abbreviate assignment expressions in which the same variable name appears on the left and right of the assignment’s = as above\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter2/\n\nMore formally, here is the flow of execution for a while statement:\n\nEvaluate the condition, yielding True or False.\nIf the condition is false, exit the while statement and continue execution at the next statement.\nIf the condition is true, execute the body and then go back to step 1.\n\nIn the while loop, the condition is always checked at the start of each iteration (that is, each time the loop is executed). If the condition is True, then the body is executed, and afterward, the condition is checked again. The first time the condition is found to be False, the while body is skipped.\nA common programming pattern is that we can run the program as long as the user wants by putting most of the program in a while loop. We’ll define a quit value and then keep the program running as long as the user has not entered the quit value:\n\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile message != 'quit':\n    message = input(prompt)\n    print(message)\n\nWe first set up a variable message to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time through the loop, the message is just an empty string, so Python enters the loop. At message = input(prompt), Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word ‘quit’, the prompt is displayed again and Python waits for more input. When the user finally enters ‘quit’, Python stops executing the while loop and the program ends.\n\nNote that Python considers 0, None, empty string, and empty container as False and all other things are True!\n\n\nbool(\"\"), bool(0), bool(None), bool(prompt), bool(12)\n\n\n2.2.4.1 Using break to Exit a Loop\nThe above program works well, except that it prints the word ‘quit’ as if it were an actual message. In fact, there is a shortcut to getting the program execution to break out of a while loop’s body early. If the execution reaches a break statement, it immediately exits the while loop’s body. In code, a break statement simply contains the break keyword.\n\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile True:\n    message = input(prompt)\n    if message == 'quit':\n        break\n    else:\n        print(message)\n\nThe fourth line creates an infinite loop; it is a while loop whose condition is always True. After the program execution enters this loop, it will exit the loop only when a break statement is executed. (An infinite loop that never exits is a common programming bug.)\nJust like before, this program asks the user to for the input. Now, however, while the execution is still inside the while loop, an if statement checks whether the message is equal to ‘quit’. If this condition is True, the break statement is run, and the execution moves out of the loop. Otherwise, the if statement’s body that contains the break statement is skipped, which again prints out the message. After that, the program execution jumps back to the start of the while statement to recheck the condition. Since this condition is merely the True Boolean value, the execution enters the loop to ask the user to type another message.\n\n\n2.2.4.2 continue Statemet\nRather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in that range:\n\ncurrent_number = 0\nwhile current_number &lt; 10:\n    current_number += 1\n    if current_number % 2 == 0:\n        continue\n    else:\n        print(current_number, end=' ')\n\nFirst, we set current_number to 0. Because it’s less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1, so current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0, the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current_number is not divisible by 2, the rest of the loop is executed and Python prints the current_number.\nNote that the built-in function print() displays its argument(s), then moves the cursor to the next line. You can change this behavior with the argument end. We used one space (’ ’), so each call to print displays the character’s value followed by one space.\n\nIf you ever run a program that has a bug causing it to get stuck in an infinite loop, press CTRL-C. This will send a KeyboardInterrupt error to your program and cause it to stop immediately.\n\n\n\n2.2.4.3 “TRUTHY” and “FALSY” Values\nLet us delve into the following program:\n\nname = ''\nwhile not name:\n    print('Enter your name:')\n    name = input()\n\nprint('How many guests will you have?')\nnumOfGuests = int(input())\n\nif numOfGuests:\n    print('Be sure to have enough room for all your guests.')\nprint('Done')\n\nYou can view the execution of this program at https://autbor.com/howmanyguests/. If the user enters a blank string for name, then the while statement’s condition will be True, and the program continues to ask for a name. If the value for numOfGuests is not 0, then the condition is considered to be True, and the program will print a reminder for the user. You could have entered not name != '' instead of not name, and numOfGuests != 0 instead of numOfGuests, but using the truthy and falsy values can make your code easier to read.\n\n\n\n2.2.5 for Loops and the range() Function\nThe while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function.\nIn code, a for statement looks something like for i in range(5): and includes the following:\n\nThe for keyword\nA variable name\nThe in keyword\nA call to the range() funtion with up to three integers passed to it (or an iterable object, which we will discuss later on)\nA colon\nStarting on the next line, an indented block of code (called the for body)\n\nLet’s create a new program to help you see a for loop in action.\n\nprint('My name is')\nfor i in range(5):\n    print('Jimmy Five Times (' + str(i) + ')')\n\nYou can view the execution of this program at https://autbor.com/fivetimesfor/. The code in the for loop’s body is run five times. The first time it is run, the variable i is set to 0. The print() call in the body will print Jimmy Five Times (0). After Python finishes an iteration through all the code inside the for loop’s body, the execution goes back to the top of the loop, and the for statement increments i by one. This is why range(5) results in five iterations through the body, with i being set to 0, then 1, then 2, then 3, and then 4. The variable i will go up to, but will not include, the integer passed to range().\nYou can actually use a while loop to do the same thing as a for loop; for loops are just more concise.\n\nprint('My name is')\ni = 0\nwhile i &lt; 5:\n    print('Jimmy Five Times (' + str(i) + ')')\n    i = i + 1\n\n\n2.2.5.1 The Starting, Stopping, and Stepping Arguments to range()\nSome functions can be called with multiple arguments separated by a comma, and range() is one of them. This lets you change the integer passed to range() to follow any sequence of integers, including starting at a number other than zero.\n\nfor i in range(12, 16):\n    print(i)\n\nThe range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.\n\nfor i in range(0, 10, 2):\n    print(i)\n\nThe range() function is flexible in the sequence of numbers it produces for for loops. For example , you can even use a negative number for the step argument to make the for loop count down instead of up.\n\nfor i in range(5, -1, -1):\n    print(i)\n\n\nNote that Python introduce switch statement as another control statement in Python 3.10\n\n\n2.2.6 Exercise 2: Write a script that displays the following triangle patterns. Use for loops to generate the patterns.\n\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\nHint: Try to use nested loops and use the outer loop to display each row while the inner loop to display each column\n\nfor row in range(__,__):\n    for column in range(__,__):\n        print('*', end='')\n    print()"
  },
  {
    "objectID": "02_Flow_control.html#importing-modules",
    "href": "02_Flow_control.html#importing-modules",
    "title": "2  Flow Control",
    "section": "2.3 Importing Modules",
    "text": "2.3 Importing Modules\nAll Python programs can call a basic set of functions called built-in functions, including the print(), input(), len() and range() functions you’ve seen before. Python also comes with a set of modules called the standard library. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematics-related functions. The random module has random number-related functions, and so on.\nBefore you can use the functions in a module, you must import the module with an import statement. In code, an import statement consists of the following:\n\nThe import keyword\nThe name of the module\nOptionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let’s give it a try with the random module, which will give us access to the random.randint() function.\n\nimport random\nfor i in range(5):\n    print(random.randint(1, 10))\n\nYou can view the execution of this program at https://autbor.com/printrandom/. The random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell Python to look for this function inside the random module. We will discuss it more in the following chapter.\n\nCheck out the Python standard library here or here\n\n\n2.3.1 Ending a Program Early with the sys.exit() Function\nThe last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.\n\n%%writefile exit.py\n\nimport sys\n\nwhile True:\n    print('Type exit to exit.')\n    response = input()\n    if response == 'exit':\n        sys.exit()\n    print('You typed ' + response + '.')\nprint('This line will not be printed')\n\n\n%run exit.py\n\nBy using expressions that evaluate to True or False (also called conditions), you can write programs that make decisions on what code to execute and what code to skip. You can also execute code over and over again in a loop while a certain condition evaluates to True. The break and continue statements are useful if you need to exit a loop or jump back to the loop’s start. These flow control statements will let you write more intelligent programs. You can also use another type of flow control by writing your own functions, which is the topic of the next chapter."
  },
  {
    "objectID": "03_Function.html#introductions",
    "href": "03_Function.html#introductions",
    "title": "3  Functions",
    "section": "3.1 Introductions",
    "text": "3.1 Introductions\nExperience has shown that the best way to develop and maintain a large program is to con struct it from smaller, more manageable pieces. This technique is called divide and conquer. We have already seen operations like print(), str() and len(), which involve parentheses wrapped around their operands. These are examples of Python’s built-in functions. Programming language allows us to use a name for a series of operations that should be performed on the given parameters. The appearance of a function in an expression or statement is known as a function call, or sometimes calling a function.\n\nIt allows you to execute a block of codes from various locations in your program by calling the function, rather than duplicating the code.\nIt also makes programs easier to modify. When you change a function’s code, all calls to the function execute the updated version.\n\n\nA function is a block of organized code that is used to perform a task. They provide better modularity and reusability."
  },
  {
    "objectID": "03_Function.html#def-statements-with-parameters",
    "href": "03_Function.html#def-statements-with-parameters",
    "title": "3  Functions",
    "section": "3.2 def Statements with Parameters",
    "text": "3.2 def Statements with Parameters\nWhen you call the print() or len() function, you pass them values, called arguments, by typing them between the parentheses. You can also define your own functions that accept arguments.\n\ndef hello(name):\n    print('Hello,', name)\n\nhello('Alice')\nhello('Bob')\n\nHello, Alice\nHello, Bob\n\n\nThe def statement defines the hello() function. Any indented lines that follow def hello(): make up the function’s body. The hello('Alice') line calls the now-created function. This function call is also known as passing the string value ‘Alice’ to the function.\n\n\n\nimage.png\n\n\nYou can view the execution of this program at https://autbor.com/hellofunc2/. The definition of the hello() function in this program has a parameter called name. When a function is called with arguments, the arguments are stored in the parameters. The first time the hello() function is called, it is passed the argument ‘Alice’. The program execution enters the function, and the parameter name is automatically set to ‘Alice’, which is what gets printed by the print() statement. One thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added print(name) after hello('Bob') in the previous program, the program would give you a NameError because there is no variable named name.\n\nprint(name)\n\nNameError: name 'name' is not defined\n\n\n\n3.2.1 Positional Arguments\nWhen you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is based on the order of the arguments provided. Values matched up this way are called positional arguments.\n\ndef describe_pet(animal_type, pet_name):\n    \"\"\"\n    Display information about a pet.\n    we can write multiple lines here!    \n    \"\"\"\n    print(\"\\nI have a\", animal_type, \".\")\n    print(\"My\", animal_type + \"'s name is\", pet_name.title() + \".\")\n\ndescribe_pet('hamster', 'harry')\n\n\nI have a hamster .\nMy hamster's name is Harry.\n\n\nWhen we call describe_pet(), we need to provide an animal_type and a name, in that order. For example, in the function call, the argument ‘hamster’ is assigned to the parameter animal_type and the argument ‘harry’ is assigned to the parameter pet_name. In the function body, these two parameters are used to display information about the pet being described.\nNote that the text on the second line is a comment called a docstring (multi-line comments introduced in Chapter 1), which describes what the function does. When Python generates documentation for the functions in your programs, it looks for a string immediately after the function’s definition. These strings are usually enclosed in triple quotes, which lets you write multiple lines. If you use the help() function, it will also be printed out as well as the function name and parameters.\n\nhelp(describe_pet)\n\nHelp on function describe_pet in module __main__:\n\ndescribe_pet(animal_type, pet_name)\n    Display information about a pet.\n    we can write multiple lines here!\n\n\n\n\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n\n\n\n\nNote that if there is more than one argument in print(), the default separation value is a white space. But you can change this behavior by specifying the sep keyword.\n\n\nprint(\"8\", \"9\", sep=\"*\")\n\n8*9\n\n\n\n\n3.2.2 Return Values and return Statements\nWhen you call the len() function and pass it an argument such as ‘Hello’, the function call evaluates to the integer value. The value that a function call evaluates to is called the return value of the function.\nWhen creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:\n\nThe return keyword\nThe value or expression that the function should return\n\nWhen an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on the number passed as an argument.\n\nimport random\n\ndef getAnswer(answerNumber):\n    if answerNumber == 1:\n        return 'It is certain'\n    elif answerNumber == 2:\n        return 'It is decidedly so'\n    elif answerNumber == 3:\n        return 'Yes'\n    elif answerNumber == 4:\n        return 'Reply hazy try again'\n    elif answerNumber == 5:\n        return 'Ask again later'\n    elif answerNumber == 6:\n        return 'Concentrate and ask again'\n    elif answerNumber == 7:\n        return 'My reply is no'\n    elif answerNumber == 8:\n        return 'Outlook not so good'\n    elif answerNumber == 9:\n        return 'Very doubtful'\n\nr = random.randint(1, 9)\nfortune = getAnswer(r)\nprint(fortune)\n\nYes\n\n\nYou can view the execution of this program at https://autbor.com/magic8ball/. When this program starts, Python first imports the random module. Then the getAnswer() function is defined. Because the function is being defined (and not called), the execution skips over the code in it. Next, the random.randint() function is called with two arguments: 1 and 9. It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named r.\nThe getAnswer() function is called with r as the argument. The program execution moves to the top of the getAnswer() function, and the value r is stored in a parameter named answerNumber. Then, depending on the value in answerNumber, the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that was originally called getAnswer(). The returned string is assigned to a variable named fortune, which then gets passed to a print() call and is printed to the screen. The functions that return values are sometimes called fruitful functions.\n\n\n3.2.3 The None Value\nIn Python, there is a value called None, which represents the absence of a value. The None value is the only value of the NoneType data type. This can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where None is used is as the return value of print(). The print() function displays text on the screen, but it doesn’t need to return anything. But since all function calls need to evaluate to a return value, print() returns None. A function does not return a value is called a void function\n\nspam = print('Hello!')\nprint(spam)\ntype(spam)\n\nHello!\nNone\n\n\nNoneType\n\n\n\nBehind the scenes, Python adds return None in the end of any function definition with no return statement. Also, if you use a return statement without a value (that is, just the return keyword by itself), then None is returned.\n\n\n\n3.2.4 Keyword Arguments\nA keyword argument is a name-value pair you pass to a function. You directly associate the name and the value within the argument, so when you pass the argument to the function, there’s no confusion. Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call.\n\ndescribe_pet(animal_type='hamster', pet_name='harry')\n\n\nI have a hamster .\nMy hamster's name is Harry.\n\n\nThe function describe_pet() hasn’t changed. But when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument ‘hamster’ to the parameter animal_type and the argument ‘harry’ to pet_name. The output correctly shows that we have a hamster named Harry.\n\n\n3.2.5 Default parameter values\nWhen writing a function, you can define a default value for each parameter. If an argument for a parameter is provided in the function call, Python uses the argument value. If not, it uses the parameter’s default value. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to ‘dog’:\n\ndef describe_pet(pet_name, animal_type='dog'):\n    \"\"\"\n    Display information about a pet.\n    Here we have default value for the animal type    \n    \"\"\"\n    print(\"\\nI have a \" + animal_type + \".\")\n    print(\"My\" + animal_type +\"'s name is \" + pet_name.title() + \".\")\n    \ndescribe_pet('willie')\n\n\nI have a dog.\nMydog's name is Willie.\n\n\nNow when the function is called with no animal_type specified, Python knows to use the value ‘dog’ for this parameter. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet’s name. Python still interprets this as a positional argument, so if the function is called with just a pet’s name, that argument will match up with the first parameter listed in the function’s definition.\n\nWhen you use default values, any parameter with a default value needs to be listed after all the parameters that don’t have default values. This allows Python to continue interpreting positional arguments correctly. Otherwise error occurs.\n\n\ndef describe_pet(animal_type='dog', pet_name):\n    \"\"\"\n    Display information about a pet.\n    Here we have default value for the animal type    \n    \"\"\"\n    print(\"\\nI have a \" + animal_type + \".\")\n    print(\"My\" + animal_type +\"'s name is \" + pet_name.title() + \".\")\n    \ndescribe_pet('willie')\n\nSyntaxError: non-default argument follows default argument (Temp/ipykernel_24512/574269134.py, line 1)"
  },
  {
    "objectID": "03_Function.html#advance-usage",
    "href": "03_Function.html#advance-usage",
    "title": "3  Functions",
    "section": "3.3 Advance usage",
    "text": "3.3 Advance usage\n\n3.3.1 Passing an Arbitrary Number of Arguments\nSometimes you won’t know how many arguments a function needs to accept ahead of time. Fortunately, Python allows a function to collect arbitrary arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings, but this parameter collects as many arguments as the calling line provides:\n\ndef make_pizza(size, *toppings):\n    \"\"\"Print the list of toppings that have been requested.\"\"\"\n    print(\"The size of the pizza is\", size, \"inch with the following toppings:\")\n    print(toppings)\n\nmake_pizza(6, 'pepperoni')\nmake_pizza(8, 'mushrooms', 'green peppers', 'extra cheese')\n\nThe size of the pizza is 6 inch with the following toppings:\n('pepperoni',)\nThe size of the pizza is 8 inch with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nIn the function definition, Python assigns the first value it receives to the parameter size. All other values that come after are stored in the tuple (which we will discuss in later chapters) with the name toppings. The function calls include an argument for the size first, followed by as many toppings as needed.\n\nYou’ll often see the generic parameter name *args, which collects arbitrary positional arguments like this. The *arg must be the rightmost parameter (except for parameter with default value and the **kwargs).\n\n\n\n3.3.2 Using Arbitrary Keyword Arguments\nSometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:\n\ndef build_profile(first, last, **user_info):\n    \"\"\"Build a dictionary containing everything we know about a user.\"\"\"\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nuser_profile = build_profile('albert', 'einstein',\n                             location='princeton',\n                             field='physics')\nprint(user_profile)\n\n{'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'}\n\n\nThe definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs (Keyword arguments) as they want. The double asterisks before the parameter **user_info cause Python to create a dictionary (Which we will discuss in later chapters) called user_info containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary.\nIn the body of build_profile(), we add the first and last names to the user_info dictionary because we’ll always receive these two pieces of information from the user, and they haven’t been placed into the dictionary yet. Then we return the user_info dictionary to the function call line.\n\nYou’ll often see the parameter name **kwargs used to collect nonspecific keyword arguments. The **kwargs must be the rightmost paramter.\n\n\n3.3.3 Exercise 1: Please write a function implementing the “guess the number” game. The function accepts two arguments for the maximum number of tries and the maximum number. The function returns a boolean value indicating whether the player guessed the number correctly or not. If the player doesn’t guess the number correctly after the maximum number of tries, the function returns False; otherwise, it should return True. You can set the default value of the max number to an arbitrary number.\n\n\n\n\n\nCurrently, there exists a delay for the input() function in vscode. Therefore, it is recommended to play the game using the script!\n\n\n%%writefile guess_number.py\n\nimport random\n\ndef guess_number(max_tries, max_number=_____):\n    \"\"\"\n    Function that allows the player to guess a number between 1 and max_number\n    If the player can guess the correct number within max_tries times, return True\n    Otherwise, return False\n    \"\"\"\n    # Generate a random number between 1 and max_number\n    number = _____ \n\n    # Allow the player to guess up to max_tries times\n    for i in range(max_tries):\n        # Prompt the player to guess the number\n        guess = int(input(\"Guess the number (between 1 and \"+ str(max_number) +\"): \"))\n\n        # Check if the guess is correct\n        if ______:\n            print(\"Congratulations, you guessed the number!\")\n            ______\n        elif ______:\n            print(\"The number is higher than your guess.\")\n        else:\n            print(\"The number is lower than your guess.\")\n\n    # If the player couldn't guess the number in max_tries tries, reveal the answer\n    print(\"Sorry, you didn't guess the number. The number was \" + str(number) + \".\")\n    _______\n\n# Call the function to start the game with a maximum of 5 tries\ngame_result = guess_number(5)\n\n# Print the result of the game\nif game_result:\n    print(\"You won!\")\nelse:\n    print(\"You lost!\")"
  },
  {
    "objectID": "03_Function.html#local-and-global-scope",
    "href": "03_Function.html#local-and-global-scope",
    "title": "3  Functions",
    "section": "3.4 Local and Global Scope",
    "text": "3.4 Local and Global Scope\nParameters and variables assigned in a called function are said to exist in that function’s local scope. Variables assigned outside all functions are said to exist in the global scope. A variable in a local scope is called a local variable, while a variable in the global scope is called a global variable. A variable must be one or the other; it cannot be both local and global.\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. There is only one global scope, and it is created when your program begins. A local scope is created whenever a function is called. Any variables assigned in the function exist within the function’s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The next time you call the function, the local variables will not remember the values stored in them from the last time it was called.\n\n3.4.1 Local Variables Cannot Be Used in the Global Scope\nConsider this program, which will cause an error when you run it:\n\ndef spam():\n    eggs = 31337\n\nspam()\nprint(eggs)\n\nNameError: name 'eggs' is not defined\n\n\nThe error happens because the eggs variable exists only in the local scope created when spam() is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs.\n\n\n3.4.2 Local Scopes Cannot Use Variables in Other Local Scopes\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\ndef spam():\n    eggs = 99\n    bacon()\n    print(eggs)\n\ndef bacon():\n    ham = 101\n    eggs = 0\n\nspam()\n\n99\n\n\nYou can view the execution of this program at https://autbor.com/otherlocalscopes/. When the program starts, the spam() function is called, and a local scope is created. The local variable eggs is set to 99. Then the bacon() function is called, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101, and a local variable eggs — which is different from the one in spam()’s local scope—is also created and set to 0. When bacon() returns, the local scope for that call is destroyed, including its eggs variable. The program execution continues in the spam() function to print the value of eggs. Since the local scope for the call to spam() still exists, the only eggs variable is the spam() function’s eggs variable, which was set to 99.\n\n\n3.4.3 Global Variables Can Be Read from a Local Scope\n\ndef spam():\n    print(eggs)\n    \neggs = 42\nspam()\nprint(eggs)\n\n42\n42\n\n\nYou can view the execution of this program at https://autbor.com/readglobal/. Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam(), Python considers it a reference to the global variable eggs. This is why 42 is printed when the previous program is run.\n\ndef spam():\n    eggs = 'spam local'\n    print(eggs)    # prints 'spam local'\n\ndef bacon():\n    eggs = 'bacon local'\n    print(eggs)    # prints 'bacon local'\n    spam()\n    print(eggs)    # prints 'bacon local'\n\neggs = 'global'\nbacon()\nprint(eggs)        # prints 'global'\n\nbacon local\nspam local\nbacon local\nglobal\n\n\n\nIf you want to modify the global variable, use the global keywords.\n\n\ndef spam():\n    global eggs    # If you want to modify the global eggs use global keyword\n    eggs = 'spam local' \n    print(eggs)    # prints 'spam local'\n\neggs = 'global'\nspam()\nprint(eggs)\n\nspam local\nspam local\n\n\nYou can visulaize the execution here."
  },
  {
    "objectID": "03_Function.html#storing-your-functions-in-modules",
    "href": "03_Function.html#storing-your-functions-in-modules",
    "title": "3  Functions",
    "section": "3.5 Storing Your Functions in Modules",
    "text": "3.5 Storing Your Functions in Modules\nOne advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, your programs become much easier to follow. You can go a step further by storing your functions in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file.\n\nStoring your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.\n\n\n3.5.1 Importing a module\nTo start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let’s make a module that contains the function make_pizza().\n\n%load_ext autoreload\n%autoreload 2\n\n\n%%writefile pizza.py\ndef make_pizza(size, *toppings):\n    \"\"\"Summarize the pizza we are about to make.\"\"\"\n    print(\"\\nMaking a \"+ str(size) + \"-inch pizza with the following toppings:\")\n    print(toppings)\n\nOverwriting pizza.py\n\n\n\nimport pizza\n\npizza.make_pizza(16, 'pepperoni')\npizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nWhen Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. To call a function from an imported module, enter the name of the module you imported, pizza, followed by the name of the function, make_pizza(), separated by a dot.\n\n\n3.5.2 Importing Specific Functions using from\nYou can also import a specific function from a module.\n\nfrom pizza import make_pizza\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nWith this syntax, you don’t need to use the dot notation when you call a function.\n\n\n3.5.3 Importing All Functions in a Module\nYou can tell Python to import every function in a module by using the asterisk (*) operator:\n\nfrom pizza import *\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\nThe asterisk in the import statement tells Python to copy every function from the module pizza into this program file. Because every function is imported, you can call each function by name without using the dot notation.\n\nHowever, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results!\n\n\n\n3.5.4 Using as to Give a Function an Alias\nIf the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique alias — an alternate name similar to a nickname for the function.\n\nfrom pizza import make_pizza as mp\n\nmp(16, 'pepperoni')\nmp(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\n\n\n3.5.5 Using as to Give a Module an Alias\nYou can also provide an alias for a module name. Giving a module a short alias, like p for pizza, allows you to call the module’s functions more quickly.\n\nimport pizza as p\n\np.make_pizza(16, 'pepperoni')\np.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n\nMaking a 16-inch pizza with the following toppings:\n('pepperoni',)\n\nMaking a 12-inch pizza with the following toppings:\n('mushrooms', 'green peppers', 'extra cheese')\n\n\n\n3.5.6 Exercise 2: In this word game, the player is in a land full of dragons. Some dragons are friendly and share their treasure. Other dragons are hungry and eat anyone who enters their cave. The player approaches two caves, one with a friendly dragon and the other with a hungry dragon, but doesn’t know which dragon is in which cave. The player must choose between the two. Please completet the design of game by calling the function from the provided game module.\n\n\n\n\n\n%%writefile word_game.py\nimport random\nimport time\n_____________\n\nplayAgain = 'yes'\n\nwhile playAgain == 'yes':\n    # Display the information of game using the displayIntro() in game module\n    ______________\n    # Read the user input and return the cave number by calling the function chooseCave() in game module\n    caveNumber = ________________\n    # Check whether the cave is safe or not by calling the checkCave() in game module with appropriate arguments\n    ______(_____)\n\n    print('Do you want to play again? (yes or no)')\n    playAgain = input()\n\nFunctions are the primary way to categorize your code into logical groups. Since the variables in functions exist in their local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when debugging your code.\nFunctions are a great tool to help you organize your code. You can think of them as black boxes: they have input in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions."
  },
  {
    "objectID": "04_Lists_tuples.html#list",
    "href": "04_Lists_tuples.html#list",
    "title": "4  Lists and Tuples",
    "section": "4.1 List",
    "text": "4.1 List\nOne more topic you’ll need to understand before you can begin writing programs in earnest is the list data type and its cousin, the tuple. Lists and tuples can contain multiple values, which makes writing programs that handle large amounts of data easier. These data types are called containers, meaning they are objects that “contain” other objects. They each have some important distinguishing properties and come with their own set of methods for interacting with objects of each type. List and tuple belong to sequence data types, which means they represent ordered collections of items. They share the same characteristic as string and the range object returned by range() function. Many of the capabilities shown in this chapter apply to all sequence types.\n\nCheckout https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range for more details.\n\nIn a string, the values are characters; in a list, they can be any type. The values in a list are called elements or sometimes items. Items are separated with commas.\n\n\n\n\nsource: https://favtutor.com/blogs/list-vs-dictionary\n\nThere are several ways to create a new list; the simplest is to enclose the elements in square brackets (“[” and ”]”). A list that contains no elements is called an empty list; you can create one with empty brackets.\n\ntype([])\n\nlist\n\n\n\ntype([10, 20, 30, 40]), type(['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra'])\n\n(list, list)\n\n\nThe first example is a list of four integers and the second is a list of four strings.\n\n4.1.1 Getting Individual Values in a List with Indexes\nYou can reference a list item by writing the list’s name followed by the element’s index (that is, its position number) enclosed in square brackets ([], known as the subscription operator or bracket operator). Remember that the indices start at 0:\n\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[0])\nprint(subjects[3])\n\ncalculus\nlinear algebra\n\n\nNote that the first index is 0, the last index is one less than the size of the list; a list of four items has 3 as its last index.\nPython will give you an IndexError error message if you use an index that exceeds the number of values in your list value.\n\nprint(subjects[4])\n\nIndexError: list index out of range\n\n\nThe elements of a list don’t have to be the same type. The following list contains a string, a float, an integer, and another list:\n\nspam = ['spam', 2.0, 5, [10, 20]]\n\nThe values in these lists of lists can be accessed using multiple indexes:\n\nspam[3][1]\n\n20\n\n\n\nspam = [1,3,5,7,9]\nspam[3:]\n\n[7, 9]\n\n\nThe first index dictates which items in the outer list to use, and the second indicates the value within the inner list. If you only use one index like spam[3], the program will print the entire list value at that index.\n\nspam[3]\n\n7\n\n\n\n4.1.1.1 Negative Indexes\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on.\n\nprint(subjects[-1]) # subjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[-2])\n\nlinear algebra\ncomputer programming\n\n\n\n\n4.1.1.2 Getting a List’s Length with the len() Function\nThe len() function will return the number of values that are in a list, just like it can count the number of characters in a string.\n\nlen(subjects)\n\n4\n\n\n\n\n4.1.1.3 Getting a sublist from Another List with Slices\nJust as an index can get a single value from a list, a slice can get several values from a list as a new list. A slice is typed between square brackets, like an index, but has two integers separated by a colon.\n\nsubjects[2] is a list with an index.\nsubjects[1:3] is a list with a slice.\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list.\n\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nprint(subjects[0:3])\nprint(subjects[1:-1])\n\n['calculus', 'introduction to mathematics', 'computer programming']\n['introduction to mathematics', 'computer programming']\n\n\nAs a shortcut, you can leave out one or both indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list.\n\nprint(subjects[:3]) # same as subjects[0:3] \nprint(subjects[1:]) # same as subjects[1:len(s)] \nprint(subjects[:]) # same as s[0:len(s)]\n\n['calculus', 'introduction to mathematics', 'computer programming']\n['introduction to mathematics', 'computer programming', 'linear algebra']\n['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n\n\nJust like range(), slicing has the optional third index that can be used to specify the step.\n\nprint(subjects[::2]) # Note the default step is 1\nprint(subjects[::-1]) # Reverse the order of the list\n\n['calculus', 'computer programming']\n['linear algebra', 'computer programming', 'introduction to mathematics', 'calculus']\n\n\n\n\n4.1.1.4 Changing Values in a List with Indexes\nUnlike strings, lists are mutable because you can reassign an item in a list. When the bracket operator appears on the left side of an assignment, it identifies the element of the list that will be assigned.\n\nnumbers = [17, 123, 42, 7]\nnumbers[1] = 5\nnumbers\n\n[17, 5, 42, 7]\n\n\nThe first element of numbers, which used to be 123, is now 5.\nAll in all, you can think of a list as a relationship between indices and elements. This relationship is called a mapping; each index “maps to” one of the elements.\n\n\n\n4.1.2 List Concatenation and List Replication\nLists can be concatenated and replicated just like strings. The + operator combines two lists to create a new list and the * operator can be used with a list and an integer value to replicate the list.\n\n[1, 2, 3] + ['A', 'B', 'C']\n\n[1, 2, 3, 'A', 'B', 'C']\n\n\n\n['X', 'Y', 'Z'] * 3\n\n['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']\n\n\n\n4.1.2.1 Removing Values from Lists with del Statements\nThe del statement will delete values at an index in a list. All values in the list after the deleted value will be moved up one index.\n\nt = ['a', 'b', 'c']\ndel t[1] # using index\nprint(t)\n\n['a', 'c']\n\n\n\n\n\n4.1.3 List traversal\nIn Chapter 2, you have learned about using for loops to execute a block of code a certain number of times. Technically, a for loop repeats the code block once for each item in a sequence.\n\nfor i in range(4):\n    print(i)\n\n0\n1\n2\n3\n\n\n\nprint(range(4))\nlist(range(4))\n\nrange(0, 4)\n\n\n[0, 1, 2, 3]\n\n\nThis is because the return value from range(4) is a sequence that Python considers similar to [0, 1, 2, 3]. The following program has the same output as the previous one:\n\nfor i in [0, 1, 2, 3]:\n    print(i)\n\n0\n1\n2\n3\n\n\n\nfor subject in subjects: # subjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n  print(subject)\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\nThis works well if you only need to read the elements of the list. But you need the indices that you want to write or update the elements. A common way to do that is to combine the functions range() and len():\nA common Python technique is to use range(len(someList)) with a for loop to iterate over the indexes of a list.\n\nfor i in range(len(numbers)): # numbers = [17, 5, 42, 7]\n  print(i, numbers[i])\n  numbers[i] = numbers[i]**2\n\nprint(numbers)\n\n0 17\n1 5\n2 42\n3 7\n[289, 25, 1764, 49]\n\n\nThis loop traverses the list and prints each element. len() returns the number of elements in the list. range() returns a list of indices from 0 to n − 1, where n is the length of the list. Each time through the loop, i gets the index of the next element. This is handy since it will iterate through all the indexes, no matter how many items it contains.\n\n4.1.3.1 The in and not in Operators\nYou can determine whether an object is or isn’t in a list with the in and not in operators. These expressions will evaluate to a Boolean value.\n\nprint('howdy' in ['hello', 'hi', 'howdy', 'heyas'])\nprint('English' not in subjects)\n\nTrue\nTrue\n\n\n\n\n4.1.3.2 Using the enumerate() Function with Lists\nInstead of using the range(len(someList)) technique with a for loop to obtain the integer index of the items in the list, you can call the enumerate() function instead. On each iteration of the loop, enumerate() will return two values: the index of the item and the item itself.\n\nnumbers = [17, 5, 42, 7]\n\nfor i, number in enumerate(numbers): \n  print(i, number)\n  numbers[i] = number**2\n\nprint(numbers)\n\n0 17\n1 5\n2 42\n3 7\n[289, 25, 1764, 49]\n\n\n\n\n4.1.3.3 Loop in Multiple Lists with zip()\nBuilt-in function zip() enables you to iterate over multiple sequences of data at the same time. The function receives as arguments any number of sequences and returns an iterator that produces tuples containing the elements at the same index in each.\n\nnames = ['Bob', 'Sue', 'Amanda']\ngrade_point_averages = [3.5, 4.0, 3.75] \n\nfor name, gpa in zip(names, grade_point_averages):\n    print('Name=', name, 'GPA=', gpa)\n\nName= Bob GPA= 3.5\nName= Sue GPA= 4.0\nName= Amanda GPA= 3.75\n\n\nThe above snippet call zip() to produces the tuples ('Bob', 3.5), ('Sue', 4.0) and ('Amanda', 3.75) consisting of the elements at index 0, 1 and 2 of each list, respectively. Note that we unpack (which we will elaborate later on) each tuple into name and gpa and display them.\n\nlist(zip(names, grade_point_averages))\n\n[('Bob', 3.5), ('Sue', 4.0), ('Amanda', 3.75)]\n\n\n\n\n\n4.1.4 Methods of the list\nA method, introduced in Chapter 1, is the same as a function, except it is “called on” an object. For example, if a list object were stored in spam, you would call the index() list method on that list like so: spam.index('hello'). The method part comes after the object, separated by a period.\nEach data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a list.\n\n4.1.4.1 Adding elements to Lists with the append() and insert() Methods\nappend() adds a new element to the end of a list:\n\nt = ['a', 'b', 'c']\nt.append('d')\nt # in-place operation!\n\n['a', 'b', 'c', 'd']\n\n\nThe previous append() method call adds the argument to the end of the list. The insert() method can insert an element at any index in the list. The first argument to insert() is the index for the new value, and the second argument is the new value to be inserted.\n\nt = ['a', 'b', 'c']\nt.insert(1,'e')\nt # in-place operation!\n\n['a', 'e', 'b', 'c']\n\n\n\nNotice that the code is t.append('d') and t.insert(1, 'e'), not t = t.append('d') and t = t.insert(1, 'e'). In fact, the return value of append() and insert() is None, so you definitely wouldn’t want to store this as the new variable value. Rather, the list is modified in-place.\n\nMethods belong to a single data type. The append() and insert()methods are list methods and can be called only on list object, not on other objects such as strings or integers.\n\neggs = 'hello'\neggs.append('world')\n\nAttributeError: 'str' object has no attribute 'append'\n\n\n\n\n4.1.4.2 Adding all the elements of a List to the end of List with the extend() Methods\nUse list method extend() to add all the elements of another sequence to the end of a list:\n\ncolor_names = ['orange', 'yellow', 'green']\ncolor_names.extend(['indigo', 'violet']) # equivalent to color_names += ['indigo', 'violet']\n\n\ncolor_names\n\n['orange', 'yellow', 'green', 'indigo', 'violet']\n\n\n\n\n4.1.4.3 Removing elements from Lists with the remove() Method\nThe remove() method will pass the object to be removed from the list when it is called:\n\nspam = ['cat', 'bat', 'rat', 'elephant']\nspam.remove('bat')\nprint(spam)\n\n['cat', 'rat', 'elephant']\n\n\n\nThe del statement is good to use when you know the index of the element you want to remove from the list. The remove() method is useful when you know the element you want to remove from the list.\n\n\n\n4.1.4.4 Sorting the elements in a List with the sort() Method\nLists of numbers or lists of strings can be sorted with the sort() method:\n\nspam = [2, 5, 3.14, 1, -7]\nspam.sort() # The default behavior is sorting in ascending order\nprint(spam)\n\nspam = ['ants', 'cats', 'dogs', 'badgers', 'Elephants']\nspam.sort()\nprint(spam)\n\n[-7, 1, 2, 3.14, 5]\n['Elephants', 'ants', 'badgers', 'cats', 'dogs']\n\n\nNote that sort() uses “ASCII order” rather than alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z.\nYou can also pass True for the reverse keyword argument to have sort() sort the values in reverse order.\n\nspam.sort(reverse=True) # Sort in descending order\nprint(spam)\n\n['dogs', 'cats', 'badgers', 'ants', 'Elephants']\n\n\n\n\n4.1.4.5 Searching an element in a List with the index() Method\nList objects have an index() method that accepts an argument, and if that argument exists in the list, the index of the argument is returned. If the argument isn’t in the list, then Python produces a ValueError error.\n\nspam = ['hello', 'hi', 'howdy', 'heyas']\nspam.index('hi')\n\n1\n\n\n\nspam = ['hello', 'hi', 'howdy', 'heyas']\nspam.index('world')\n\nValueError: 'world' is not in list\n\n\nWhen there are duplicates of the elements in the list, the index of its first appearance is returned.\n\nspam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka']\nspam.index('Pooka')\n\n1\n\n\n\n\n\n4.1.5 Numerical functions for list\nThere are a number of built-in functions that can be used on lists that allow you to quickly look through a list without writing your own loops:\n\nnums = [3, 41, 12, 9, 74, 15]\nprint(len(nums))\n\n6\n\n\n\nprint(max(nums))\nprint(min(nums))\nprint(sum(nums))\n\n74\n3\n154\n\n\nCheck out https://docs.python.org/3/tutorial/datastructures.html#more-on-lists for more methods!\n\n\n4.1.6 List Comprehensions\nConsider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10).\n\nsquares = []\nfor value in range(1,11):\n    squares.append(value**2)\nprint(squares)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nBut a list comprehension allows you to generate this same list in just one line of code. A list comprehension combines the for loop and the creation of new elements into one line, and automatically appends each new element!\n\nsquares = [value**2 for value in range(1, 11)]\nprint(squares)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nTo use this syntax\n\nBegin with a descriptive name for the list, such as squares.\nNext, open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression is value**2\nThen, write a for loop to generate the numbers you want to feed into the expression and close the square brackets. In this example, the for loop iterates value in range(1, 11), which feeds the values 1 through 10 into the expression value**2.\n\nNote that no colon is used at the end of the for statement.\n\nThe syntax of list comprehension is similar to the set-builder notation. For instance, preivous example is similar to \\(\\{x^2 | x \\in \\{1,2,...,10\\}\\}\\)\n\nAnother common operation is filtering elements to select only those that match a condition. This typically produces a list with fewer elements than the data being filtered. To do this in a list comprehension, use the if clause. The following includes in list1 only the even values produced by the for clause:\n\nlist1 = [item for item in range(1, 11) if item % 2 == 0]\nlist1\n\n[2, 4, 6, 8, 10]\n\n\n\n4.1.7 Exercise 1: Bulls and Cows (or 1A2B) is a code-breaking game. The numerical version of the game is usually played with four digits. On a sheet of paper, the players each write a 4-digit secret number. The digits must all be different. Then, in turn, the players try to guess their opponent’s number, which gives the number of matches. If the matching digits are in their right positions, they are “bulls” (A). If they are in different positions, they are “cows” (B). For example, if the secret number is 4271 and our guess is 1234, then we should get 1 bull and 2 cows. (The bull is “2”, the cows are “4” and “1”.). Please complete the following game design, that the computer will generate a 4-digit number, and we must write a function to read the user’s 4-digit inputs and check the user’s guess against the secret number. Finally, return the message XAXB to the user.\n\n\n\n\n\nsource: https://en.wikipedia.org/wiki/Bulls_and_Cows\n\n\n%%writefile 1A2B.py\n\nimport random\n\n# Generate a random four-digit number\ndef generate_number():\n    digits = list(range(10))\n    random.shuffle(digits) # randomly shuffle the list!\n    return digits[:4]\n\n# Check the user's guess against the secret number\ndef check_guess(guess, secret):\n    # Note that both guess and secret are lists!\n    a = 0 # number of correct digits in the correct position\n    b = 0 # number of correct digits in the wrong position\n    for i,j in zip(__,__): # Iterate over two lists\n        if i == j:\n            a += 1\n        elif __________: # Use operator to determine whether the digit is in secret number or not\n            b += 1\n    return a, b\n\n# Play the game\nprint(\"Welcome to 1A2B!\")\nprint(\"I'm thinking of a four-digit number. Can you guess it?\")\nsecret = generate_number()\nguesses = 0\nwhile True:\n    guess = input(\"Enter your guess, enter 'quit' to give up: \")\n    if guess == 'quit':\n        print(\"The secret number is\", secret)\n        break\n    elif len(guess) != 4 or not guess.isdigit():\n        print(\"Invalid guess. Please enter a four-digit number.\")\n        continue\n    guess = _______ # Use list comprehension to get the 4-digit guess list\n    guesses += 1\n    result = check_guess(guess, secret)\n    print(result[0],'A', result[1], 'B', sep=\"\")\n    if result[0] == 4:\n        print(\"Congratulations, you guessed the number in\", guesses, \"guesses!\")\n        break\n\nOverwriting 1A2B.py\n\n\n\n\n4.1.8 Sequence Data Types\nLists aren’t the only data types that represent ordered sequences of values. For example, strings and lists are similar if you consider a string to be a “list” of single text characters. The Python sequence data types include lists, strings, range objects returned by range(), and tuples. Many of the things you can do with lists can also be done with strings and other values of sequence types: indexing; slicing; and using them with for loops, with len(), and with the in and not in operators.\n\n'a' in 'apple'\n\nTrue\n\n\n\n\n4.1.9 Mutable and Immutable Data Types\nBut lists and strings are different in an important way. A list object is a mutable data type: it can have elements added, removed, or changed. However, a string is immutable: it cannot be changed. Trying to reassign a single character in a string results in a TypeError error:\n\nname = 'Zophie a cat'\nname[7] = 't'\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "04_Lists_tuples.html#tuples",
    "href": "04_Lists_tuples.html#tuples",
    "title": "4  Lists and Tuples",
    "section": "4.2 Tuples",
    "text": "4.2 Tuples\nA tuple is a sequence of values much like a list. The values stored in a tuple can be any type, and they are indexed by integers. The important difference is that tuples are immutable.\n\nIt is similar to the tuple you encounter in math\n\nAlthough it is not necessary, it is common to enclose tuples in parentheses to help us quickly identify tuples when we look at Python code:\n\ntype(())\n\ntuple\n\n\n\nt = ('a', 'b', 'c', 'd', 'e')\ntype(t)\n\ntuple\n\n\nTo create a tuple with a single element, you have to include the final comma or use the tuple() function:\n\nt1 = ('a',)\nprint(type(t1))\nt2 = ('a')\nprint(type(t2))\n\n&lt;class 'tuple'&gt;\n&lt;class 'str'&gt;\n\n\nIf the argument of tuple() is a sequence (string, list, or tuple), the result is a tuple with the elements of the sequence:\n\nt = tuple('nsysu')\nt\n\n('n', 's', 'y', 's', 'u')\n\n\nMost list operators also work on tuples. The bracket operator indexes an element:\n\nprint(t[0])\nprint(t[1:3])\n\nn\n('s', 'y')\n\n\nBut if you try to modify one of the elements of the tuple, you get an error:\n\nt[0] = 'A'\n\nTypeError: 'tuple' object does not support item assignment\n\n\nYou can use tuples to convey to anyone reading your code that you don’t intend for that sequence of values to change. Use a tuple if you need an ordered sequence of values that never changes.\n\n4.2.1 Unpacking Sequences\nWe have seen the multiple assignment trick in the previous chapter (which is actually unpacking the tuple). In fact, you can unpack any sequence’s elements by assigning the sequence to a comma-separated list of variables.\n\nstudent_tuple = ('Amanda', [98, 85, 87])\n\n\nfirst_name, grades = student_tuple\nprint(first_name, grades)\n\nAmanda [98, 85, 87]\n\n\nUnpacking is widely used to return multiple values in a function:\n\ndef total_ave(grade):\n    total = sum(grade)\n    ave = total/len(grade)\n    return total, ave\n\ngrades = [85, 70, 100, 90]\ntotal, ave = total_ave(grades)\n\nprint(total, ave)\n\n345 86.25"
  },
  {
    "objectID": "04_Lists_tuples.html#references",
    "href": "04_Lists_tuples.html#references",
    "title": "4  Lists and Tuples",
    "section": "4.3 References",
    "text": "4.3 References\nTechnically, in Python, variables store references to the computer memory locations where the values are stored.\n\nspam = 42\ncheese = spam\nprint(id(cheese), id(spam))\nspam = 100\nprint(id(cheese), id(spam))\n\nspam, cheese\n\n140731993439296 140731993439296\n140731993439296 140731993441152\n\n\n(100, 42)\n\n\nWhen you assign 42 to the spam variable, you are actually creating the 42 value in the computer’s memory and storing a reference (address) to it in the spam variable. When you copy the value in spam and assign it to the variable cheese, you are actually copying the reference. Both the spam and cheese variables refer to the 42 value in the computer’s memory. When you later change the value in spam to 100, you’re creating a new 100 value and storing a reference to it in spam. This doesn’t affect the value in cheese. Integers are immutable values that don’t change; changing the spam variable is actually making it refer to a completely different value in memory.\nYou can use id() function to verify this behavior. In CPython (the most widely used implementation of Python), the identifier returned by id() is actually the memory address of the object, represented as a Python integer. All values in Python have a unique identity (address) that can be obtained with the id() function.\nBut lists don’t work this way, because list are mutable:\n\nspam = [0, 1, 2, 3, 4, 5]\ncheese = spam        # The reference is being copied, not the list.\nprint(id(cheese), id(spam))\ncheese[1] = 'Hello!' # This changes the list value.\nprint(id(cheese), id(spam))\n\nspam, cheese\n\n2790646437440 2790646437440\n2790646437440 2790646437440\n\n\n([0, 'Hello!', 2, 3, 4, 5], [0, 'Hello!', 2, 3, 4, 5])\n\n\nUsing boxes as a metaphor for variables, the following shows what happens when a list is assigned to the spam variable.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nThen, the reference in spam is copied to cheese. Only a new reference was created and stored in cheese, not a new list. Note how both references refer to the same list.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nWhen you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\nYou may be wondering why the weird behavior with mutable lists in the previous section doesn’t happen with immutable values like integers or strings. Let us elaborate on this topics.\nLike integer, 'Hello' is a string which is immutable and cannot be changed. If you “change” the string in a variable, a new string object is being made at a different place in memory, and the variable refers to this new string.\n\nbacon = 'Hello'\nprint(id(bacon))\nbacon = bacon + 'World'\nprint(id(bacon))\n\n2790646417200\n2790646416176\n\n\nHowever, lists can be modified because they are mutable objects. The append() method doesn’t create a new list object; it changes the existing list object. We call this “modifying the object in-place.”\n\neggs = ['Hello'] # This creates a new list.\nprint(id(eggs))\neggs.append('World')  # append() modifies the list \"in place\".\nprint(id(eggs))       # eggs still refers to the same list as before.\n\n2790646499648\n2790646499648\n\n\nIf two variables refer to the same list (like spam and cheese in the previous section) and the list itself changes, both variables are affected because they both refer to the same list. The append(), remove(), sort(), reverse(), and other list methods modify their lists in place.\n\nPython’s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don’t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\n\n4.3.1 Passing References\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries, which we will describe in the next chapter), this means a copy of the reference is used for the parameter.\n\ndef eggs(someParameter):\n    someParameter.append('Hello')\n\nspam = [1, 2, 3]\neggs(spam)\nprint(spam)\n\n[1, 2, 3, 'Hello']\n\n\nNotice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place directly. Even though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.\nFor immutable types string and integers, we will create a new object in the function when we modify someParameter. Therefore, the original value will not be modified after the loop.\n\ndef eggs(someParameter):\n    print(id(someParameter))\n    someParameter = someParameter + \"world\" # This will create a new object and assign the new reference to someParameter\n    print(id(someParameter))\n\nspam = \"hello\"\nprint(id(spam))\neggs(spam)\nprint(spam)\n\n2790636340272\n2790636340272\n2790646431216\nhello\n\n\n\n\n4.3.2 The copy Module’s copy() and deepcopy() Functions\nPython provides a module named copy that provides both the copy() and deepcopy() functions. copy(), can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference.\n\nimport copy\n\nspam = ['A', 'B', 'C', 'D']\nprint(id(spam))\ncheese = copy.copy(spam)\nprint(id(cheese)) # cheese is a different list with different identity.\ncheese[1] = 42\n\nspam, cheese\n\n2790645442048\n2790645869632\n\n\n(['A', 'B', 'C', 'D'], ['A', 42, 'C', 'D'])\n\n\nNow the spam and cheese variables refer to separate lists, which is why only the list in cheese is modified when you assign 42 at index 1.\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter4/\n\n\nIf the list you need to copy contains another list, then use the copy.deepcopy() function instead of copy.copy(). The deepcopy() function will copy these inner lists as well.\n\n\n4.3.3 Exercise 2: Here, we will simulate the process of a simple card game. The game is played with a standard deck of 52 cards, and we will randomly select 40 cards and divide them evenly between two players. Each player gets a hand of 20 cards. The goal of the game is to collect pairs of cards with the same rank (e.g., two aces, two kings, etc.). The player with the most pairs at the end of the game wins.\n\n\n\n\n\nimport random\n\n# Write a function create_deck that creates a list of tuples representing a standard deck of 52 cards. \n# Each tuple should contain two elements: the rank (e.g., \"ace\", \"king\", etc.) \n# and the suit (e.g., \"hearts\", \"spades\", etc.). \ndef create_deck():\n    ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n    suits = ['♣', '♦', '♥', '♠']\n    deck = [(rank, suit) ______] # Use list comprehension to create the deck.\n    return deck\n\n# A function that takes the deck as a parameter and returns two lists, each containing 26 randomly-selected \n# cards from the deck. Use list slicing and the random module to implement this function.\ndef deal_cards(deck):\n    deck = deck[:40]\n    random.shuffle(deck)\n    hand1 = _____  # Split it into 20 cards in each using slice\n    hand2 = _____\n    return hand1, hand2\n\n# Write a function find_pairs that takes a list of cards as a parameter and returns a list of tuples \n# representing the pairs of cards in the list. A pair is defined as two cards with the same rank. \ndef find_pairs(cards):\n    pairs = []\n    for i, card1 in enumerate(cards):\n        for j, card2 in enumerate(cards):\n            if i != j and card1[0] == card2[0] and card1 not in [pair[0] for pair in pairs]\\\n                and card1 not in [pair[1] for pair in pairs] and card2 not in [pair[0] for pair in pairs]\\\n                and card2 not in [pair[1] for pair in pairs]:\n                pairs._____((card1, card2)) # Use a method from the list to add it into the pairs\n    return pairs\n\ndeck = create_deck()\nhand1, hand2 = deal_cards(deck)\npairs1 = find_pairs(hand1)\npairs2 = find_pairs(hand2)\n\nprint(pairs1)\nprint(pairs2)\nif ___________: # Compare the length of the two lists\n    print(\"Player 1 wins!\")\nelif _____________:\n    print(\"Player 2 wins!\")\nelse:\n    print(\"It's a tie!\")\n\nLists are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later on, you will see programs using lists to do things that would be difficult or impossible to do without them.\nLists are a sequence data type that is mutable, meaning that their contents can change. Tuples and strings, though also sequence data types, are immutable and cannot be changed. A variable that contains a tuple or string value can be overwritten with a new tuple or string value, but this is not the same thing as modifying the existing value in place — like, say, the append() or remove() methods do on lists. Because tuples are immutable, they don’t provide methods like sort() and reverse(), which modify existing lists. However Python provides the built-in functions sorted() and reversed(), which take any sequence as a parameter and return a new sequence with the same elements in a different order.\nVariables do not store list objects directly; they store references to lists. This is an important distinction when you are copying variables or passing lists as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the list might impact another variable in your program. You can use copy() or deepcopy() if you want to make changes to a list in one variable without modifying the original list. It is noted that slicing also create a new list object."
  },
  {
    "objectID": "05_Dictionaries_sets.html#dictionaries",
    "href": "05_Dictionaries_sets.html#dictionaries",
    "title": "5  Other collections - Dictionaries and Sets",
    "section": "5.1 Dictionaries",
    "text": "5.1 Dictionaries\nWe’ve discussed three built-in sequence collections — strings, lists and tuples. Now, we consider the built-in non-sequence collections — dictionaries and sets. A dictionary is an unordered collection which stores key–value pairs that map immutable keys to values, just as a conventional dictionary maps words to definitions. A set is an unordered collection of unique immutable elements.\nLike a list, a dictionary is a mutable collection of many values, but more general. In a list, the index positions have to be integers; in a dictionary, the indices can be any immutable data type. You can think of a dictionary as a mapping between a set of indices (which are called keys) and a set of values. Each key maps to a value. The association of a key and a value is called a key-value pair or sometimes an item.\nA dictionary’s keys must be immutable (such as strings, integers or tuples) and unique (that is, no duplicates). However, multiple keys can have the same value.\n\n\n\n\nsource: https://pynative.com/python-dictionaries/\n\n\nIt is noted that as of Python 3.7, dictionary items maintain the order in which they are inserted into the dictionary. However, dictionaries are considered unordered collections and do not write code that depends on the order of the key–value pairs.\n\nAs an example, we’ll build a dictionary that maps from subjects to grades, so the keys are string while the values are integers. The function dict creates a new dictionary with no items.\n\ntype({}) # {} also treated as dict in Python\n\ndict\n\n\n\ngrade = dict()\ntype(grade), grade\n\n(dict, {})\n\n\nTo add/update items to the dictionary, you can again use subscript operator (square brackets):\n\ngrade['calculus'] = 85 # Key:'calculus', value: 85\nprint(grade) # Note that key and value are separate by colon\n\n{'calculus': 85}\n\n\nYou can create a dictionary that contains multiple items by enclosing in curly braces, {}, a comma-separated list of key–value pairs, each of the form key:value.\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'computer programming':90, 'linear algebra':95}\ngrade\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95}\n\n\nYou can store them using separate lists for subjects and scores, but the following update and maintenance will become tedious:\nsubjects = ['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\nscore = [85, 80, 90, 95]\nYou can now use the keys to look up the corresponding values:\n\nprint(grade['computer programming'])\n\n90\n\n\nYou can obtain the number of items using len()\n\nlen(grade)\n\n4\n\n\n\nNote that you can’t access items in them using integer indexes like grade[0] because it is unordered collections. (Consider the case when you use 4, 2, 1, 0 as the keys). Therefore, you can’t use slice syntax for dictionaries.\n\nTrying to access a key that does not exist in a dictionary will result in a KeyError error message, much like a list’s “out-of-range” IndexError error message.\n\ngrade['English']\n\nKeyError: 'English'\n\n\nTo add or delete an entry, it is similar to list\n\ngrade['English'] = 100\ngrade\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95,\n 'English': 100}\n\n\nYou can delete a key–value pair from a dictionary with the del statement:\n\ndel grade['English']\ngrade\n\n{'calculus': 85,\n 'introduction to mathematics': 80,\n 'computer programming': 90,\n 'linear algebra': 95}\n\n\n\n5.1.1 The keys(), values(), and items() Methods\nThere are three dictionary methods that will return list-like values of the dictionary’s keys, values, or both keys and values: keys(), values(), and items(). The values returned by these methods are not true lists, but these data types (dict_keys, dict_values, and dict_items, respectively) can be used in for loops (Just like range object)!\nIf you want a true list from one of these methods, pass its list-like return value to the list() function\n\nsubject = list(grade.keys())\nscore = list(grade.values())\nprint(subject)\nprint(score)\n\n['calculus', 'introduction to mathematics', 'computer programming', 'linear algebra']\n[85, 80, 90, 95]\n\n\n\nfor v in grade.values():\n    print(v)\n\n85\n80\n90\n95\n\n\nHere, a for loop iterates over each of the values in the grade dictionary. A for loop can also iterate over the keys:\n\nfor k in grade.keys():\n    print(k)\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\n\nfor k in grade:\n    print(k)\n\ncalculus\nintroduction to mathematics\ncomputer programming\nlinear algebra\n\n\n\nNote that by default, it will traverse over the keys!\n\nDictionaries have a method called items() that returns a list of tuples, where each tuple is a key-value pair:\n\nlist(grade.items())\n\n[('calculus', 85),\n ('introduction to mathematics', 80),\n ('computer programming', 90),\n ('linear algebra', 95)]\n\n\nCombining items(), multiple assignment, and for, you can see a nice code pattern for traversing the keys and values of a dictionary in a single loop:\n\nfor key, val in grade.items():\n    print(key,val)\n\ncalculus 85\nintroduction to mathematics 80\ncomputer programming 90\nlinear algebra 95\n\n\n\n5.1.1.1 Checking Whether a Key or Value Exists in a Dictionary\nRecall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary\n\n'calculus' in grade, 'English' in grade.keys(), 85 in grade.values() \n\n(True, False, True)\n\n\n\nAgain, it will check keys by default. Therefore, in the previous example, 'calculus' in grade is essentially a shorter version of writing 'calculus' in grade.keys(). This is always the case: if you ever want to check whether a value is (or isn’t) a key in the dictionary, you can simply use the in (or not in) keyword with the dictionary itself.\n\n\n\n5.1.1.2 Retrieve value uisng get() Method\n\nif 'English' in grade:\n    e_score= grade['English']\n\nIt’s tedious to check whether a key exists in a dictionary before accessing that key’s value. Fortunately, dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\npicnicItems = {'apples': 5, 'cups': 2}\nprint('I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.') \nprint('I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.')\n\nI am bringing 2 cups.\nI am bringing 0 eggs.\n\n\nBecause there is no ‘eggs’ key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get(), the code would have caused a KeyError message\n\npicnicItems = {'apples': 5, 'cups': 2}\n'I am bringing ' + str(picnicItems['eggs']) + ' eggs.'\n\nKeyError: 'eggs'\n\n\n\n\n5.1.1.3 Update value using setdefault() Method\nYou’ll often have to set a value in a dictionary for a certain key only if that key does not already have a value. The code looks something like this:\n\nspam = {'name': 'Pooka', 'age': 5}\nif 'color' not in spam:\n    spam['color'] = 'black'\n\nThe setdefault() method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist.\nThe setdefault() method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a string.\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    if character not in count:\n        count[character] = 0\n    count[character] = count[character] + 1\n\nprint(count)    \n\n{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}\n\n\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    count.setdefault(character, 0)\n    count[character] = count[character] + 1\n\nprint(count)    \n\n{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}\n\n\nYou can view the execution of this program at https://autbor.com/setdefault. The program loops over each character in the message variable’s string, counting how often each character appears. The setdefault() method ensures that the key is in the count dictionary (with a default value of 0) so the program doesn’t throw a KeyError error when count[character] = count[character] + 1 is executed!\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time.\n\n\n\n5.1.2 Pretty Printing\nIf you import the pprint module into your programs, you’ll have access to the pprint() function that will “pretty print” a dictionary’s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides.\n\nimport pprint\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.'\ncount = {}\n\nfor character in message:\n    count.setdefault(character, 0)\n    count[character] = count[character] + 1\n\npprint.pprint(count)\n\n{' ': 13,\n ',': 1,\n '.': 1,\n 'A': 1,\n 'I': 1,\n 'a': 4,\n 'b': 1,\n 'c': 3,\n 'd': 3,\n 'e': 5,\n 'g': 2,\n 'h': 3,\n 'i': 6,\n 'k': 2,\n 'l': 3,\n 'n': 4,\n 'o': 2,\n 'p': 1,\n 'r': 5,\n 's': 3,\n 't': 6,\n 'w': 2,\n 'y': 1}\n\n\nYou can view the execution of this program at https://autbor.com/pprint/. This time, when the program is run, the output looks much cleaner, with the keys sorted. The pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries.\n\n5.1.2.1 Dictionary Comprehensions\nDictionary comprehensions provide a convenient notation for quickly generating dictionaries, often by mapping one dictionary to another. For example, in a dictionary with unique values, you can reverse the key–value pairs:\n\nmonths = {'January': 1, 'February': 2, 'March': 3}\n\n\nmonths2 = {number:name for name, number in months.items()}\nmonths2\n\n{1: 'January', 2: 'February', 3: 'March'}\n\n\nCurly braces delimit a dictionary comprehension, and the expression to the left of the for specifies a key–value pair of the form key:value. The comprehension iterates through months.items(), unpacking each key–value pair tuple into the variables name and number. The expression number:name reverses the key and value, so the new dictionary maps the month numbers to the month names.\nA dictionary comprehension also can map a dictionary’s values to new values. The following comprehension converts a dictionary of names and lists of grades into a dictionary of names and grade-point averages. The variables k and v commonly mean key and value:\n\ngrades = {'Sue': [98, 87, 94], 'Bob': [84, 95, 91]}\n\n{'Bob': [84, 95, 91], 'Sue': [98, 87, 94]}\n\n\n\ngrades2 = {k:sum(v)/len(v) for k, v in grades.items()}\ngrades2\n\n{'Sue': 93.0, 'Bob': 90.0}\n\n\n\nNote the above is nested structure, with a list in a dictionary!\n\n\n\n\n5.1.3 Using Data Structures to Model Real-World Things\nA tic-tac-toe board looks like a large hash symbol (#) with nine slots that can each contain an X, an O, or a blank. To represent the board with a dictionary, you can assign each slot a key, as shown in below:\n\n\n\n\n1\n2\n3\n\n\n\n\n4\n5\n6\n\n\n7\n8\n9\n\n\n\n\nYou can use string values to represent what’s in each slot on the board: ‘X’, ‘O’, or ’ ’ (a space). Thus, you’ll need to store nine strings. You can use a dictionary of values for this. The string value with the key ‘3’ can represent the top-right corner, the string value with the key ‘7’ can represent the bottom-left corner, the string value with the key ‘5’ can represent the middle, and so on. This dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named board.\n\nboard = {'1': ' ', '2': ' ', '3': ' ',\n         '4': ' ', '5': ' ', '6': ' ',\n         '7': ' ', '8': ' ', '9': ' '}\n\nA board where player O has won by placing Os across the top might look like this:\n\nboard = {'1': 'O', '2': 'O', '3': 'O',\n         '4': 'X', '5': 'X', '6': ' ',\n         '7': ' ', '8': ' ', '9': 'X'}\nprint(board)\n\n{'1': 'O', '2': 'O', '3': 'O', '4': 'X', '5': 'X', '6': ' ', '7': ' ', '8': ' ', '9': 'X'}\n\n\n\n\n\n\nsource: https://automatetheboringstuff.com/2e/chapter5/\n\nOf course, the player should see only what is printed to the screen, not the contents of variables. Let’s create a function to print the board dictionary onto the screen:\n\ndef printBoard(board):\n    \"\"\"\n    The function that prints out the board in a square shape\n    \"\"\"\n    print(board['1'] + '|' + board['2'] + '|' + board['3'])\n    print('-+-+-')\n    print(board['4'] + '|' + board['5'] + '|' + board['6'])\n    print('-+-+-')\n    print(board['7'] + '|' + board['8'] + '|' + board['9'])\n\nprintBoard(board)\n\nO|O|O\n-+-+-\nX|X| \n-+-+-\n | |X\n\n\nThe printBoard() function can handle any tic-tac-toe data structure you pass it!\nNow let’s add code that allows the players to enter their moves.\n\nboard = {'1': ' ', '2': ' ', '3': ' ',\n         '4': ' ', '5': ' ', '6': ' ',\n         '7': ' ', '8': ' ', '9': ' '}\n\nboard['1'] = 'O'  # Update the board\nprintBoard(board)\nboard['5'] = 'X' \nprintBoard(board)\n\nO| | \n-+-+-\n | | \n-+-+-\n | | \nO| | \n-+-+-\n |X| \n-+-+-\n | | \n\n\nWe can also check whether player has won the game or not using the following code:\n\np = 'O' # Check whether 'O' has won the game or not\n\n((board['1'] == board['2'] == board['3'] == p) or  # Across top\n(board['4'] == board['5'] == board['6'] == p) or  # Across middle\n(board['7'] == board['8'] == board['9'] == p) or  # Across boardottom\n(board['1'] == board['4'] == board['7'] == p) or  # Down left\n(board['2'] == board['5'] == board['8'] == p) or  # Down middle\n(board['3'] == board['6'] == board['9'] == p) or  # Down right\n(board['3'] == board['5'] == board['7'] == p) or  # Diagonal\n(board['1'] == board['5'] == board['9'] == p))  # Diagonal\n\nFalse\n\n\n\nNote that by enclosing the condiations with (), we do not have to add \\ for multipline commands.\n\n\n5.1.4 Exercise 1: Tic-tac-toe is a classic pencil-and-paper game played on a 3 × 3 grid. Players take turns placing their ‘X’ or ‘O’ marks, trying to get three in a row. Try to complete the following game design by complete three functions getBlankBoard(), isValidSpace() and isBoardFull().\n\n\n%%writefile ttt.py\n\ndef printBoard(board):\n    \"\"\"\n    The function that prints out the board in a square shape\n    \"\"\"\n    print(board['1'] + '|' + board['2'] + '|' + board['3'])\n    print('-+-+-')\n    print(board['4'] + '|' + board['5'] + '|' + board['6'])\n    print('-+-+-')\n    print(board['7'] + '|' + board['8'] + '|' + board['9'])\n\n\ndef updateBoard(board, space, mark):\n    \"\"\"Sets the space on the board to mark.\"\"\"\n    board[space] = mark\n\ndef isWinner(board, player):\n    \"\"\"Return True if player is a winner on this TTTBoard.\"\"\"\n    # Shorter variable names used here for readablility:\n    b, p = board, player\n    # Check for 3 marks across 3 rows, 3 columns, and 2 diagonals.\n    return ((b['1'] == b['2'] == b['3'] == p) or  # Across top\n            (b['4'] == b['5'] == b['6'] == p) or  # Across middle\n            (b['7'] == b['8'] == b['9'] == p) or  # Across bottom\n            (b['1'] == b['4'] == b['7'] == p) or  # Down left\n            (b['2'] == b['5'] == b['8'] == p) or  # Down middle\n            (b['3'] == b['6'] == b['9'] == p) or  # Down right\n            (b['3'] == b['5'] == b['7'] == p) or  # Diagonal\n            (b['1'] == b['5'] == b['9'] == p))    # Diagonal\n\ndef getBlankBoard():\n    \"\"\"Create a new, blank tic-tac-toe board.\"\"\"\n    # Map of space numbers: 1|2|3\n    #                       -+-+-\n    #                       4|5|6\n    #                       -+-+-\n    #                       7|8|9\n    # Keys are '1' through '9', the values are 'X', 'O', or ' ':\n    # Initialize all spaces of the board as blank string ' ' using loop or dictionary complehention\n    ALL_SPACES = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    ______________________________\n    return board\n\ndef isValidSpace(board, space):\n    \"\"\"Returns True if the space on the board is a valid space number (1-9)\n    and the space is blank.\"\"\"\n    ALL_SPACES = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n    return ____________ and ________________\n\ndef isBoardFull(board):\n    \"\"\"Return True if every space on the board has been taken.\"\"\"\n    for v in ________:  # Traverse over the board to see if there is blank space\n        if v == ' ':\n            return False  # If any space is blank, return False.\n    return True  # No spaces are blank, so return True\n\n\n\n# The logic of the game\nprint('Welcome to Tic-Tac-Toe!')\ngameBoard = getBlankBoard()  # Create a TTT board dictionary.\ncurrentPlayer, nextPlayer = 'X', 'O'  # X goes first, O goes next.\n\nwhile True:  # Main game loop.\n    # 1. Display the board on the screen:\n    printBoard(gameBoard)\n\n    # 2. Keep asking the player until they enter a number 1-9:\n    move = None\n    while not isValidSpace(gameBoard, move):\n        print('What is ' + currentPlayer + '\\'s move? (1-9)')\n        move = input('&gt; ')\n    updateBoard(gameBoard, move, currentPlayer)  # Make the move.\n\n    # 3. Check if the game is over:\n    if isWinner(gameBoard, currentPlayer):  # Check for a winner.\n        printBoard(gameBoard)\n        print(currentPlayer + ' has won the game!')\n        break\n    elif isBoardFull(gameBoard):  # Check for a tie.\n        print(printBoard(gameBoard))\n        print('The game is a tie!')\n        break\n    # 4. Switch turns to the next player using multiple assignment:\n    currentPlayer, nextPlayer = nextPlayer, currentPlayer\nprint('Thanks for playing!')\n\nOverwriting ttt.py\n\n\n\n\n5.1.5 Nested Dictionaries and Lists\n\n5.1.5.1 A List of Dictionaries\nConsider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien:\n\nalien_0 = {'color': 'green', 'points': 5}\n\nThe alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a screen full of aliens. How can you manage a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien.\n\naliens = []\n# Make 30 green aliens.\nfor alien_number in range(30):\n    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}\n    aliens.append(new_alien)\n# Show the first 5 aliens.\nfor alien in aliens[:5]:\n    print(alien)\nprint(\"...\")\n# Show how many aliens have been created.\nprint(f\"Total number of aliens: {len(aliens)}\")\n\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n...\nTotal number of aliens: 30\n\n\nThese aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progresses. When it’s time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this:\n\nfor alien in aliens[:3]:\n    if alien['color'] == 'green':\n        alien['color'] = 'yellow'\n        alien['speed'] = 'medium'\n        alien['points'] = 10\n\naliens[:10]\n\n[{'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'yellow', 'points': 10, 'speed': 'medium'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'},\n {'color': 'green', 'points': 5, 'speed': 'slow'}]"
  },
  {
    "objectID": "05_Dictionaries_sets.html#sets",
    "href": "05_Dictionaries_sets.html#sets",
    "title": "5  Other collections - Dictionaries and Sets",
    "section": "5.2 Sets",
    "text": "5.2 Sets\nA set is an unordered collection of unique values. Sets may contain only immutable objects, like strings, ints, floats and tuples that contain only immutable elements.\nThe following code creates a set of strings named colors:\n\ncolors = {'red', 'orange', 'yellow', 'green', 'red', 'blue'} # Similar to set in math\ncolors\n\n{'blue', 'green', 'orange', 'red', 'yellow'}\n\n\nNotice that the duplicate string 'red' was ignored (without causing an error). An important use of sets is duplicate elimination, which is automatic when creating a set. Also, the resulting set’s values may not be displayed in the same order as they were listed! Though the color names are displayed in sorted order, sets are unordered. You should not write code that depends on the order of their elements!\n\nNote that we also use curly bracket to create a set!\n\nThough sets are iterable, they are not sequences and do not support indexing and slicing with square brackets, [].\n\ncolors[0]\n\nTypeError: 'set' object is not subscriptable\n\n\nYou can determine the number of items in a set with the built-in len() function:\n\nlen(colors)\n\n5\n\n\nYou can check whether a set contains a particular value using the in and not in operators:\n\n'red' in colors, 'purple' not in colors\n\n(True, True)\n\n\nSets are iterable, so you can process each set element with a for loop:\n\nfor color in colors: # {'blue', 'green', 'orange', 'red', 'yellow'}\n    print(color, end=' ')\n\ngreen blue red yellow orange \n\n\nSets are unordered, so there’s no significance to the iteration order!\n\n5.2.1 Creating a Set with the Built-In set() Function\nYou can create a set from another collection of values by using the built-in set() function — here we create a list that contains several duplicate integer values and use that list as set’s argument:\n\nnumbers = list(range(10)) + list(range(5))\nnumbers\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4]\n\n\n\nset(numbers)\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nIf you need to create an empty set, you must use the set() function with empty parentheses, rather than empty braces, {}, which represent an empty dictionary:\n\nset()\n\nset()\n\n\n\nPython displays an empty set as set() to avoid confusion with Python’s string representation of an empty dictionary ({}).\n\n\n\n5.2.2 Set Operators and Methods\nSets are mutable — you can add and remove elements, but set elements must be immutable. Therefore, a set cannot have other sets as elements.\n\n{6,5,'a'}\n\n{5, 6, 'a'}\n\n\n\n{7,3,{3,5,7}}\n\nTypeError: unhashable type: 'set'\n\n\n\n{7,3,[3,5,7]}\n\nTypeError: unhashable type: 'list'\n\n\n\n5.2.2.1 Methods for Adding and Removing Elements\nHere we first discuss operators and methods that modify an existing set.\nSet method update() performs a union operation modifying the set in-place — the argument can be any iterable:\n\nnumbers = {1, 3, 5}     \nnumbers.update(range(10)) \nnumbers\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\nSet method add() inserts its argument if the argument is not already in the set; otherwise, the set remains unchanged:\n\nnumbers.add(17)\nnumbers.add(3)\nnumbers\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 17}\n\n\nSet method remove() removes its argument from the set — a KeyError occurs if the value is not in the set:\n\nnumbers.remove(3)\nnumbers\n\n{0, 1, 2, 4, 5, 6, 7, 8, 9, 17}\n\n\n\nnumbers.remove(11)\n\nKeyError: 11\n\n\nMethod discard() also removes its argument from the set but does not cause an exception if the value is not in the set.\n\nnumbers.discard(1)\nnumbers\n\n{2, 4, 5, 6, 7, 8, 9, 17}\n\n\n\nnumbers.discard(0)\n\n\n\n\n5.2.3 Mathematical Set Operations\nThe operators and methods presented in this section each result in a new set!\n\n5.2.3.1 Union\nThe union of two sets is a set consisting of all the unique elements from both sets. You can calculate the union with the | operator or with the set union() method:\n\n{1, 3, 5} | {2, 3, 4}\n\n{1, 2, 3, 4, 5}\n\n\n\n{1, 3, 5}.union([20, 20, 3, 40, 40])\n\n{1, 3, 5, 20, 40}\n\n\nThe operands of the binary set operators, like |, must both be sets. The corresponding set methods may receive any iterable object as an argument — we passed a list. When a mathematical set method receives a non-set iterable argument, it first converts the iterable to a set, then applies the mathematical operation.\n\n\n5.2.3.2 Intersection\nThe intersection of two sets is a set consisting of all the unique elements that the two sets have in common. You can calculate the intersection with the & operator or with the set intersection() method:\n\n{1, 3, 5} & {2, 3, 4}\n\n{3}\n\n\n\n{1, 3, 5}.intersection([1, 2, 2, 3, 3, 4, 4])\n\n{1, 3}\n\n\n\n\n5.2.3.3 Difference\nThe difference between two sets is a set consisting of the elements in the left operand that are not in the right operand. You can calculate the difference with the - operator or with the set difference() method:\n\n{1, 3, 5} - {2, 3, 4}\n\n{1, 5}\n\n\n\n{1, 3, 5, 7}.difference([2, 2, 3, 3, 4, 4])\n\n{1, 5, 7}\n\n\n\n\n5.2.3.4 Symmetric Difference\nThe symmetric difference between two sets is a set consisting of the elements of both sets that are not in common with one another. You can calculate the symmetric difference with the ^ operator or with the set symmetric_difference method:\n\n{1, 3, 5} ^ {2, 3, 4}\n\n{1, 2, 4, 5}\n\n\n\n{1, 3, 5, 7}.symmetric_difference([2, 2, 3, 3, 4, 4])\n\n{1, 2, 4, 5, 7}\n\n\n\n\n5.2.3.5 Disjoint\nTwo sets are disjoint if they do not have any common elements. You can determine this with the set isdisjoint() method:\n\n{1, 3, 5}.isdisjoint({2, 4, 6})\n\nTrue\n\n\n\n{1, 3, 5}.isdisjoint({4, 6, 1})\n\nFalse\n\n\n\n\n\n5.2.4 Set Comprehensions\nLike dictionary comprehensions, you define set comprehensions in curly braces. Let’s create a new set containing only the unique even values in the list numbers:\n\nnumbers = [1, 2, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 10]\nevens = {item for item in numbers if item % 2 == 0}\n\nevens\n\n{2, 4, 6, 8, 10}\n\n\n\n\n5.2.5 Sorting the set and dictionary\nAs we mentioned last week, data types like tuples don’t provide methods like sort(). However Python provides the built-in function sorted(), which takes any sequence as a parameter and returns a new container with the same elements in a different order. You can also apply sorted to the set, but the returning container will be list.\n\nhelp(sorted)\n\nHelp on built-in function sorted in module builtins:\n\nsorted(iterable, /, *, key=None, reverse=False)\n    Return a new list containing all items from the iterable in ascending order.\n    \n    A custom key function can be supplied to customize the sort order, and the\n    reverse flag can be set to request the result in descending order.\n\n\n\n\nRANKS = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n\ndef rank_key(card):\n    return RANKS.index(card)\n\nori_set = {\"A\", \"2\", \"7\", \"4\", \"Q\"}\nprint(sorted(ori_set))\nsorted_list = sorted(ori_set, key=rank_key) \n# Each element will be replaced by the output of rank_key() and sorts!\nprint(sorted_list)\n\n['2', '4', '7', 'A', 'Q']\n['A', '2', '4', '7', 'Q']\n\n\nNote that we have changed the behavior of the sorted() function by providing the custom key that allows us to sort the data in a specific order using the predefined list and the index() function.\nIf you would like to sort the dictionary, you need to use the items() method (Otherwise, it will only return keys). The returning container will again be a list:\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'introduction to computer science':90, 'linear algebra':95}\nsorted_list = sorted(grade.items())\nprint(sorted_list)\n\n[('calculus', 85), ('introduction to computer science', 90), ('introduction to mathematics', 80), ('linear algebra', 95)]\n\n\nIf you would like to sort by the value, use the following code:\n\ndef value_key(x):\n    return x[1]\n\ngrade = {'calculus':85, 'introduction to mathematics':80, 'computer programming':90, 'linear algebra':95}\nsorted_dict = sorted(grade.items(), key=value_key)\nprint(sorted_dict)\n\n[('introduction to mathematics', 80), ('calculus', 85), ('computer programming', 90), ('linear algebra', 95)]\n\n\n\n5.2.6 Exercise 2: Try to design a program that counts the number of unique characters in a string. Be sure to exclude the punctuation and white space and the character with upper and lower cases are treated as different characters.\n\n\n\n\n\nsource: https://realpython.com/python-encodings-guide/\n\n\nimport string\n\n# You can obtain all the punctuations using the following attribute\nstring.punctuation\n\n'!\"#$%&\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'\n\n\n\n# Sample text\ntext = \"The quick brown fox jumped over the lazy dog. The dog didn't seem to mind!\"\n\n# Create a set of punctuation characters\npunctuation = set(string.punctuation)\n    \n# Create a set of all characters included in the text\nall_chars = _____________\n    \n# Find the difference between the two sets to get the non-punctuation characters\nnon_punctuation_chars = ____________________________\n# Also remove the whitespace\n_____________________________\n    \n# Count the number of non-punctuation characters\nnum_unique_chars = len(non_punctuation_chars)\n\nprint(\"Number of unique characters:\", num_unique_chars)\n\n# Sanity check\nassert num_unique_chars == 27\n\nNumber of unique characters: 27\n\n\nIn this chapter, we discussed Python’s dictionary and set collections. They are both unorder, mutable and do not allow duplicates.\nWe said what a dictionary is and presented several examples. We showed the syntax of key–value pairs and showed how to use them to create dictionaries with comma-separated lists of key–value pairs in curly braces, {}. You also created dictionaries with dictionary comprehensions. You used square brackets, [], to retrieve the value corresponding to a key, and to insert and update key–value pairs. You also used the dictionary method update to change a key’s associated value. You iterated through a dictionary’s keys, values and items.\nYou created sets of unique immutable values. You combined sets with set operators and methods, changed sets’ values with the mutable set operations and created sets with set comprehensions. You saw that sets are mutable.\nA short comparison of the containers is shown below:\n\n\n\n\n\n\n\n\n\n\nFeature\nList\nTuple\nDictionary\nSet\n\n\n\n\nMutable (Can be modified in place)\nYes\nNo\nYes (keys are immutable)\nYes\n\n\nIterable (Can be use in for loop)\nYes\nYes\nYes\nYes\n\n\nOrdered (Can access by index, slicing)\nYes\nYes\nNo\nNo\n\n\nDuplicate Values\nAllowed\nAllowed\nNot in keys\nNot allowed"
  },
  {
    "objectID": "06_Manipulating_string.html#string",
    "href": "06_Manipulating_string.html#string",
    "title": "6  Manipulating Strings",
    "section": "6.1 String",
    "text": "6.1 String\nText is one of the most common forms of data your programs will handle. You already know how to concatenate two string together with the + operator, but you can do much more than that! You can extract partial strings from string just like sequence, add or remove spacing, convert letters to lowercase or uppercase, and check that strings are formatted correctly!\nThere are several ways to create a new string; the simplest is to enclose the elements in single or double quotes:\n\ntype(''), type(\"\")\n\n(str, str)\n\n\n\nOne benefit of using double quotes is that the string can have a single quote character in it.\n\n\nprint(\"I'am fine\")\n\nI'am fine\n\n\nA string is a sequence that maps index to case sensitive characters and thus belongs to sequence data type. Anything that we can apply to the sequence can also be applied to string. For instance, you can access the items (characters) one at a time with the bracket operator:\n\nfruit = 'banana'\nfruit[1]\n\n'a'\n\n\nSo “b” is the 0th letter (“zero-th”) of “banana”, “a” is the 1th letter (“one-th”), and “n” is the 2th (“two-th”) letter.\n\n\n\n\nsource: https://www.py4e.com/html3/06-strings\n\nlen() can be used to return the number of characters in a string:\n\nlen(fruit)\n\n6\n\n\nWe can use negative indices, which count backward from the end of the string.\n\nfruit[-1], fruit[-2]\n\n('a', 'n')\n\n\nSlicing also works on string to extract a substring from the original string. Remember that we can slice sequences using [start:stop:step]. The operator [start:stop] returns the part of the string from the “start-th” character to the “stop-th” character, including the first but excluding the last with step=1. If we omit the first index (before the colon), the slice starts at the beginning of the string. If we omit the second index, the slice goes to the end of the string:\n\ns = 'Cool-Python'\n\nprint(s[:5]) #same as s[0:5] \nprint(s[5:]) #same as s[5:len(s)] \nprint(s[::2]) #same as s[0:len(s):2]\nprint(s[::]) #same as s[:] and s[0:len(s):1] =&gt; copy the string\nprint(s[::-1]) #same as s[-1:-(len(s)+1):-1] =&gt; reverse the string\n\nCool-\nPython\nCo-yhn\nCool-Python\nnohtyP-looC\n\n\nStrings are “immutable”, which means that it cannot be modified:\n\ns = \"hello\"\ns[0] = 'y' \n\nTypeError: 'str' object does not support item assignment\n\n\nThe “object” in this case, is the string and the “item” is the character you tried to assign. The best you can do is create a new string that is a variation on the original:\n\nprint(id(s))\ns = 'y' + s[1:len(s)]\nprint(id(s))\nprint(s)\n\n1956771186608\n1956805647664\nyello\n\n\nA lot of computations involve processing a string one character at a time. Often they start at the beginning, select each character in turn, do something to it, and continue until the end. The traversal of string is just like we see before:\n\ns\n\n'yello'\n\n\n\n# Test if s contains 'o'\nfor char in s: # Retrieve item (character) one by one\n    if char == 'o':\n        print(\"There is an o\")\n        break\n\nThere is an o\n\n\nThe in and not in operators can be used with strings just like with list. An expression with two strings joined using in or not in will evaluate to a Boolean True or False:\n\nprint('Hello' in 'Hello, World')\nprint('cats' not in 'cats and dogs')\n\nTrue\nFalse"
  },
  {
    "objectID": "06_Manipulating_string.html#escape-characters",
    "href": "06_Manipulating_string.html#escape-characters",
    "title": "6  Manipulating Strings",
    "section": "6.2 Escape Characters",
    "text": "6.2 Escape Characters\nAn escape character lets you use characters that are otherwise impossible to put into a string. An escape character consists of a backslash (\\) followed by the character you want to add to the string. (Despite consisting of two characters, it is commonly referred to as a singular escape character.) For example, the escape character for a single quote is \\'. You can use this inside a string that begins and ends with single quotes\n\nspam = 'Say hi to Bob\\'s mother.'\nspam\n\n\"Say hi to Bob's mother.\"\n\n\nPython knows that since the single quote in Bob\\'s has a backslash, it is not a single quote meant to end the string. The escape characters \\' and \\\" let you put single quotes and double quotes inside your strings, respectively.\n\n\n\n\nEscape character\nPrints as\n\n\n\n\n\\'\nSingle quote\n\n\n\\\"\nDouble quote\n\n\n\\\\\nBackslash\n\n\n\\t\nTab\n\n\n\\n\nNewline (line break)\n\n\n\n\n\nprint(\"Hello there!\\nHow are you?\\n\\tI\\'m doing fine.\")\n\nHello there!\nHow are you?\n    I'm doing fine.\n\n\nWhile you can use the \\n escape character to put a newline into a string, it is often easier to use multiline strings. A multiline string in Python begins and ends with either three single quotes or three double quotes. Any quotes, tabs, or newlines in between the “triple quotes” are considered part of the string.\n\nprint('''Hello there,\nHow are you?\n        I'm doing fine\n''')\n\nHello there,\nHow are you?\n        I'm doing fine\n\n\n\nNotice that the single quote character in I'm does not need to be escaped. Escaping single and double quotes is optional in multiline strings.\n\n6.2.1 Raw Strings\nYou can place an r before the beginning quotation mark of a string to make it a raw string. A raw string completely ignores all escape characters and prints any backslash that appears in the string.\n\nprint(r'That is Carol\\'s cat.')\n\nThat is Carol\\'s cat.\n\n\nBecause this is a raw string, Python considers the backslash as part of the string and not as the start of an escape character. Raw strings are helpful if you are typing strings that contain many backslashes, such as the strings used for Windows file paths like r'C:\\Users\\Al\\Desktop'."
  },
  {
    "objectID": "06_Manipulating_string.html#putting-strings-inside-other-strings",
    "href": "06_Manipulating_string.html#putting-strings-inside-other-strings",
    "title": "6  Manipulating Strings",
    "section": "6.3 Putting Strings Inside Other Strings",
    "text": "6.3 Putting Strings Inside Other Strings\nPutting strings inside other strings is a common operation in programming. So far, we’ve been using the + operator and string concatenation to do this:\n\nname = 'Al'\nage = 33\nlanguage = 'Python'\nprint(\"\\nHey! I'm \" + name + \", \" + str(age)+ \" old and I love \" + language + \" Programing\")\n\n\nHey! I'm Al, 33 old and I love Python Programing\n\n\nHowever, this requires a lot of tedious typing. A simpler approach is to use string interpolation. The format operator, % allows us to construct strings, replacing parts of the strings with the data stored in variables. When applied to integers, % is the modulus operator. But when the first operand is a string, % is the format operator.\nThe first operand is the format string, which contains one or more format specifiers that specify how the second operand is formatted. The result is a string. For example, the format specifiers %d means that the second operand should be formatted as an integer (“d” stands for “decimal”). One benefit is that str() doesn’t have to be called to convert values to strings:\n\n\n\n\nsource: https://towardsdatascience.com/python-string-interpolation-829e14e1fc75\n\n\nprint(\"\\nHey! I'm %s, %d years old and I love %s Programing\"%(name,age,language))   # Like the printf in C\n\nWe can have more control over the formatting, for instance:\n\n\n\n\nsource: https://refactored.ai/microcourse/notebook?path=content%2F02-Python_for_Data_Scientists%2F03-Data_Structures_in_python%2F01-Basic_data_types_and_operators.ipynb\n\n\na = 32\nb = 32.145\nprint('a=%4d, b=%6.2f' % (a,b))\n\n\na = 32\nb = 32.145\nprint(f'{a:4d},{b:6.2f}')\n\n  32, 32.15\n\n\nBy default, Python right-aligns numbers and left-aligns other values such as strings. The numbers after % is the total field width and the field width for the decimal part (separated by .). For values with fewer characters than the field width, the remaining character positions are filled with spaces. The %f is used to format floating points and note that variable b has been rounded.\nPython 3.6 introduced f-strings (The f is for format), which is similar to string interpolation except that braces are used instead of %s, with the expressions placed directly inside the braces. Like raw strings, f-strings have an f prefix before the starting quotation mark. (Note that it is even possible to do inline arithmetic)\n\nprint(f\"\\nHey! I'm {name}, {age+2} years old and I love {language} Programing\") \n\nWe can have more control with the f-string besides the field width, like specifying left, right and center alignment with &lt;, &gt; and ^. Note now the format specifiers are placed after the variable separated by a colon:\n\nprint(f'[{a:&lt;15d}]')\nprint(f'[{b:^9.2f}]')\n\nIn addition, you can use + before the field width specifies that a positive number should be preceded by a +. A negative number always starts with a -. To fill the remaining characters of the field with 0s rather than spaces, place a 0 before the field width (and after the + if there is one):\n\nprint(f'[{a:+10d}]')\nprint(f'[{a:+010d}]')\n\nSee https://docs.python.org/3/library/string.html#formatspec for more details.\n\nYet another is the format() method, see https://realpython.com/python-string-formatting/#toc for more details.\n\n\n6.3.1 Exercise 1: Assuming we are designing a word game called “The Mysterious Island” and we need to print the statistics of the player each time the game begins. Try to complete the following function that receives the variables from the game and displays the information that right aligns with each other using the f-string:\n\nPlayer1 Stats:\nHealth:     100/100\nExperience:   0/150\nGold:   50.00/60.00\n\n\nPlayer2 Stats:\nHealth:      60/100\nExperience: 120/150\nGold:   40.00/60.00\nHint: You can first calculate the maximal width required for each row.\n\n\n\n\ndef print_stats(player_name, health, experience, gold):\n    print(f\"{player_name} Stats:\")\n    print(f\"Health:____/100\")\n    print(f\"Experience:______/150\")\n    print(f\"Gold:_____/60.00\")\n\n\ngame_title = \"The Mysterious Island\"\n\nwelcome_message = f'Welcome to \"{game_title}\" adventure!\\n\\n'\n# 1. Print the welcome_message\nprint(welcome_message)\n\n# 2. Use string and number formatting to print out the statistics\nplayer_name = \"Player1\"\nhealth = 100\nexperience = 0\ngold = 50.000\n\nprint_stats(player_name, health, experience, gold)\n\nprint(\"\\n\")\n\nplayer_name = \"Player2\"\nhealth = 60\nexperience = 120\ngold = 40.0\n\nprint_stats(player_name, health, experience, gold)"
  },
  {
    "objectID": "06_Manipulating_string.html#string-method",
    "href": "06_Manipulating_string.html#string-method",
    "title": "6  Manipulating Strings",
    "section": "6.4 String method",
    "text": "6.4 String method\nStrings are an example of Python objects. An object contains both data (the actual string itself) and methods, which are effective functions that are built into the object and are available to any instance of the object.\nPython has a function called dir(), which lists the methods available for an object.\n\ndir(s)\n\nWhile the dir() function lists the methods, and you can use help() to get some simple documentation on a method, a better source of documentation for string methods would be https://docs.python.org/library/stdtypes.html#string-methods.\n\n6.4.1 The upper(), lower() Methods\nThe upper() and lower() string methods return a new string where all the letters in the original string have been converted to uppercase or lowercase:\n\nspam = 'Hello, world!'\nspam = spam.upper()\nprint(spam)\nspam = spam.lower()\nprint(spam)\n\nNote that these methods do not change the string itself but return new string values. If you want to change the original string, you have to call upper() or lower() on the string and then assign the new string to the variable where the original was stored. This is why you must use spam = spam.upper() to change the string in spam instead of simply spam.upper(). (This is just like if a variable eggs contains the value 10. Writing eggs + 3 does not change the value of eggs, but eggs = eggs + 3 does.). These data types are immutable and can not be modified in-place.\nThe upper() and lower() methods are helpful if you need to make a case-insensitive comparison. For example, the strings 'great' and 'GREat' are not equal to each other. But in the following small program, it does not matter whether the user types Great, GREAT, or grEAT, because the string is first converted to lowercase.\n\nprint('How are you?')\nfeeling = input()\nif feeling.lower() == 'great':\n    print('I feel great too.')\nelse:\n    print('I hope the rest of your day is good.')\n\n\n\n6.4.2 The isX() Methods\nThere are several other string methods that have names beginning with the word is. These methods return a Boolean value that describes the nature of the string. Here are some common isX() string methods:\n\nisupper()/islower() Returns True if the string has at least one letter and all the letters are uppercase or lowercase\nisalpha() Returns True if the string consists only of letters and isn’t blank\nisalnum() Returns True if the string consists only of letters and numbers and is not blank\nisdecimal() Returns True if the string consists only of numeric characters and is not blank\nisspace() Returns True if the string consists only of spaces, tabs, and newlines and is not blank\nistitle() Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters\n\n\nprint('Hello, world!'.islower()) \nprint('hello, world!'.islower())\nprint('hello'.isalpha())\nprint('hello123'.isalnum())\nprint('hello123'.isdecimal())\nprint(' '.isspace())\nprint('This Is Title Case'.istitle())\n\nThe isX() string methods are helpful when you need to validate user input. For example, the following program repeatedly asks users for their age and a password until they provide valid input:\n\nwhile True:\n    print('Enter your age:')\n    age = input()\n    if age.isdecimal():\n        break\n    print('Please enter a number for your age.')\n\nwhile True:\n    print('Select a new password (letters and numbers only):')\n    password = input()\n    if password.isalnum():\n        break\n    print('Passwords can only have letters and numbers.')\n\nIn the first while loop, we ask the user for their age and store their input in age. If age is a valid (decimal) value, we break out of this first while loop and move on to the second, which asks for a password. Otherwise, we inform the user that they need to enter a number and again ask them to enter their age. In the second while loop, we ask for a password, store the user’s input in password, and break out of the loop if the input is alpha­numeric. If it wasn’t, we’re not satisfied, so we tell the user the password needs to be alphanumeric and again ask them to enter a password.\n\n\n6.4.3 The startswith() and endswith() Methods\nThe startswith() and endswith() methods return True if the string they are called on begins or ends (respectively) with the string passed to the method; otherwise, they return False:\n\nprint('Hello, world!'.startswith('Hello'))\nprint('abc123'.endswith('12'))\n\n\n\n6.4.4 The replace() methods\nThe replace() function is like a “search and replace” operation in a word processor:\n\ngreet = 'Hello Bob'\nnstr = greet.replace('Bob','Jane')\nprint(nstr)\n\n\n\n6.4.5 The join() and split() Methods\nThe join() method is useful when you have a list of strings that need to be joined together into a single string. The join() method is called on a string, gets passed a list of strings, and returns a string. The returned string is the concatenation of each string in the passed-in list.\n\nprint(', '.join(['cats', 'rats', 'bats']))     #Separated by comma\nprint(' '.join(['My', 'name', 'is', 'Simon'])) #Separated by white space\n\n\n' and '.join(['cats', 'rats', 'bats'])\n\n'cats and rats and bats'\n\n\nNotice that the string join() calls on is inserted between each string of the list argument. For example, when join(['cats', 'rats', 'bats']) is called on the ', ' string, the returned string is 'cats, rats, bats'.\nThe split() method does the opposite: It’s called on a string and returns a list of strings.\n\n'My name is Simon'.split()\n\nBy default, the string ‘My name is Simon’ is split wherever whitespace characters such as the space, tab, or newline characters are found. These whitespace characters are not included in the strings in the returned list. You can pass a delimiter string to the split() method to specify a different string to split upon:\n\n'cats, rats, bats'.split(',')\n\nA common use of split() is to split a multiline string along the newline characters:\n\nspam = '''Dear Alice,\nHow have you been? I am fine.\nThere is a container in the fridge\nthat is labeled \"Milk Experiment.\"\n\nPlease do not drink it.\nSincerely,\nBob'''\n\nspam.split('\\n')\n\nPassing split() the argument '\\n' lets us split the multiline string stored in spam along the newlines and return a list in which each item corresponds to one line of the string.\n\n\n6.4.6 Removing Whitespace with the strip(), lstrip() and rstrip() Methods\nSometimes you may want to strip off whitespace characters (space, tab, and newline) from the left side, right side, or both sides of a string. The strip() string method will return a new string without any whitespace characters at the beginning or end. The lstrip() and rstrip() methods will remove whitespace characters from the left and right ends, respectively.\n\nspam = '    Hello, World    \\n'\nspam.strip()\n\n'Hello, World'\n\n\n\nspam.lstrip()\n\n\nspam.rstrip()\n\n\n6.4.7 Exercise 2: When editing the markdown document, you can create a bulleted list by putting each list item on its own line and placing a - in front. But say you have a really large list to which you want to add bullet points. You could just type those - at the beginning of each line, one by one. Or you could automate this task with a short Python program! For example, if I have following text:\n\nLists of resources\nLists of books\nLists of videos\nLists of blogs\nAfter running the program, the text should contain the following:\n- Lists of resources\n- Lists of books\n- Lists of videos\n- Lists of blogs\n\n\n\n\ntext = \"\"\"Lists of resources\nLists of books\nLists of videos\nLists of blogs\"\"\"\n\n# 1. Separate lines into list using string method.\nlines = text.________\n\n# 2. Add -\nfor i, line in enumerate(lines):    # loop through all indexes for \"lines\" list\n    lines[i] = ________             # add - to each string in \"lines\" list\n\n# 3. Use string method to conctenate list of strings back to string\ntext = _____________\nprint(text)\n\nText is a common form of data, and Python comes with many helpful string methods to process the text stored in string. You will make use of indexing, slicing, and string methods in almost every Python program you write. The programs you are writing now don’t seem too sophisticated—they don’t have graphical user interfaces with images and colorful text. So far, you’re displaying text with print() and letting the user enter text with input(). However, another way to manipulate large amounts of text is by reading and writing files directly off the hard drive. You’ll learn how to do this with Python later on.\nThat just about covers all the basic concepts of Python programming! You’ll continue to learn new concepts throughout the rest of this course, but you now know enough to start writing some useful programs that can automate tasks. If you’d like to see a collection of short, simple Python programs built from the basic concepts you’ve learned so far, check out https://github.com/asweigart/pythonstdiogames/. Try copying the source code for each program by hand and then make modifications to see how they affect the behavior of the program. Once you have an understanding of how the program works, try re-creating the program yourself from scratch. You don’t need to re-create the source code exactly; just focus on what the program does rather than how it does it."
  },
  {
    "objectID": "07_Files.html#reading-from-a-file",
    "href": "07_Files.html#reading-from-a-file",
    "title": "7  Files and Exceptions",
    "section": "7.1 Reading from a File",
    "text": "7.1 Reading from a File\nNow that you’ve mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable.\nAn incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file.\n\n7.1.1 Reading the Contents of a File\nTo begin, we need a file with a few lines of text in it. Let’s start with a file that contains pi to 30 decimal places:\n\n%%writefile pi_digits.txt\n3.1415926535\n  8979323846\n  2643383279\n\nHere’s a program that opens this file, reads it, and prints the contents of the file to the screen:\n\nfile_object = open('pi_digits.txt')\nprint(file_object.read())\nfile_object.close()\n\n3.1415926535\n  8979323846\n  2643383279\n\n\n\nTo do any work with a file, even just printing its contents, you first need to open the file to access it. The open() function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that’s currently being executed is stored. The open() function returns an object representing the file. Here, open('pi_digits.txt') returns an object representing pi_digits.txt. Python assigns this object to file_object, which we’ll work with later in the program.\n\n# A recommended way:\nwith open('pi_digits.txt') as file_object: #  file_object = open('pi_digits.txt')\n    contents = file_object.read()          #  We do not have to call file_object.close()\nprint(contents.strip())\n\n3.1415926535\n  8979323846\n  2643383279\n\n\nThe keyword with closes the file once access to it is no longer needed. Notice how we call open() in this program but not close(). You could open and close the file by calling open() and close(), but if a bug in your program prevents the close() method from being executed, the file may never close! This may seem trivial, but improperly closed files can cause data to be lost or corrupted.\nOnce we have a file object representing pi_digits.txt, we use the read() method in the second line of our program to read the entire contents of the file and store it as one long string in contents. Since read() returns an empty string when it reaches the end of the file; this empty string shows up as a blank line. If you want to remove the extra blank line, you can use strip() in the call to print().\n\nIt’s not always easy to know exactly when you should close a file, but with the structure shown here, Python will figure that out for you. All you have to do is open the file and work with it as desired, trusting that Python will close it automatically when the with block finishes execution.\n\n\n\n7.1.2 File Paths\nSometimes, depending on how you organize your work, the file you want to open won’t be in the same directory as your program file. To get Python to open files from a directory other than the one where your program file is stored, you need to provide a file path , which tells Python to look in a specific location on your system. A relative file path will tell Python to look for a given location relative to the directory where the currently running program file is stored. For example, you’d write:\nwith open('text_files/filename.txt') as file_object:\nThis line tells Python to look for the desired .txt file in the folder text_files and assumes that text_files is located in the current directory.\n\nWindows systems use a backslash (\\) instead of a forward slash (/) when displaying file paths, but you can still use forward slashes in your code.\n\n\n!mkdir text_files\n\n\n%%writefile text_files/pi_digits2.txt\n3.1415926535\n  8979323846\n  2643383279\n\nWriting text_files/pi_digits2.txt\n\n\n\nwith open('text_files/pi_digits2.txt') as file_object:\n    contents = file_object.read()\nprint(contents.strip())\n\n3.1415926535\n  8979323846\n  2643383279\n\n\nYou can also tell Python exactly where the file is on your computer regardless of where the program that’s being executed is stored. This is called an absolute file path. Absolute paths are usually longer than relative paths, so it’s helpful to assign them to a variable and then pass that variable to open():\nfile_path = '/home/phonchi/other_files/text_files/filename.txt'\nwith open(file_path) as file_object:\n\n\n7.1.3 Reading Line by Line\nWhen you’re reading a file, you’ll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. You can use a for loop on the file object to examine each line from a file one at a time:\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object: # file_object is also iterable!\n    for line in file_object:\n        print(line.strip())\n\n3.1415926535\n8979323846\n2643383279\n\n\nTo examine the file’s contents, we work through each line in the file by looping over the file object. Since there is a newline in each line of file and the print function adds its own newline each time we call it, so we will end up with two newline characters at the end of each line: one from the file and one from print(). Using strip() on each line in the print() call eliminates these extra blank lines.\n\n\n7.1.4 Making a List of Lines from a File\nWhen you use with, the file object returned by open() is only available inside the with block that contains it. If you want to retain access to a file’s contents outside the with block, you can store the file’s lines in a list inside the block and then work with that list!\n\nfilename = 'pi_digits.txt'\nwith open(filename) as file_object:\n    lines = file_object.readlines()\n\nprint(lines) # List of strings\npi_string = ''\nfor line in lines:\n    pi_string += line.strip()\n    \nprint(pi_string)\nprint(len(pi_string)) # The string is 32 characters long because it also includes the leading 3 and a decimal point\n\n['3.1415926535\\n', '  8979323846\\n', '  2643383279\\n']\n3.141592653589793238462643383279\n32\n\n\nThe readlines() method takes each line from the file and stores it in a list. This list is then assigned to lines, which we can continue to work with after the with block ends. Here, we create a variable, pi_string, to hold the digits of pi. We then create a loop that adds each line of digits to pi_string and removes the newline character from each line.\n\nWhen Python reads from a text file, it interprets all text in the file as a string. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the int() function or convert it to a float using the float() function.\n\n\n\n7.1.5 Writing to a File\nOne of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program finishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later!\n\n7.1.5.1 Writing to an Empty File\nTo write text to a file, you need to call open() with a second argument telling Python that you want to write to the file\n\nfilename = 'programming.txt'\n\nwith open(filename, 'w') as file_object:\n    file_object.write(\"We love programming!\")\n\nThe call to open() in this example has two arguments. The first argument is still the name of the file we want to open. The second argument, ‘w’, tells Python that we want to open the file in write mode. You can open a file in read mode (‘r’), write mode (‘w’), append mode (‘a’), or a mode that allows you to read and write to the file ( ‘r+’). If you omit the mode argument, Python opens the file in read-only mode by default. Here, we use the write() method on the file object to write a string to the file.\n\nPython can only write strings to a text file. If you want to store numerical data in a text file, you’ll have to convert the data to string format first using the str() function.\n\n\nThe open() function automatically creates the file you’re writing to if it doesn’t already exist. However, be careful opening a file in write mode (‘w’) because if the file does exist, Python will erase the contents of the file before returning the file object.\n\n\nwith open(filename, 'w') as file_object:\n    print(\"12\")\n\n12\n\n\nWhile reading through a file, the system maintains a file-position pointer(index) representing the location of the next character to read. Therefore, the following code snippet will allow you to append it to the end of the file.\n\nyear = 2023\n\nwith open(filename, 'r+') as file_object:\n    spam = file_object.readlines()\n    print(file_object.tell())\n    print(len(\"We love programming!\"))\n    file_object.write(str(year))\n\n20\n20\n\n\nThe tell() function will return the current position of the file-position pointer. We can also use seek() to change the position. Checkout more details about file-position pointer here.\n\n\n\n7.1.6 Appending to a File\nIf you want to add content to a file instead of writing over existing content, you can also open the file in append mode. When you open a file in append mode, Python doesn’t erase the contents of the file before returning the file object. Any lines you write to the file will be added at the end of the file. If the file doesn’t exist yet, Python will create an empty file for you.\n\nfilename = 'programming.txt'\n\nwith open(filename, 'a') as file_object:\n    file_object.write(\"\\nWe also love finding meaning in large datasets.\\n\")\n    file_object.write(\"We love creating apps that can run in a browser.\\n\")\n\nThe write() function doesn’t add any newlines to the text you write. So we need to add newline characters if we would like to. There is also a writelines() function that can write list of strings into files."
  },
  {
    "objectID": "07_Files.html#storing-data",
    "href": "07_Files.html#storing-data",
    "title": "7  Files and Exceptions",
    "section": "7.2 Storing Data",
    "text": "7.2 Storing Data\nMany of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for visualization. Whatever the focus of your program is, you’ll store the information users provide in data structures such as lists and dictionaries. When users close a program, you’ll almost always want to save the information they entered. A simple way to do this involves storing your data using the json module.\nThe json module allows you to dump simple Python data structures into a file and load the data from that file the next time the program runs. You can also use json to share data between different programming languages. It’s a useful and portable format.\n\n7.2.0.1 Using json.dump() and json.load()\nThe json.dump() function takes two arguments: a piece of data to store and a file object it can use to store the data.\n\nimport json\n\nnumbers = [2, 3, 5, 7, 11, 13]\nfilename = 'numbers.json'\n\nwith open(filename, 'w') as f:\n    json.dump(numbers, f)\n\nNow we’ll write a program that uses json.load() to read the list back into memory\n\nfilename = 'numbers.json'\nwith open(filename) as f:\n    numbers = json.load(f)\n    \nprint(numbers)\n\n[2, 3, 5, 7, 11, 13]"
  },
  {
    "objectID": "07_Files.html#exceptions",
    "href": "07_Files.html#exceptions",
    "title": "7  Files and Exceptions",
    "section": "7.3 Exceptions",
    "text": "7.3 Exceptions\nPython uses special objects called exceptions to manage errors that arise during a program’s execution. Whenever an error makes Python unsure of what to do next, it creates an exception object. If we write code that handles the exception, the program will continue running. If you don’t handle the exception, the program will halt and show a traceback, which includes a report of the exception that was raised.\nExceptions are handled with try-except blocks. A try-except block tells Python what to do if an exception is raised. When we use try-except blocks, our programs will continue running even if things go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that we write!\n\n7.3.1 Handling the ZeroDivisionError Exception\n\nprint(5/0)\n\nZeroDivisionError: division by zero\n\n\nThe error reported at the first line in the traceback, ZeroDivisionError, is an exception object. Python creates this kind of object in response to a situation where it can’t do what we ask. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program.\nWhen we think an error may occur, you can write a try-except block to handle the exception that might be raised. We tell Python to try running some code and tell it what to do if the code results in a particular kind of exception.\n\ntry:\n    print(5/0)\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\n\nYou can't divide by zero!\n\n\nWe put print(5/0), the line that caused the error, inside a try block. If the code in a try block works, Python skips over the except block. If the code in the try block causes an error, Python looks for an except block whose error matches the one that was raised and ran the code in that block. In this example, the user sees a friendly error message instead of a traceback.\n\ntry:\n    print(5/0)\nexcept:\n    print(\"Exceptions occur!\")\n\nExceptions occur!\n\n\nIf you do not add any exception type, it will capture all exceptions!\n\n\n7.3.2 Using Exceptions to Prevent Crashes\nHandling errors correctly is especially important when the program has more work to do after the error occurs. Let’s create a simple calculator that does only division:\n\n%%writefile division_calculator.py\nprint(\"Give me two numbers, and I'll divide them.\")\nprint(\"Enter 'q' to quit.\")\n\nwhile True:\n    first_number = input(\"\\nFirst number: \")\n    if first_number == 'q':\n        break\n    second_number = input(\"Second number: \")\n    if second_number == 'q':\n        break\n    try:\n        answer = int(first_number) / int(second_number)\n    except ZeroDivisionError:\n        print(\"You can't divide by 0!\")\n    else: # Only executed if try block is succeed\n        print(answer)\n    finally: # Always executed\n        print(\"\\nGive me two numbers, and I'll divide them.\")\n        print(\"Enter 'q' to quit.\")\n\nOverwriting division_calculator.py\n\n\nHere, the error may occur on the line that performs the division, so that’s where we’ll put the try-except block. This example also includes an else block. Any code that depends on the try block executing successfully goes into the else block. In addition, the finally clause is guaranteed to execute, regardless of whether its try suite executes successfully or an exception occurs.\nWe ask Python to try to complete the division operation in a try block, which includes only the code that might cause an error. The program continues to run, and the user never sees a traceback.\n\n\n7.3.3 Handling the FileNotFoundError Exception\nOne common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename may be misspelled, or the file may not exist at all\n\nfilename = 'alice.txt'\nwith open(filename) as f: # Note it is in read mode\n    contents = f.read()\n\nFileNotFoundError: [Errno 2] No such file or directory: 'alice.txt'\n\n\n\nfilename = 'alice.txt'\ntry:\n    with open(filename) as f:\n        contents = f.read()\nexcept FileNotFoundError:\n    print(f\"Sorry, the file {filename} does not exist.\")\n\nSorry, the file alice.txt does not exist.\n\n\nIn this example, the code in the try block produces a FileNotFoundError, so Python looks for an except block that matches that error. Python then runs the code in that block, and the result is a friendly error message instead of a traceback.\n\n7.3.4 Exercise 1: Assuming we are designing a word game called “The Mysterious Island” and we need to load the statistics of the player and enemies each time the game begins. Try to complete the following functions load_data() and save_data() so that you can load the JSON file if it does not exist using the exception handling techniques you just learned.\n\n\n\n\n\nimport random\nimport time\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\ndef battle(player, enemy):\n    slow_print(f\"You encounter a {enemy['name']} with {enemy['hp']} HP!\")\n    while player['hp'] &gt; 0 and enemy['hp'] &gt; 0:\n        choice = input(\"Do you want to attack or escape? (a/e): \")\n        if choice.lower() == 'a':\n            player_damage = max(random.randint(player['attack']//2, player['attack']), 1)\n            enemy_damage = max(random.randint(enemy['attack']//2, enemy['attack']), 1)\n            slow_print(f\"You deal {player_damage} damage to the {enemy['name']}!\")\n            enemy['hp'] -= player_damage\n            if enemy['hp'] &lt;= 0:\n                break\n            slow_print(f\"The {enemy['name']} deals {enemy_damage} damage to you!\")\n            player['hp'] -= enemy_damage\n        elif choice.lower() == 'e':\n            escape_chance = random.randint(1, 10)\n            if escape_chance &lt;= 2:\n                slow_print(\"You successfully escape from the battle!\")\n                return\n            else:\n                slow_print(\"You failed to escape!\")\n                enemy_damage = max(random.randint(enemy['attack']//2, enemy['attack']), 1)\n                slow_print(f\"The {enemy['name']} deals {enemy_damage} damage to you!\")\n                player['hp'] -= enemy_damage\n        else:\n            slow_print(\"Invalid choice! Try again.\")\n    if player['hp'] &lt;= 0:\n        slow_print(\"You were defeated!\")\n        print(\"Game over!\")\n        return False\n    else:\n        slow_print(f\"You defeated the {enemy['name']}!\")\n\ndef load_data():\n    # Perform exception handling, if this is the first time you load the game\n    _____:\n        with open('game_data.json', 'r') as f:\n            data = ____________________ # Read the data here using load()\n    __________________________:\n        data = {\n            \"player\": {\n                \"name\": \"Player\",\n                \"hp\": 50,\n                \"attack\": 10\n            },\n            \"enemies\": [\n                {\n                    \"name\": \"Slime\",\n                    \"hp\": 10,\n                    \"attack\": 5\n                },\n                {\n                    \"name\": \"Goblin\",\n                    \"hp\": 25,\n                    \"attack\": 8\n                },\n                {\n                    \"name\": \"Dragon\",\n                    \"hp\": 80,\n                    \"attack\": 15\n                }\n            ]\n        }\n        save_data(data)\n    return data\n\ndef save_data(data):\n    with open('game_data.json', 'w') as f:\n        ______________# Save the data so that you can play again using dump()\n\ndata = load_data()\nplayer = data['player']\nenemies = data['enemies']\nflag = True\n\nfor enemy in enemies:\n    flag = battle(player, enemy)\n\nif flag != False: \n    print(\"Congratulations!\")\n\nYou encounter a Slime with 10 HP!\nYou deal 7 damage to the Slime!\nThe Slime deals 2 damage to you!\nInvalid choice! Try again.\nYou deal 9 damage to the Slime!\nYou defeated the Slime!\nYou encounter a Goblin with 25 HP!\nYou deal 6 damage to the Goblin!\nThe Goblin deals 8 damage to you!\nYou deal 7 damage to the Goblin!\nThe Goblin deals 5 damage to you!\nYou deal 7 damage to the Goblin!\nThe Goblin deals 4 damage to you!\nYou deal 10 damage to the Goblin!\nYou defeated the Goblin!\nYou encounter a Dragon with 80 HP!\nYou failed to escape!\nThe Dragon deals 13 damage to you!\nYou failed to escape!\nThe Dragon deals 9 damage to you!\nYou failed to escape!\nThe Dragon deals 15 damage to you!\nYou were defeated!\nGame over!\n\n\nIn this chapter, you learned how to work with files. You learned to read an entire file at once and read through a file’s contents one line at a time. You learned to write to a file and append text onto the end of a file. You learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program. Finally, You read about exceptions and how to handle the exceptions you’re likely to see in your programs."
  },
  {
    "objectID": "08_09_OOP.html#introduction",
    "href": "08_09_OOP.html#introduction",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.1 Introduction",
    "text": "8.1 Introduction\nIn the first lecture, we mentioned that everything in Python is an object, so you’ve been using objects constantly. Object Oriented Programming (OOP) is a programming paradigm that allows you to group variables (data/attributes) and functions (methods) into new data types called classes, from which you can create objects (instance). When you write a class, you define the general behavior that a whole category of objects can have.\nWhen you create individual objects from the class, each object is automatically equipped with the general behavior; you can then give each object whatever unique traits you desire. Making an object from a class is called instantiation, and you work with instances of a class. You’ve already used lots of classes created by other people (int, str, float, list, dict, etc.); these are designed to represent simple pieces of information, such as the cost of an apple, the name of a student. What if you want to represent something more complex? In this chapter, you’ll learn how to create your custom classes.\n\nLearning about OOP will help you see the world as a programmer does. Knowing the logic behind classes will train you to think logically, so you can write programs that effectively address almost any problem you encounter."
  },
  {
    "objectID": "08_09_OOP.html#creating-and-using-a-class",
    "href": "08_09_OOP.html#creating-and-using-a-class",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.2 Creating and Using a Class",
    "text": "8.2 Creating and Using a Class\nYou can model almost anything using classes. Let’s start by writing a simple class, Dog, that represents a dog — not one dog in particular, but any dog. What do we know about most pet dogs? Well, they all have a name and an age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they’re common to most dogs.\n\n8.2.1 Creating the Dog Class\nEach instance created from the Dog class will store a name and an age, and we’ll give each dog the ability to sit() and roll_over():\n\nclass Dog:\n    \"\"\"A simple attempt to model a dog.\"\"\"\n    def __init__(self, name, age):\n        \"\"\"Initialize name and age attributes.\"\"\"\n        self.name = name\n        self.age = age\n    def sit(self):\n        \"\"\"Simulate a dog sitting in response to a command.\"\"\"\n        print(f\"{self.name} is now sitting.\")\n    def roll_over(self):\n        \"\"\"Simulate rolling over in response to a command.\"\"\"\n        print(f\"{self.name} rolled over!\")\n\nWe first define a class called Dog with the class keyword. By convention, capitalized names refer to classes in Python. We then write a docstring describing what this class does.\n\nThere are no parentheses in the class definition here because we’re creating this class from scratch\n\n\n8.2.1.1 The __init__() Method\n\nA function that’s part of a class is a method. The __init__() method is a special method that Python runs whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python’s default method names from conflicting with your method names.\nThe self parameter is required in the method definition, and it must come first before any other parameters. It must be included in the definition because when Python calls this method later (to create an instance of Dog), the method call will automatically pass the self argument. The two variables defined in the body of the __init__() method each have the prefix self. Any variable prefixed with self (refer as instance attributes) is available to every method in the class, and we’ll also be able to access these variables through any instance created from the class, which can be different between instances.\nThe line self.name = name takes the value associated with the parameter name and assigns it to the variable name, which is then attached to the instance being created. The same process happens with self.age = age. Variables that are accessible through instances like this are called (instance) attributes.\n\nThe Dog class has two other methods defined: sit() and roll_over(). Because these methods don’t need additional information to run, we define them to have one parameter, self, so that the instances we create later will have access to these methods. In other words, they’ll be able to sit and roll over.\n\n\n8.2.1.2 Making an Instance from a Class\nWhen we make an instance of Dog, Python will call the __init__() method from the Dog class. We’ll pass Dog() a name and an age as arguments; self is passed automatically, so we don’t need to pass it.\n\nmy_dog = Dog('Willie', 6) # This is known as constructor expression\n\n# You can access their instance attributes using dot notation:\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"My dog is {my_dog.age} years old.\")\n\nHere, we tell Python to create a dog whose name is ‘Willie’ and whose age is 6, which is known as constructor expression. When Python reads this line, it calls the __init__() method in Dog with the arguments ‘Willie’ and 6. The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog. To access the attributes of an instance, you use dot notation. After we create an instance from the class Dog, we can use dot notation to call any method defined in Dog.\n\nmy_dog.sit()\nmy_dog.roll_over()\n\nTo call a method, give the name of the instance (in this case, my_dog) and the method you want to call, separated by a dot agian.\n\nThe class constructor of Python is actually divided into two steps. Check out here for more information. There is also a destructor __del__, but in Python, destructors are not needed as much as in C++ because Python has a garbage collector that handles memory management automatically.\n\n\n\n8.2.1.3 Creating Multiple Instances\nOnce you create a class, you can use it to create different objects.\n\nmy_dog = Dog('Willie', 6) \nyour_dog = Dog('Lucy', 3)\n\n# Even though my_dog and your_dog are both instances of the Dog class, they represent two distinct objects in memory.\nprint(my_dog == your_dog)\n\nprint(f\"My dog's name is {my_dog.name}.\")\nprint(f\"My dog is {my_dog.age} years old.\")\nmy_dog.sit()\n\nprint(f\"\\nYour dog's name is {your_dog.name}.\")\nprint(f\"Your dog is {your_dog.age} years old.\")\nyour_dog.sit()\n\nIn this example, we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own attributes, capable of the same set of actions."
  },
  {
    "objectID": "08_09_OOP.html#working-with-classes-and-instances",
    "href": "08_09_OOP.html#working-with-classes-and-instances",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.3 Working with Classes and Instances",
    "text": "8.3 Working with Classes and Instances\nOnce you write a class, you’ll spend most of your time working with instances created from that class. One of the first tasks you’ll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.\n\n8.3.1 The Car Class\nHere, we create another class that Car with four instance attributes:\n\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"Created in {self.year}, {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\nIn the Car class, we define the __init__() method with the self parameter first, just like we did with the Dog class. We also give it other parameters: make, model, year and odometer_reading. The __init__() method takes in these parameters and assigns them to the attributes associated with instances made from this class. When we make a new Car instance, we’ll need to specify a make, model, and year for our instance. We define a method called get_descriptive_name() that puts a car’s year, make, and model into one string neatly describing the car. To work with the attribute values in this method, we use self.make, self.model, and self.year.\nWhen an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, which assigns a default value. In the above example, an attribute called odometer_reading always starts with a value of 0. Finally, there is a method read_odometer() that helps us read each car’s odometer.\nOutside of the class, we make an instance from the Car class and assign it to the variable my_new_car. Then we call get_descriptive_name() to show what kind of car we have! Our car starts with a mileage of 0:\n\nmy_new_car = Car('audi', 'a4', 2023) \nprint(my_new_car.get_descriptive_name())\nmy_new_car.read_odometer()\n\nNot many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.\n\n8.3.1.1 Modifying Attribute Values\nYou can change an attribute’s value in different ways: you can change the value directly through an instance, set the value through a method, or increment the value (add a certain amount to it) through a method. The simplest way to modify the value of an attribute is to access the attribute directly through an instance.\n\nmy_new_car.odometer_reading = 23\nmy_new_car.read_odometer()\n\nIt can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally.\n\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"Created in {self.year}, {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n\n    ## We add these there methods!\n    def update_odometer(self, mileage):\n        \"\"\"\n        Set the odometer reading to the given value.\n        Reject the change if it attempts to roll the odometer back.\n        \"\"\"\n        if mileage &gt;= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n            \n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\n    def fill_gas_tank(self):\n        \"\"\"Filling the gas tank.\"\"\"\n        print(\"The gas tank is now full!\")\n\nThe only modification to Car is the addition of update_odometer(). This method takes in a mileage value and assigns it to self.odometer_reading. It also checks that the new reading makes sense before modifying the attribute. If the value provided for mileage is greater than or equal to the existing mileage, self.odometer_reading, you can update the odometer reading to the new mileage. If the new mileage is less than the existing mileage, you’ll get a warning that you can’t roll back an odometer! In addition, we also define the new method increment_odometer() takes in a number of miles and adds this value to self.odometer_reading. Finally, a method fill_gas_tank() is also added to the class.\n\nmy_new_car = Car('audi', 'a4', 2023)\nprint(my_new_car.get_descriptive_name())\n\nmy_new_car.update_odometer(23)\nmy_new_car.read_odometer()\n\nmy_new_car.fill_gas_tank()\nmy_new_car.increment_odometer(100)\nmy_new_car.read_odometer()\n\n\nYou can use methods like this to control how users use your program by including additional logic.\n\n\n\n8.3.1.2 __repr__ and __str__ method\nNotice that when you evaluate the my_new_car, it will return a message that returns the address of the object:\n\nmy_new_car\n\nWhen writing your classes, it’s a good idea to have a method that returns a string containing useful information about a class instance. You can change this behavior by adding a special function __repr__:\n\nclass Car:\n    \"\"\"A simple attempt to represent a car.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"Initialize attributes to describe a car.\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"Return a neatly formatted descriptive name.\"\"\"\n        long_name = f\"Created in {self.year} {self.make} {self.model}\"\n        return long_name.title()\n    \n    def read_odometer(self):\n        \"\"\"Print a statement showing the car's mileage.\"\"\"\n        print(f\"This car has {self.odometer_reading} miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\"\n        Set the odometer reading to the given value.\n        Reject the change if it attempts to roll the odometer back.\n        \"\"\"\n        if mileage &gt;= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n            \n    def increment_odometer(self, miles):\n        \"\"\"Add the given amount to the odometer reading.\"\"\"\n        self.odometer_reading += miles\n\n    def fill_gas_tank(self):\n        \"\"\"Filling the gas tank.\"\"\"\n        print(\"The gas tank is now full!\")\n\n    ## We add these two methods!\n    def __repr__(self):\n        return f'Car(make={self.make}, model={self.model}, year={self.year})'\n    \n    def __str__(self):\n        return self.get_descriptive_name()\n\n\nmy_new_car = Car('audi', 'a4', 2023)\nmy_new_car\n\nThe Python documentation indicates that __repr__ returns the “official” string representation of the object. We also define the __str__ special method that is used to replace the behavior of __repr__ in some cases. This method is called when you convert an object to a string with the built-in function str(), such as when you print an object or call str() explicitly.\n\nprint(my_new_car)\nstr(my_new_car)\n\n\nSpecial methods like __init__(), __str__() and __repr__ are called dunder methods (Double UNDERscore). There are many dunder methods that you can use to customize classes i\n\n\n8.3.2 Exercise 1: Create a Pokemon class with three instance attributes: name, which stores the name of the Pokemon as a string, type which stores the type of Pokemon (e.g., “Fire”, “Water”, “Grass”, etc.) as string and total_species as an integer. In addition, add the __str__() method to the class so that it can print out meaningful information as follows:\n\nPikachu (Electric, total species 320)\nComplete the following class and execute the code cell to see which six Pokemon you get.\n\n\n\n\nsource: https://www.trustedreviews.com/reviews/pokemon-legends-arceus\n\n\n### If you are not using anaconda, you need to install the following package:\n#%pip install requests\n\n\nclass Pokemon:\n    # Your code here\n    def __init__(,_,_,_):\n        _______\n\n    # Your code here\n    def __str__(_):\n        return f\"{_} ({_}, total specis {_})\"\n\n\nimport random\nimport json \nimport time\nimport requests\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\n## 1. Download the data\nurl = 'https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json'\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    with open('pokedex.json', 'w', encoding = \"utf-8\") as f:\n        f.write(response.text)\nelse:\n    print(f\"Failed to download the file. Status code: {response.status_code}\")\n\nwith open('Pokedex.json', 'r' , encoding = \"utf-8\") as file:\n    pokemon_data = json.load(file)\n\n## 2. Randomly pick 6 pokemon\n\nrandom.shuffle(pokemon_data)\npicks = pokemon_data[:6]\n\n\n## 3. Print the pokemon you got!\nprint(\"The pokemon you got are: \")\nfor i in range(6):\n    pokemon = Pokemon(picks[i]['name']['english'], picks[i]['type'][0], sum([picks[i]['base'][key] for key in picks[i]['base'] if key != \"name\"]))\n    slow_print(str(pokemon))"
  },
  {
    "objectID": "08_09_OOP.html#inheritance",
    "href": "08_09_OOP.html#inheritance",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.4 Inheritance",
    "text": "8.4 Inheritance\nYou don’t always have to start from scratch when writing a class. If the class you’re writing is a specialized version of another class you wrote, you can use inheritance which is called ” is a” releationship. When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class, and the new class is the child class. The child class can inherit any or all of the attributes and methods of its parent class, but it’s also free to define new attributes and methods of its own.\n\n\n\n\nsource: https://realpython.com/inheritance-composition-python/\n\n\n8.4.1 The __init__() method for a Child Class\nWhen writing a new class based on an existing class, we will often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let’s model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote about earlier. Then we’ll only have to write code for the attributes and behaviors specific to electric cars.\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year) # Call the constructor of parent class\n        self.battery_size = 40\n   \n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n\nWhen you create a child class, the parent class must be part of the current file and appear before the child class. We then define the child class, ElectricCar. The name of the parent class must be included in parentheses in the definition of a child class.\nThe __init__() method takes in the information required to make a Car instance. The super() function is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car, which gives an ElectricCar instance all the attributes defined in that method. The name super comes from a convention of calling the parent class a superclass (base class) and the child class a subclass (derived class).\nWe also add a new attribute specific to electric cars (a battery) and a method to report on this attribute. We’ll store the battery size and write a method that prints a description of the battery. This attribute/method will be associated with all instances created from the ElectricCar class but won’t be associated with any instances of Car.\n\nWe make an instance of the ElectricCar class and assign it to my_leaf.\n\nmy_leaf = ElectricCar('nissan', 'leaf', 2023) \nprint(my_leaf.get_descriptive_name())\nmy_leaf.describe_battery()\n\nWhen we need to know the type of an object, we can pass the object to the built-in type() function. But if we’re doing a type check of an object, it’s a better idea to use the more flexible isinstance() built-in function. The isinstance() function will return True if the object is of the given class or a subclass of the given class.\n\ntype(my_leaf)\n\n\nisinstance(my_leaf, ElectricCar)\n\n\nisinstance(my_leaf, Car)\n\n\n8.4.1.1 Overriding Methods from the Parent Class\nYou can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Say the class Car had a method called fill_gas_tank(). This method is meaningless for an all-electric vehicle, so you might want to override this method. Here’s one way to do that:\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery_size = 40\n   \n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n\n    ## We overide the method here\n    def fill_gas_tank(self):\n        \"\"\"Electric cars don't have gas tanks.\"\"\"\n        print(\"This car doesn't have a gas tank!\")\n\nNow if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead.\n\nWhen you use inheritance, you can make your child classes retain what you need and override anything you don’t need from the parent class.\n\n\nmy_leaf = ElectricCar('nissan', 'leaf', 2023) \nmy_leaf.fill_gas_tank()\n\n\n\n8.4.1.2 Use composition to organize the code\nWhen modeling something from the real world in code, you may add more detail to a class. You’ll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together; this approach is called composition, which is sometimes referred to as the “has a” releationship.\nFor example, if we continue adding detail to the ElectricCar class, we might notice that we’re adding many attributes and methods specific to the car’s battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery. Then we can use a Battery instance as an attribute in the ElectricCar class:\n\nclass Battery:\n    \"\"\"A simple attempt to model a battery for an electric car.\"\"\"\n\n    def __init__(self, battery_size=40):\n        \"\"\"Initialize the battery's attributes.\"\"\"\n        self.battery_size = battery_size\n\n    def describe_battery(self):\n        \"\"\"Print a statement describing the battery size.\"\"\"\n        print(f\"This car has a {self.battery_size}-kWh battery.\")\n        \n    def get_range(self):\n        \"\"\"Print a statement about the range this battery provides.\"\"\"\n        if self.battery_size == 40:\n            range = 150 # Class attributes\n        elif self.battery_size == 65:\n            range = 225\n        print(f\"This car can go about {range} miles on a full charge.\")\n\n\nclass ElectricCar(Car):\n    \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"\n        Initialize attributes of the parent class.\n        Then initialize attributes specific to an electric car.\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery = Battery()\n\nWe define a new class called Battery that doesn’t inherit from any other class. The __init__() method has one parameter, battery_size, in addition to self. This optional parameter sets the battery’s size to 40 if no value is provided. The method describe_battery() has been moved to this class as well. A new method, get_range(), performs some simple analysis and is also added.\nIn the ElectricCar class, we now add an attribute called self.battery. This tells Python to create a new instance of Battery (with a default size of 40) and assign that instance to the attribute self.battery. Any ElectricCar instance will now have a Battery instance created automatically. When we want to describe the battery, we need to work through the car’s battery attribute:\n\nmy_leaf = ElectricCar('nissan', 'leaf', 2023)\nprint(my_leaf.get_descriptive_name())\nmy_leaf.battery.describe_battery()\nmy_leaf.battery.get_range()\n\n\nInheritance and composition are two essential concepts in object-oriented programming that model the relationship between two classes. Check out here for more in-depth comparisons."
  },
  {
    "objectID": "08_09_OOP.html#encapsulation---attributes-for-data-access",
    "href": "08_09_OOP.html#encapsulation---attributes-for-data-access",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.5 Encapsulation - Attributes for data access",
    "text": "8.5 Encapsulation - Attributes for data access\nMost object-oriented programming languages enable you to encapsulate (or hide) an object’s data from the code. Such data in these languages are said to be private data. Python does not have private data. Instead, you use naming conventions to design classes that encourage correct use. By convention, Python programmers know that any attribute name beginning with an underscore (_) is for a class’s internal use only. Code should use the class’s methods to interact with each object’s internal-use data attributes. Attributes whose identifiers do not begin with an underscore (_) are considered publicly accessible.\n\nHowever, even when we use these conventions, attributes are always accessible.\n\nLet’s develop a Time class that stores the time in 24-hour clock format with hours in the range 0–23 and minutes and seconds each in the range 0–59:\n\nclass Time:\n    \"\"\"Class Time with read-write attributes.\"\"\"\n\n    def __init__(self, hour=0, minute=0, second=0):\n        \"\"\"Initialize each attribute.\"\"\"\n        self.set_hour(hour)      # 0-23, note that this line calls the setter method hour\n        self.set_minute(minute)  # 0-59, note that this line calls the setter method minute\n        self.set_second(second)  # 0-59, note that this line calls the setter method second\n\n    #getter\n    def get_hour(self):\n        \"\"\"Return the hour.\"\"\"\n        print(\"getter is called\")\n        return self._hour # Private data\n\n    #setter\n    def set_hour(self, hour):\n        \"\"\"Set the hour.\"\"\"\n        print(\"setter is called\")\n        if not (0 &lt;= hour &lt; 24):\n            raise ValueError(f'Hour ({hour}) must be 0-23')\n\n        self._hour = hour\n\n    #getter\n    def get_minute(self):\n        \"\"\"Return the minute.\"\"\"\n        return self._minute # Private data\n\n    #setter\n    def set_minute(self, minute):\n        \"\"\"Set the minute.\"\"\"\n        if not (0 &lt;= minute &lt; 60):\n            raise ValueError(f'Minute ({minute}) must be 0-59')\n\n        self._minute = minute\n\n    #getter\n    def get_second(self):\n        \"\"\"Return the second.\"\"\"\n        return self._second # Private data\n\n    #setter\n    def set_second(self, second):\n        \"\"\"Set the second.\"\"\"\n        if not (0 &lt;= second &lt; 60):\n            raise ValueError(f'Second ({second}) must be 0-59')\n\n        self._second = second\n\n\nClass Time’s __init__ method specifies hour, minute and second parameters, each with a default argument of 0. The statements containing self.set_hour(), self.set_minute() and self.set_second() call methods that implement the class’s setter. Those methods then create attributes named _hour, _minute and _second that is meant for use only inside the class!\nLines 10–21 define methods that manipulate a data attribute named _hour. The single-leading-underscore (_) naming convention indicates that we should not access _hour directly. We define a getter method which gets (that is, returns) a data attribute’s value and a setter method, which sets a data attribute’s value.\n\nHere is how we initialize an object:\n\nwake_up = Time(hour=8, minute=30)\n\nsetter is called\n\n\nThe following code expression invokes the getter method:\n\nwake_up.get_hour()\n# Instead of wake_up._hour\n\ngetter is called\n\n\n8\n\n\nThe following code expression invokes the setter by assigning a value to the attribute:\n\nwake_up.set_hour(8)\n# Instead of wake_up._hour = 8\n\nsetter is called\n\n\nClass Time’s getter and setter define the class’s public interface — that is, the set of attributes programmers should use to interact with objects of the class. Just like the private attributes above, not all methods need to serve as part of a class’s interface. Some serve as utility methods used only inside the class and are not intended to be part of the class’s public interface used by others. Such methods should be named with a single leading underscore. In other object-oriented languages like C++, Java and C#, such methods typically are implemented as private methods.\n\nIn Python, there is a more Pythonic way to define the getter and setter using properties. You can check out here for more information.\n\nNote that although we define the public interface, the internal attribute can still be accessed.\n\nwake_up._hour\n\n8\n\n\n\n8.5.1 Simulating “Private” Attributes\nIn programming languages such as C++, Java and C#, classes state explicitly which class members are publicly accessible. Class members that may not be accessed outside a class definition are private and visible only within the class that defines them. Python programmers often use “private” attributes for data or utility methods that are essential to a class’s inner workings but are not part of the class’s public interface.\nRather than _hour, we can name the attribute __hour with two leading underscores. This convention indicates that __hour is “private” and should not be accessible to the class’s clients.\n\nclass PrivateClass:\n    \"\"\"Class with public and private attributes.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the public and private attributes.\"\"\"\n        self.public_data = \"public\"  # public attribute\n        self._private_data = \"private1\"  # private attribute\n        self.__private_data = \"private2\"  # private attribute\n\n\nmy_object = PrivateClass()\nmy_object.public_data\n\n'public'\n\n\nWhen we attempt to access __private_data directly, we get an AttributeError indicating that the class does not have an attribute by that name:\n\nmy_object._private_data\n\n'private1'\n\n\n\nmy_object.__private_data\n\nAttributeError: 'PrivateClass' object has no attribute '__private_data'\n\n\n\nEven with double-underscore (__) naming, we can still access and modify __private_data, because we know that Python renames attributes simply by prefixing their names with ‘_ClassName’\n\n\nprint(my_object._PrivateClass__private_data)\nmy_object._PrivateClass__private_data = 'modified'\nprint(my_object._PrivateClass__private_data)\n\nprivate2\nmodified"
  },
  {
    "objectID": "08_09_OOP.html#class-methods",
    "href": "08_09_OOP.html#class-methods",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.6 Class Methods",
    "text": "8.6 Class Methods\nClass methods are associated with a class rather than individual objects like regular methods are. You can recognize a class method in code when you see two markers: the @classmethod decorator before the method’s def statement and the use of cls as the first parameter, as shown in the following example:\n\nclass ExampleClass:\n    def exampleRegularMethod(self):\n        print('This is a regular method.')\n\n    @classmethod # This is the \"decorator\" that takes another function as input, extends or modifies its behavior, and returns a new function\n    def exampleClassMethod(cls):\n        print('This is a class method.')\n\n\nExampleClass.exampleRegularMethod() # This is not a valid statement\n\nTypeError: exampleRegularMethod() missing 1 required positional argument: 'self'\n\n\n\n# Call the class method without instantiating an object:\nExampleClass.exampleClassMethod()\n\nobj = ExampleClass()\n# Given the above line, these two lines are equivalent:\nobj.exampleClassMethod() # It will implicitly pass the class instead of the object\nobj.__class__.exampleClassMethod()\n\nThe cls parameter acts like self except self refers to an object, but the cls parameter refers to an object’s class. This means that the code in a class method cannot access an individual object’s attributes or call an object’s regular methods. Class methods can only call other class methods or access class attributes. We often call class methods through the class, as in ExampleClass.exampleClassMethod(). But we can also call them through any object of the class, as in obj.exampleClassMethod().\nClass methods aren’t commonly used. The most frequent use case is to provide alternative constructor methods besides __init__(). For example, what if a constructor function could accept either a string of data the new object needs or a string of a filename that contains the data the new object needs? We don’t want the __init__() method’s parameters to be lengthy and confusing. Instead, let’s use class methods to return a new object. For example, let’s create an AsciiArt class:\n\n%%writefile pokeball.txt\n⠀⠀⠀⠀⠀⠀⠀⠀  \n⠀⠀⠀⠀⠀⠀⣀⣴⡶⠿⠛⠛⠛⠛⠛⠛⠻⠷⣦⣄⡀⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⣠⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣦⡀⠀⠀⠀  \n⠀⠀⢠⣾⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⠀⠀  \n⠀⢠⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣇⠀  \n⠀⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄  \n⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇  \n⠸⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇  \n⠀⣿⣿⣦⣀⠀⠀⠀⠀⠀⣠⣴⣶⢶⣦⣤⡀⠀⠀⠀⠀⢀⣠⣾⣿⠇ \n⠀⠸⣷⡈⠛⠿⣶⣦⣤⣼⠟⡡⠒⠒⢢⠙⣿⣤⣤⣶⠾⠟⠋⣰⡟⠀\n⠀⠀⠹⣷⡄⠀⠀⠀⠉⣿⣄⠣⣀⢀⡠⢀⣿⠏⠁⠀⠀⢀⣴⡟⠀⠀ \n⠀⠀⠀⠈⠻⣦⣄⠀⠀⠈⠻⢷⣦⣤⣶⠿⠋⠀⠀⢀⣤⡾⠋⠀⠀⠀ \n⠀⠀⠀⠀⠀⠈⠛⠷⣦⣤⣀⣀⠀⠀⣀⣀⣠⣤⡶⠟⠋⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠛⠛⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀\n\nOverwriting pokeball.txt\n\n\n\nclass AsciiArt:\n    def __init__(self, characters):\n        \"\"\" Approach1: Initialize it with string \"\"\"\n        self._characters = characters\n\n    @classmethod\n    def fromFile(cls, filename):\n        \"\"\" Approach2: Initialize it with filename \"\"\"\n        with open(filename) as fileObj:\n            characters = fileObj.read()\n        return AsciiArt(characters) # This calls the __init__ function, notice the use of return statement\n\n    def display(self):\n        print(self._characters)\n\n    # Other AsciiArt methods would go here...\n\n\nball1 = AsciiArt(\"\"\"⠀⠀⠀⠀⠀⠀⠀  \n⠀⠀⠀⠀⠀⠀⣀⣴⡶⠿⠛⠛⠛⠛⠛⠛⠻⠷⣦⣄⡀⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⣠⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣦⡀⠀⠀⠀  \n⠀⠀⢠⣾⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⠀⠀  \n⠀⢠⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣇⠀  \n⠀⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄  \n⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇  \n⠸⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇  \n⠀⣿⣿⣦⣀⠀⠀⠀⠀⠀⣠⣴⣶⢶⣦⣤⡀⠀⠀⠀⠀⢀⣠⣾⣿⠇ \n⠀⠸⣷⡈⠛⠿⣶⣦⣤⣼⠟⡡⠒⠒⢢⠙⣿⣤⣤⣶⠾⠟⠋⣰⡟⠀\n⠀⠀⠹⣷⡄⠀⠀⠀⠉⣿⣄⠣⣀⢀⡠⢀⣿⠏⠁⠀⠀⢀⣴⡟⠀⠀ \n⠀⠀⠀⠈⠻⣦⣄⠀⠀⠈⠻⢷⣦⣤⣶⠿⠋⠀⠀⢀⣤⡾⠋⠀⠀⠀ \n⠀⠀⠀⠀⠀⠈⠛⠷⣦⣤⣀⣀⠀⠀⣀⣀⣠⣤⡶⠟⠋⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠛⠛⠋⠉⠁⠀⠀⠀⠀⠀\"\"\"\n)\n\nball1.display()\n\nball2 = AsciiArt.fromFile('pokeball.txt')\nball2.display()\n\n⠀⠀⠀⠀⠀⠀⠀  \n⠀⠀⠀⠀⠀⠀⣀⣴⡶⠿⠛⠛⠛⠛⠛⠛⠻⠷⣦⣄⡀⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⣠⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣦⡀⠀⠀⠀  \n⠀⠀⢠⣾⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⠀⠀  \n⠀⢠⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣇⠀  \n⠀⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄  \n⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇  \n⠸⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇  \n⠀⣿⣿⣦⣀⠀⠀⠀⠀⠀⣠⣴⣶⢶⣦⣤⡀⠀⠀⠀⠀⢀⣠⣾⣿⠇ \n⠀⠸⣷⡈⠛⠿⣶⣦⣤⣼⠟⡡⠒⠒⢢⠙⣿⣤⣤⣶⠾⠟⠋⣰⡟⠀\n⠀⠀⠹⣷⡄⠀⠀⠀⠉⣿⣄⠣⣀⢀⡠⢀⣿⠏⠁⠀⠀⢀⣴⡟⠀⠀ \n⠀⠀⠀⠈⠻⣦⣄⠀⠀⠈⠻⢷⣦⣤⣶⠿⠋⠀⠀⢀⣤⡾⠋⠀⠀⠀ \n⠀⠀⠀⠀⠀⠈⠛⠷⣦⣤⣀⣀⠀⠀⣀⣀⣠⣤⡶⠟⠋⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠛⠛⠋⠉⠁⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀  \n⠀⠀⠀⠀⠀⠀⣀⣴⡶⠿⠛⠛⠛⠛⠛⠛⠻⠷⣦⣄⡀⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⣠⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣦⡀⠀⠀⠀  \n⠀⠀⢠⣾⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⠀⠀  \n⠀⢠⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣇⠀  \n⠀⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄  \n⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇  \n⠸⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇  \n⠀⣿⣿⣦⣀⠀⠀⠀⠀⠀⣠⣴⣶⢶⣦⣤⡀⠀⠀⠀⠀⢀⣠⣾⣿⠇ \n⠀⠸⣷⡈⠛⠿⣶⣦⣤⣼⠟⡡⠒⠒⢢⠙⣿⣤⣤⣶⠾⠟⠋⣰⡟⠀\n⠀⠀⠹⣷⡄⠀⠀⠀⠉⣿⣄⠣⣀⢀⡠⢀⣿⠏⠁⠀⠀⢀⣴⡟⠀⠀ \n⠀⠀⠀⠈⠻⣦⣄⠀⠀⠈⠻⢷⣦⣤⣶⠿⠋⠀⠀⢀⣤⡾⠋⠀⠀⠀ \n⠀⠀⠀⠀⠀⠈⠛⠷⣦⣤⣀⣀⠀⠀⣀⣀⣠⣤⡶⠟⠋⠀⠀⠀⠀⠀ \n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠛⠛⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀\n\n\n\nThe AsciiArt class has an __init__() method that can be passed the text characters of the image as a string. It also has a fromFile() class method that can be passed the filename string of a text file containing the ASCII art. Both methods create AsciiArt objects. Note that the last line of fromFile() calls __init__() method. This is a trick you can use to follow the “Don’t Repeat Yourself (DRY)” principle. If we rename this class or modify the content of the constructor (__init__) at some point, we won’t have to remember to update the class method.\n\n8.6.1 Class Attributes\nA class attribute is a variable that belongs to the class rather than to an object. We create class attributes inside the class but outside all methods, just like we can create global variables in a .py file but outside all functions. Here’s an example of a class attribute named count, which keeps track of how many CreateCounter objects have been created:\n\nclass CreateCounter:\n    count = 0 # This is a class attribute.\n\n    def __init__(self):\n        CreateCounter.count += 1\n\nprint('Objects created:', CreateCounter.count)  # Prints 0.\na = CreateCounter()\nb = CreateCounter()\nc = CreateCounter()\nprint('Objects created:', CreateCounter.count)  # Prints 3.\n\nObjects created: 0\nObjects created: 3\n\n\nThe CreateCounter class has a single class attribute named count. All CreateCounter objects share this attribute rather than having their own separate count attributes. This is why the CreateCounter.count += 1 line in the constructor function can keep count of every CreateCounter object created.\n\n\n8.6.2 Static Methods\nA static method doesn’t have a self or cls parameter. Static methods are effectively just functions, because they can’t access the attributes or methods of the class (using cls) or its objects (using self).\nWe define static methods by placing the @staticmethod decorator before their def statements. Here is an example of a static method:\n\nclass ExampleClassWithStaticMethod:\n    @staticmethod\n    def sayHello():\n        print('Hello!')\n\n# Note that no object is created, the class name precedes sayHello():\n\nExampleClassWithStaticMethod.sayHello()\n\nobj = ExampleClassWithStaticMethod()\nobj.sayHello()\n\nHello!\nHello!\n\n\n\nStatic methods are more common in other languages that don’t have Python’s flexible language features. Python’s inclusion of static methods imitates the features of other languages but doesn’t offer much practical value.\n\nYou’ll rarely need class methods, class attributes, and static methods, and they’re also prone to overuse. If you’re thinking, “Why can’t I just use a function or global variable instead?” this is a hint that you probably don’t need to use a class method, class attribute, or static method. The only reason we cover them is so you can recognize them when you encounter them in code. You can find more information about the discussion here."
  },
  {
    "objectID": "08_09_OOP.html#polymorphism",
    "href": "08_09_OOP.html#polymorphism",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.7 Polymorphism",
    "text": "8.7 Polymorphism\nPolymorphism allows objects of one type to be treated as objects of another type (class).\n\nFor example, the len() function returns the length of the argument passed to it. You can pass a string to len() to see how many characters it has, but you can also pass a list or dictionary to len() to see how many items or key-value pairs it has, respectively. This polymorphism of function is called generic functions or method/function overloading because it can handle objects of many different types.\nPolymorphism also includes operator overloading, where operators (such as + or *) can behave differently based on the type of objects they’re operating on. For example, the + operator does mathematical addition when operating on two integer or float values, but it does string concatenation when operating on two strings.\n\nIn Python, we can achieve method polymorphism by defining a method in a base class and then overriding it in the derived classes. Each derived class can then provide its implementation of the method. For example:\n\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        pass # Don't do anything and prevent error by using this keyword\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\ndef speak(animal):\n    print(animal.speak())\n\nanimals = [Dog(\"Rufus\"), Cat(\"Whiskers\"), Dog(\"Buddy\")]\n\n# method overloading\nfor animal in animals:\n    print(f'{animal.name} : {animal.speak()}')\n\n# function overloading\nfor animal in animals:\n    speak(animal)\n\nRufus : Woof!\nWhiskers : Meow!\nBuddy : Woof!\nWoof!\nMeow!\nWoof!\n\n\nIn this example, the Animal class defines the speak method as a pass statement, meaning it does nothing. However, both Dog and Cat classes override the method with their implementation of the method. This is called method overriding and is also a form of polymorphism. The speak() function accepts any object that implements the speak() method, meaning it can handle animals of different types. Here, we can pass both Dog and Cat objects to the speak() function, as they both inherit the speak() method from the Animal class.\n\n8.7.1 Operator overloading\nPython has several dunder method. You’re already familiar with the __init__() dunder method name, but Python has several more. We often use them for operator overloading — that is, adding custom behaviors that allow us to use objects of our classes with Python operators, such as + or &gt;=. Other dunder methods let objects of our classes work with Python’s built-in functions, such as len(). These methods are documented online in the official Python documentation at here.\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __eq__(self, other):\n        return (self.x == other.x) and (self.y == other.y)\n\n\np1 = Point(1, 2)\np2 = Point(3, 4)\np3 = p1 + p2\np4 = Point(4, 6)\nprint(p3.x, p3.y)  # Output: 4 6\nprint(p3 == p4)\n\n4 6\nTrue\n\n\nIn this example, we define the __add__ and __eq__ method in the Point class to implement the addition and equality of two Point objects. When we use the + and = operators with two Point objects, the __add__ and __eq__methods are called automatically to perform the addition and comparison.\nFor more information about overloading, see here.\n\n8.7.2 Exercise 2: Inherit from Pokemon class to create new classes, firePokemon and waterPokemon, that accept the same parameters when constructed. Add a new method attack() for the two derived classes that recieve a single parameter attack_type and print out the message like this:\n\nMagmortar is attacking with flamethrower\nIn addition, define a function PokemonAttack(), which receives a Pokemon object and an attack_type, then call the method attack(). Complete the following class/function and execute the code cell.\n\n\n\n\nsource: https://www.wallpaperflare.com/search?wallpaper=Fire+Pokemon\n\n\n### If you are not using anaconda, you need to install the following package:\n#%pip install requests\n\n\nclass Pokemon:\n    def __init__(self, name, type, total_specis):\n        self.name = name\n        self.type = type\n        self.total_specis = total_specis\n        \n    def __str__(self):\n        return f\"{self.name} ({self.type}, total specis {self.total_specis})\"\n    \nclass firePokemon(Pokemon):\n    # Your code here\n    def __init__(self, name, type, total_specis):\n        self.name = name\n        self.type = type\n        self.total_specis = total_specis\n    # Your code here\n    def attack(self, attack_type):\n        print(f\"{self.name} is attacking with {attack_type}\")\n    \nclass waterPokemon(Pokemon):\n    # Your code here\n    def __init__(self, name, type, total_specis):\n        super().__init__(name, type, total_specis)\n    # Your code here\n    def attack(self, attack_type):\n        print(f\"{self.name} is attacking with {attack_type}\")\n    \ndef PokemonAttack(pokemon, attack_type):\n    # Your code here\n    pokemon.attack(attack_type)\n\n\nimport random\nimport json \nimport time\nimport requests\n\ndef slow_print(text, delay=0.05):\n    for char in text:\n        print(char, end='', flush=True)\n        time.sleep(delay)\n    print()\n\n## 1. Download the data\nurl = 'https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json'\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    with open('pokedex.json', 'w', encoding = \"utf-8\") as f:\n        f.write(response.text)\nelse:\n    print(f\"Failed to download the file. Status code: {response.status_code}\")\n\nwith open('Pokedex.json', 'r', encoding = \"utf-8\") as file:\n    pokemon_data = json.load(file)\n\n\n## 2. Get the pokemon\nrandom.shuffle(pokemon_data)\ngetpokemon = []\ni = 0\nwhile True:\n    if len(getpokemon) == 6:\n        break\n    if pokemon_data[i]['type'][0] != \"Fire\" and pokemon_data[i]['type'][0] != \"Water\":\n        i += 1\n        continue\n    else:\n        if pokemon_data[i]['type'][0] == \"Fire\":\n            pokemon = firePokemon(pokemon_data[i]['name']['english'], pokemon_data[i]['type'][0], sum([pokemon_data[i]['base'][key] for key in pokemon_data[i]['base'] if key != \"name\"]))\n        else:\n            pokemon = waterPokemon(pokemon_data[i]['name']['english'], pokemon_data[i]['type'][0], sum([pokemon_data[i]['base'][key] for key in pokemon_data[i]['base'] if key != \"name\"]))\n        getpokemon.append(pokemon)\n        i += 1\n\n# 3. Print the pokemon and attack!\nfor i in range(6):\n    if getpokemon[i].type == \"Fire\":\n        attack = 'flamethrower'\n    else:\n        attack = 'hydro pump'\n    PokemonAttack(getpokemon[i], attack)\n\nCloyster is attacking with hydro pump\nTentacruel is attacking with hydro pump\nTorracat is attacking with flamethrower\nLotad is attacking with hydro pump\nGastrodon is attacking with hydro pump\nFinneon is attacking with hydro pump"
  },
  {
    "objectID": "08_09_OOP.html#data-class",
    "href": "08_09_OOP.html#data-class",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.8 Data Class",
    "text": "8.8 Data Class\nData classes are among Python 3.7’s most important new features. They help you build classes faster by using more concise notation and by autogenerating “boilerplate” code that’s common in most classes. For instance:\n\nA data class autogenerates __init__, __repr__ and __eq__, saving you time.\nA data class can autogenerate the special methods that overload the &lt;, &lt;=, &gt; and &gt;= comparison operators.\nWhen you change data attributes defined in a data class, then use it in a script or interactive session, the autogenerated code updates automatically. So, you have less code to maintain and debug.\nSome static code analysis tools and IDEs can inspect variable annotations and issue warnings if your code uses the wrong type. This can help you locate logic errors in your code before you execute it.\n\nCheck out here for more details."
  },
  {
    "objectID": "08_09_OOP.html#summary",
    "href": "08_09_OOP.html#summary",
    "title": "8  Object Oriented Programming and Classes",
    "section": "8.9 Summary",
    "text": "8.9 Summary\nObject-oriented programming is a programming paradigm that provides a means of structuring programs so that attributes and behaviors are bundled into individual objects. The discussion of OOP is centered around inheritance, encapsulation and Polymorphism:\n\nInheritance promotes code reusability and organization by allowing derived classes to inherit attributes and methods from parent classes.\nEncapsulation improves maintainability and security by bundling data and methods within objects and controlling access to their internal state.\nPolymorphism enhances flexibility and extensibility by enabling a single interface to represent different types, allowing for interchangeable objects and easier code modification.\n\nHowever, Python implements object-oriented features slightly differently than other OOP languages, such as Java or C++. For example, Python lets you overload its operators via its dunder methods, which begin and end with double underscore characters. These methods provide a way for Python’s built-in operators to work with objects of the classes you create."
  },
  {
    "objectID": "10_11_NumPy.html#introduction",
    "href": "10_11_NumPy.html#introduction",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.1 Introduction",
    "text": "9.1 Introduction\nThe NumPy (Numerical Python) library first appeared in 2006 and is the preferred Python array implementation. It offers a high-performance, richly functional n-dimensional array type called array. Operations on arrays are up to one or two orders of magnitude faster than those on lists.\nIn this chapter, we explore the array’s basic capabilities. The built-in lists can have multiple dimensions, and you generally process multi-dimensional lists with nested loops or list comprehensions with multiple clauses. A strength of NumPy is “array-oriented programming,” which uses functional-style programming with internal iteration to make array manipulations concise and straightforward, eliminating the kinds of bugs that can occur with explicitly programmed loops.\nIn Python the types are dynamically inferred and we do not have to allocate the memory by ourselves. This type of flexibility also points to the fact that Python variables are more than just their values; they also contain extra information about the type and the size of the value:\n\n\n\n\nsource: https://jakevdp.github.io/PythonDataScienceHandbook/figures/cint_vs_pyint.png\n\nSimilarly, the list in Python is very flexible that can store heterogeneous objects. But this flexibility comes at a cost: to allow these flexible types, each item in the list must contain its type, size, and other information. Every element is a complete Python object. In the special case that all variables are of the same type, much of this information is redundant, so storing the data in a fixed-type array can be much more efficient. The difference between a dynamic-type list and a fixed-type (NumPy-style) array is illustrated:\n\n\n\n\nsource: https://jakevdp.github.io/PythonDataScienceHandbook/figures/array_vs_list.png\n\nAt the implementation level, the array essentially contains a single pointer to one contiguous block of data. The Python list, on the other hand, includes a pointer to a block of pointers, each of which in turn points to a whole Python object like the Python integer we saw earlier.\n\nThe advantage of the list is flexibility: because each list element is a full structure containing both data and type information, the list can be filled with data of any desired type. Fixed-type NumPy-style arrays lack this flexibility but are much more efficient for storing and manipulating data.\n\nFrom the previous lecture, we know that every object consists of data and methods. The ndarray object of the NumPy package not only provides efficient storage of array-based data but adds to this efficient operations on that data."
  },
  {
    "objectID": "10_11_NumPy.html#creating-array-from-existing-data-constructor",
    "href": "10_11_NumPy.html#creating-array-from-existing-data-constructor",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.2 Creating array from Existing Data (Constructor)",
    "text": "9.2 Creating array from Existing Data (Constructor)\n\npackage_name = \"numpy\"\n\ntry:\n    __import__(package_name)\n    print(f\"{package_name} is already installed.\")\nexcept ImportError:\n    print(f\"{package_name} not found. Installing...\")\n    %pip install {package_name}\n\nnumpy is already installed.\n\n\nThe NumPy documentation recommends importing the numpy module as np so that you can access its members with “np.”\n\nimport numpy as np\n\n\n9.2.1 Creating array using from fix sequence\nThe numpy module provides various functions for creating arrays. Here we use the array() function, which receives a collection of elements and returns a new array containing the argument’s elements. Let’s pass a list for example:\n\nnumbers = np.array([2, 3, 5, 7, 11])\nnumbers, type(numbers)\n\n(array([ 2,  3,  5,  7, 11]), numpy.ndarray)\n\n\nThe array() function copies its argument’s contents into the array. Note that the type is numpy.ndarray, but all arrays are output as “array.”\n\n\n9.2.2 Multidimensional Arguments\nThe array() function copies its argument’s dimensions. Let’s create an array from a two-row-by-three-column list:\n\nnp.array([[1, 2, 3], [4, 5, 6]]), type(np.array([[1, 2, 3], [4, 5, 6]]))\n\n(array([[1, 2, 3],\n        [4, 5, 6]]),\n numpy.ndarray)\n\n\n\n9.2.2.1 array Attributes\nThe array function determines an array’s element type from its argument’s elements. You can check the element type with an array’s dtype attribute:\n\nintegers = np.array([[1, 2, 3], [4, 5, 6]])\nfloats = np.array([0.0, 0.1, 0.2, 0.3, 0.4])\n\nintegers.dtype, floats.dtype\n\n(dtype('int32'), dtype('float64'))\n\n\nAs you’ll see in the next section, various array-creation functions receive a dtype keyword argument so you can specify an array’s element type.\nFor performance reasons, NumPy is written in the C programming language and uses C’s data types. By default, NumPy stores integers as the NumPy type int_ values — which correspond to 32-bit (4-byte) integers in C (this may be platform-dependent) — and stores floating-point numbers as the NumPy type float64 values — which correspond to 64-bit (8-byte) floating-point values (double) in C. In our examples, most commonly, you’ll see the types int32, float64 and bool for non-numeric data (such as strings). The complete list of supported types is at https://docs.scipy.org/doc/numpy/user/basics.types.html.\nThe attribute ndim contains an array’s number of dimensions and the attribute shape contains a tuple specifying an array’s dimensions:\n\nprint(integers.ndim)\nprint(floats.ndim)\n\n2\n1\n\n\n\nprint(integers.shape)\nprint(floats.shape)\n\n(2, 3)\n(5,)\n\n\nHere, integers have 2 rows and 3 columns (6 elements) and floats are one-dimensional, containing 5 floating numbers.\nYou can view an array’s total number of elements with the attribute size and the number of bytes required to store each element with itemsize:\n\nprint(integers.size)\nprint(integers.itemsize)\nprint(floats.size)\nprint(floats.itemsize)\n\n6\n4\n5\n8\n\n\nNote that the integers’ size is the product of the shape tuple’s values — two rows of three elements each for a total of six elements. In each case, itemsize is 4 because integers contain int32 values and 8 since floats contain float64 values.\n\n\n\n9.2.3 Filling array with Specific Values\nNumPy provides functions zeros(), ones() and full() for creating arrays containing 0s, 1s or a specified value, respectively. By default, zeros() and ones() create arrays containing float64 values. We’ll show how to customize the element type momentarily. The first argument to these functions must be an integer or a tuple of integers specifying the desired dimensions. For an integer, each function returns a one-dimensional array with the specified number of elements:\n\nnp.zeros(5)\n\narray([0., 0., 0., 0., 0.])\n\n\nFor a tuple of integers, these functions return a multidimensional array with the specified dimensions. You can specify the array’s element type with the zeros() and ones() function’s dtype keyword argument:\n\nnp.ones((2, 4), dtype=np.int64)\n\narray([[1, 1, 1, 1],\n       [1, 1, 1, 1]], dtype=int64)\n\n\nThe array returned by full() contains elements with the second argument’s value and type:\n\nnp.full((3, 5), 13)\n\narray([[13, 13, 13, 13, 13],\n       [13, 13, 13, 13, 13],\n       [13, 13, 13, 13, 13]])\n\n\n\n\n9.2.4 Creating array from sequence generated by different methods\n\n9.2.4.1 Creating sequence with fix step by arange()\nLet’s use NumPy’s arange function to create integer ranges — similar to using the built-in function range. In each case, arange first determines the resulting array’s number of elements, allocates the memory, then stores the specified range of values in the array:\n\nnp.arange(5)\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(5, 10)\n\narray([5, 6, 7, 8, 9])\n\n\n\nnp.arange(10, 1, -2) \n\narray([10,  8,  6,  4,  2])\n\n\n\nIt is the same as range() which takes three arguments numpy.arange(start, stop, step)\n\n\n\n9.2.4.2 Creating sequence with fix sample number by linspace()\nYou can produce evenly spaced floating-point ranges with NumPy’s linspace() function. The function’s first two arguments specify the starting and ending values in the range, and the ending value is included in the array. The optional keyword argument num specifies the number of evenly spaced values to produce:\n\nnp.linspace(0.0, 1.0, num=5)\n\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n\n\n\n\n9.2.4.3 Reshaping an array\nYou also can create an array from a range of elements, then use the array method reshape() to transform the one-dimensional array into a multidimensional array. Let’s create an array containing the values from 1 through 20, then reshape it into four rows by five columns:\n\nnp.arange(1, 21).reshape(4, 5)\n\narray([[ 1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10],\n       [11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20]])\n\n\nNote the chained method calls in the preceding snippet. First, arange produces an array containing the values 1–20. Then we call reshape() on that array to get the 4-by-5 array that was displayed. You can reshape() any array, provided that the new shape has the same number of elements as the original. So a six-element one-dimensional array can become a 3-by-2 or 2-by-3 array, and vice versa!\n\n\n\n9.2.5 List vs. array Performance: Introducing %timeit\nMost array operations execute significantly faster than corresponding list operations. To demonstrate, we’ll use the %timeit magic command, which times the average duration of operations.\n\nimport random\n\nHere, let’s use the random module’s randint() function with a list comprehension to create a list of six million die rolls and time the operation using %timeit:\n\n%timeit rolls_list = [random.randint(1, 6) for i in range(0, 6_000_000)] #_ is use to separate long integer\n\n3.67 s ± 15.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\nBy default, %timeit executes a statement in a loop, and it runs the loop seven times. If you do not indicate the number of loops, %timeit chooses an appropriate value.\n\nNow, let’s use the randint() function from the numpy.random module to create an array\n\n%timeit rolls_array = np.random.randint(1, 7, 6_000_000)\n\n42 ms ± 805 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)"
  },
  {
    "objectID": "10_11_NumPy.html#indexing-and-slicing-getter-and-setter",
    "href": "10_11_NumPy.html#indexing-and-slicing-getter-and-setter",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.3 Indexing and Slicing (Getter and Setter)",
    "text": "9.3 Indexing and Slicing (Getter and Setter)\nOne-dimensional arrays can be indexed and sliced using the same syntax and techniques demonstrated in the “Lists and Tuples” chapter. Here, we focus on array-specific indexing and slicing capabilities.\nTo select an element in a two-dimensional array, specify a tuple containing the element’s row and column indices in square brackets:\n\ngrades = np.array([[87, 96, 70], [100, 87, 90],\n                   [94, 77, 90], [100, 81, 82]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\n\ngrades[0, 1]  # row 0, column 1\n\n96\n\n\nTo select a single row, specify only one index in square brackets:\n\ngrades[1]\n\narray([100,  87,  90])\n\n\nTo select multiple sequential rows, use slice notation:\n\ngrades[0:2]\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nTo select multiple non-sequential rows, use a list of row indices (fancy indexing):\n\ngrades[[1, 3]]\n\narray([[100,  87,  90],\n       [100,  81,  82]])\n\n\nLet’s select only the elements in the first column:\n\ngrades[:, 0]\n\narray([ 87, 100,  94, 100])\n\n\nThe 0 after the comma indicates that we’re selecting only column 0. The : before the comma indicates which rows within that column to select. In this case, : is a slice representing all rows. You can select consecutive columns using a slice:\n\ngrades[:, 1:3]\n\narray([[96, 70],\n       [87, 90],\n       [77, 90],\n       [81, 82]])\n\n\nor specific columns using a list of column indices:\n\ngrades[:, [0, 2]]\n\narray([[ 87,  70],\n       [100,  90],\n       [ 94,  90],\n       [100,  82]])\n\n\narray is mutable. Therefore, if we want to modify the value of the array, we can use the previous method and put the result on the left-hand side:\n\ngrades[3, 2] = 42\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  42]])\n\n\n\n9.3.1 Views: Shallow Copies\nViews are objects “see” the data in other objects, rather than having their own copies of the data. Views are also known as shallow copies. Various array methods and slicing operations produce views of an array’s data. The array method view() returns a new array object with a view of the original array object’s data. First, let’s create an array and a view of that array:\n\nnumbers = np.arange(1, 6)\nnumbers2 = numbers.view()\n\nWe can use the built-in id() function to see that numbers and numbers2 are different objects:\n\nid(numbers), id(numbers2)\n\n(1664107572080, 1664073164144)\n\n\n\nnp.shares_memory(numbers, numbers2)\n\nTrue\n\n\nTo prove that numbers2 views the same data as numbers, let’s modify an element in numbers, then display both arrays:\n\nnumbers[1] *= 10\nnumbers\n\narray([ 1, 20,  3,  4,  5])\n\n\n\nnumbers2\n\narray([ 1, 20,  3,  4,  5])\n\n\nSimilarly, changing a value in the view also changes that value in the original array:\n\nnumbers2[1] /= 5\nnumbers, numbers2\n\n(array([1, 4, 3, 4, 5]), array([1, 4, 3, 4, 5]))\n\n\nSlices also create views. Let’s make numbers2 a slice that views only the first three elements of numbers:\n\nnumbers2 = numbers[0:3]\nnumbers2\n\narray([1, 4, 3])\n\n\nAgain, we can confirm that numbers and numbers2 are different objects with id():\n\nid(numbers), id(numbers2), np.shares_memory(numbers, numbers2)\n\n(1664107572080, 1664107667152, True)\n\n\nNow, let’s modify an element both arrays share, then display them. Again, we see that numbers2 is a view of numbers:\n\nnumbers[1] *= 20\nnumbers\n\narray([ 1, 80,  3,  4,  5])\n\n\n\nnumbers2\n\narray([ 1, 80,  3])\n\n\n\nNote that this behavior is different from list, where the slicing will create a new sub list!\n\n\n\n9.3.2 Deep Copies\nThough views are separate array objects, they save memory by sharing element data from other arrays. However, when sharing mutable values, sometimes creating a deep copy with independent copies of the original data is necessary. This is especially important in multi-core programming, where separate parts of your program could attempt to modify your data at the same time, possibly corrupting it.\nThe array method copy() returns a new array object with a deep copy of the original array object’s data. First, let’s create an array and a deep copy of that array:\n\nnumbers = np.arange(1, 6)\nnumbers2 = numbers.copy()\n\n\nid(numbers), id(numbers2), np.shares_memory(numbers, numbers2)\n\n(1664107664944, 1664107665712, False)\n\n\nTo prove that numbers2 has a separate copy of the data in numbers, let’s modify an element in numbers, then display both arrays:\n\nnumbers[1] *= 10\nnumbers\n\narray([ 1, 20,  3,  4,  5])\n\n\n\nnumbers2\n\narray([1, 2, 3, 4, 5])\n\n\n\nRecall that if you need deep copies of other types of Python objects, pass them to the copy module’s deepcopy() function.\n\n\n\n9.3.3 More about Reshaping and Transposing\nWe’ve used array method reshape() to produce two-dimensional arrays from one-dimensional array. NumPy provides various other ways to reshape arrays.\nThe array methods reshape() and resize() both enable you to change an array’s dimensions. Method reshape() returns a view (shallow copy) of the original array with the new dimensions. It does not modify the original array:\n\ngrades = np.array([[87, 96, 70], [100, 87, 90]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\n\ngrades2 = grades.reshape(1, 6)\n\n\ngrades2[0, 0] = 0\ngrades2, grades\n\n(array([[  0,  96,  70, 100,  87,  90]]),\n array([[  0,  96,  70],\n        [100,  87,  90]]))\n\n\nA common trick is that you can use -1 to specify the shape in resahpe(). The length of the dimension set to -1 is automatically determined by inferring from the specified values of other dimensions:\n\ngrades.reshape(-1, 2) # Same as grades.reshape(3, 2)\n\narray([[  0,  96],\n       [ 70, 100],\n       [ 87,  90]])\n\n\nMethod resize() modifies the original array’s shape in-place. It does not return a value:\n\ngrades.resize(1, 6)\ngrades\n\narray([[  0,  96,  70, 100,  87,  90]])\n\n\nWe can also do the opposite operation, which takes a multidimensional array and flatten it into a single dimension with the methods flatten() and ravel(). Method flatten() deep copies the original array’s data:\n\ngrades = np.array([[87, 96, 70], [100, 87, 90]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\n\nflattened = grades.flatten()\nflattened\n\narray([ 87,  96,  70, 100,  87,  90])\n\n\n\nflattened[0] = 100\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90]])\n\n\nMethod ravel() produces a view of the original array, which shares the grades array’s data!\n\nraveled = grades.ravel()\nraveled\n\narray([ 87,  96,  70, 100,  87,  90])\n\n\n\nraveled[0] = 100\ngrades\n\narray([[100,  96,  70],\n       [100,  87,  90]])\n\n\nAdditionally, we can effortlessly transpose an array‘s rows and columns, causing the rows to turn into columns and the columns into rows. The T attribute returns a transposed view (shallow copy) of the array. Assume that the original grades array presents two students’ grades (the rows) across three exams (the columns). Let’s transpose the rows and columns to examine the data as the grades for three exams (the rows) taken by two students (the columns):\n\ntranspose = grades.T\ntranspose\n\narray([[100, 100],\n       [ 96,  87],\n       [ 70,  90]])\n\n\nTransposing does not modify the original array but it does create a view of the original array’s data:\n\ntranspose[0, 0] = 0\ngrades\n\narray([[  0,  96,  70],\n       [100,  87,  90]])\n\n\nYou can combine arrays by adding more columns or more rows — known as horizontal stacking and vertical stacking. Let’s create another 2-by-3 array of grades:\n\ngrades2 = np.array([[94, 77, 90], [100, 81, 82]])\ngrades2\n\narray([[ 94,  77,  90],\n       [100,  81,  82]])\n\n\nLet’s assume grades2 represents three additional exam grades for the two students in the grades array. We can combine grades and grades2 with NumPy’s hstack() (horizontal stack) function by passing a tuple containing the arrays to combine. The extra parentheses are required because hstack() expects one argument:\n\nnp.hstack((grades, grades2))\n\narray([[  0,  96,  70,  94,  77,  90],\n       [100,  87,  90, 100,  81,  82]])\n\n\nNext, let’s assume that grades2 represents two more students’ grades on three exams. In this case, we can combine grades and grades2 with NumPy’s vstack() (vertical stack) function:\n\nnp.vstack((grades, grades2))\n\narray([[  0,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\n\n9.3.4 Exercise 1: Suppose we are developing a chess game and the chess game provide two special checkerboards as follows:\n\n\n\n\n\n\n\nWe decide to use 1 to represent the white square and 0 to represent the black square. Write a program to create two 2D arrays to represent the two checkerboards as follows:\n[[1, 0, 1, 0, 1, 0],\n [0, 1, 0, 1, 0, 1],\n [1, 0, 1, 0, 1, 0],\n [0, 1, 0, 1, 0, 1],\n [1, 0, 1, 0, 1, 0],\n [0, 1, 0, 1, 0, 1]]\n[[1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1],\n [0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\n [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1]]\nNote you should not directly hardcode the above arrays. You should use Numpy methods to create the arrays. After you have finished the exercise, you can print out the checkerboard using the following code cell.\n\n# Your answer here\ncheckerboard\n\narray([[1., 0., 1., 0., 1., 0.],\n       [0., 1., 0., 1., 0., 1.],\n       [1., 0., 1., 0., 1., 0.],\n       [0., 1., 0., 1., 0., 1.],\n       [1., 0., 1., 0., 1., 0.],\n       [0., 1., 0., 1., 0., 1.]])\n\n\n\n# Your answer here\ncheckerboard2\n\narray([[1., 0., 1., 0., 1., 0., 0., 1., 0., 1., 0., 1.],\n       [0., 1., 0., 1., 0., 1., 1., 0., 1., 0., 1., 0.],\n       [1., 0., 1., 0., 1., 0., 0., 1., 0., 1., 0., 1.]])\n\n\n\n# Plot the checkerboard\npackage_name = \"matplotlib\"\n\ntry:\n    __import__(package_name)\n    print(f\"{package_name} is already installed.\")\nexcept ImportError:\n    print(f\"{package_name} not found. Installing...\")\n    %pip install {package_name}\n\nimport matplotlib.pyplot as plt\nplt.imshow(checkerboard, cmap='gray')\nplt.show()\nplt.imshow(checkerboard2, cmap='gray');\n\nmatplotlib is already installed."
  },
  {
    "objectID": "10_11_NumPy.html#numpy-calculation-methods-reduction",
    "href": "10_11_NumPy.html#numpy-calculation-methods-reduction",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.4 NumPy calculation methods (Reduction)",
    "text": "9.4 NumPy calculation methods (Reduction)\nAn array includes several methods that carry out computations based on its contents. By default, these methods disregard the array’s shape and utilize all the elements in the calculations. For instance, when computing the mean of an array, it sums all of its elements irrespective of its shape, and then divides by the total number of elements. We can also execute these calculations on each dimension. For example, in a two-dimensional array, we can determine the mean of each row and each column.\n\ngrades = np.array([[87, 96, 70], [100, 87, 90],\n                   [94, 77, 90], [100, 81, 82]])\ngrades\n\narray([[ 87,  96,  70],\n       [100,  87,  90],\n       [ 94,  77,  90],\n       [100,  81,  82]])\n\n\nWe can use methods to calculate sum(), min(), max(), mean(), std() (standard deviation) and var() (variance) — each is a functional-style programming reduction:\n\nprint(grades.sum())\nprint(grades.min())\nprint(grades.max())\nprint(grades.mean())\nprint(grades.std())\nprint(grades.var())\n\n1054\n70\n100\n87.83333333333333\n8.792357792739987\n77.30555555555556\n\n\n\n9.4.1 Calculations by Row or Column\nNumerous calculation methods can be applied to specific array dimensions, referred to as the array’s axes. These methods accept an axis keyword argument that designates the dimension to be utilized in the calculation, providing a convenient means to perform computations by row or column in a two-dimensional array.\nSuppose we want to find the maximum grade for each exam, represented by the columns of grades. By specifying axis=0, the calculation is performed on all the row values within each column:\n\ngrades, grades.max(axis=0), grades.argmax(axis=0)\n\n(array([[ 87,  96,  70],\n        [100,  87,  90],\n        [ 94,  77,  90],\n        [100,  81,  82]]),\n array([100,  96,  90]),\n array([1, 0, 1], dtype=int64))\n\n\nHere, 100 is the maximum value in the first column and its corresponding index (row) is 1 (if there are duplicate elements, the index of the first element will be reported). 96 and 90 are the maximum values in the second and third columns, respectively.\n\ngrades, grades.mean(axis=0)\n\n(array([[ 87,  96,  70],\n        [100,  87,  90],\n        [ 94,  77,  90],\n        [100,  81,  82]]),\n array([95.25, 85.25, 83.  ]))\n\n\nHence, 95.25 above represents the average of the first column’s grades (87, 100, 94, and 100), 85.25 is the average of the second column’s grades (96, 87, 77, and 81), and 83 is the average of the third column’s grades (70, 90, 90, and 82). Similarly, specifying axis=1 performs the calculation on all the column values within each individual row. To determine each student’s average grade for all exams, we can use:\n\n\n\n\ngrades, grades.mean(axis=1)\n\n(array([[ 87,  96,  70],\n        [100,  87,  90],\n        [ 94,  77,  90],\n        [100,  81,  82]]),\n array([84.33333333, 92.33333333, 87.        , 87.66666667]))\n\n\nThis generates four averages — one for the values in each row. Therefore, 84.33333333 is the average of row 0’s grades (87, 96, and 70), and the other averages correspond to the remaining rows. For more methods, refer to https://numpy.org/doc/stable/reference/arrays.ndarray.html.\n\nFor more operations such as methods related to linear algebra, we can use the sub-module numpy.linalg, which implements basic linear algebra, such as solving linear systems, singular value decomposition, etc. However, it is not guaranteed to be compiled using efficient routines, and thus we recommend the use of scipy.linalg, which will introduce in a later chapter."
  },
  {
    "objectID": "10_11_NumPy.html#array-operators",
    "href": "10_11_NumPy.html#array-operators",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.5 array Operators",
    "text": "9.5 array Operators\n\n9.5.1 The slowness of loops\nThe speed of computations on NumPy arrays can range from very fast to very slow. To optimize performance, the recommended approach is to use vectorized operations, which are typically implemented through NumPy’s universal functions (ufuncs). In scenarios that involve executing numerous small operations repeatedly, the inherent sluggishness of Python often becomes apparent. One such instance is when we loop over arrays to perform operations on each element. For example, suppose we have an array of values and need to compute the reciprocal of each value. A straightforward approach might involve:\n\ndef compute_reciprocals(values):\n    output = np.empty(len(values))\n    for i in range(len(values)):\n        output[i] = 1.0 / values[i]\n    return output\n\nvalues = np.random.randint(1, 10, 5)\ncompute_reciprocals(values)\n\narray([0.11111111, 0.25      , 0.16666667, 0.14285714, 0.5       ])\n\n\nBut if we measure the execution time of this code for a large input, we see that this operation is very slow:\n\nbig_array = np.random.randint(1, 10, 1_000_000)\n\n\n%%timeit \ncompute_reciprocals(big_array)\n\n1.33 s ± 3.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\nInterestingly, the bottleneck in this situation isn’t the operations themselves, but rather the type checking and function dispatches that Python needs to execute during each iteration of the loop. Whenever the reciprocal is calculated, Python initially verifies the type of the object and performs a dynamic lookup to determine the correct function to employ for that type. If we were using compiled code, this kind of specification would be predetermined before the code execution, resulting in much more efficient computations.\n\nIn NumPy, vectorization is the process of performing operations on entire arrays of data, as opposed to individual elements. This is accomplished by applying an operation to the entire array, instead of looping through each element of the array one at a time.\n\n1.0 / values # The vectorized version of the above code\n\narray([0.11111111, 0.25      , 0.16666667, 0.14285714, 0.5       ])\n\n\nThe above syntax is the vectorized version of the original code and works due to the broadcasting. Looking at the execution time for our big array, we see that it completes orders of magnitude faster than the Python loop:\n\n%%timeit \n(1.0 / big_array)\n\n2.04 ms ± 19.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\nThe execution time is much faster since the vectorization operation is done via ufuncs, which is a compiled routine. Now we will introduce each concept in detail, including broadcasting, ufuncs and vectorization.\n\n9.5.1.1 Element-wise arithmetic\nNumPy offers numerous operators that allow us to create simple expressions that carry out operations on whole arrays and returns another array. Firstly, let’s perform element-wise arithmetic with arrays and numeric values by employing arithmetic operators and augmented assignments. Element-wise operations are applied to each element, so the snippet below doubles every element and cubes every element. Each operation returns a new array containing the result:\n\nnumbers = np.arange(1, 7) # array([1, 2, 3, 4, 5, 6])\nnumbers * 2\n\narray([ 2,  4,  6,  8, 10, 12])\n\n\n\nnumbers ** 3\n\narray([  1,   8,  27,  64, 125, 216], dtype=int32)\n\n\nAugmented assignments modify every element in the left operand in place!\n\nnumbers += 10\nnumbers\n\narray([11, 12, 13, 14, 15, 16])\n\n\n\n\n\n9.5.2 Broadcasting\nTypically, arithmetic operations necessitate two arrays of identical size and shape as operands. When one operand is a single value, known as a scalar, NumPy carries out the element-wise calculations as though the scalar were an array of the same shape as the other operand, but with the scalar value present in all its elements. This is referred to as broadcasting. The snippets above demonstrate this capability. For instance, numbers * 2 is equivalent to numbers * [2, 2, 2, 2, 2, 2].\nBroadcasting can also be applied between arrays of varying sizes and shapes, enabling concise and powerful manipulations. We will present more examples of broadcasting later in this chapter when we introduce NumPy’s universal functions.\n\n9.5.2.1 Arithmetic Operations Between arrays\nArithmetic operations and augmented assignments can be performed between arrays of the same shape. Let’s multiply the one-dimensional arrays numbers and numbers2 (created below), each containing five elements:\n\nnumbers2 = np.linspace(1.1, 6.6, 6) \nnumbers * numbers2 # array([11, 12, 13, 14, 15, 16]) * array([ 1.1,  2.2,  3.3,  4.4,  5.5, 6.6])\n\narray([ 12.1,  26.4,  42.9,  61.6,  82.5, 105.6])\n\n\nThe outcome is a new array created by multiplying the elements of each operand element-wise — 11 * 1.1, 12 * 2.2, 13 * 3.3, and so on. Arithmetic operations between arrays of integers and floating-point numbers result in an array of floating-point numbers. Let’s see another example:\n\nc = np.ones((3, 3))\nc * c \n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\nNote that the above operation is not matrix multiplication. To perform matrix multiplication use the dot() method!\n\nc.dot(c)\n\narray([[3., 3., 3.],\n       [3., 3., 3.],\n       [3., 3., 3.]])\n\n\nThe above operation is the same as using the @ operator:\n\nc @ c\n\narray([[3., 3., 3.],\n       [3., 3., 3.],\n       [3., 3., 3.]])\n\n\nWe can apply broadcasting to higher-dimensional arrays in a similar way. For instance, consider adding a one-dimensional array to a two-dimensional array and observe the resulting output:\n\na = np.array([0, 1, 2])\nM = np.ones((3, 3))\nprint(a.shape, M.shape)\nM + a\n\n(3,) (3, 3)\n\n\narray([[1., 2., 3.],\n       [1., 2., 3.],\n       [1., 2., 3.]])\n\n\nHere, the one-dimensional array a is stretched, or broadcasted, across the second dimension in order to match the shape of M.\n\n\n9.5.2.2 Rules of Broadcasting\nIn NumPy, broadcasting adheres to a strict set of regulations that govern how two arrays interact with one another. These rules are as follows:\n\nWhen the number of dimensions between two arrays differs, the array with fewer dimensions is padded with ones on its leading (left) side to match the number of dimensions of the other array.\nIf the shape of the two arrays doesn’t match in any dimension, the array with a shape of 1 in that dimension is expanded to match the shape of the other array.\nIf the sizes of the arrays conflict in any dimension and neither is equal to 1, an error is raised.\n\nNow let’s take a look at an example where both arrays need to be broadcast:\n\na = np.arange(0, 40, 10).reshape(4,1)\nb = np.arange(3)\nprint(a.shape, b.shape)\na, b\n\n(4, 1) (3,)\n\n\n(array([[ 0],\n        [10],\n        [20],\n        [30]]),\n array([0, 1, 2]))\n\n\n\na + b\n\narray([[ 0,  1,  2],\n       [10, 11, 12],\n       [20, 21, 22],\n       [30, 31, 32]])\n\n\n\nTo begin, we need to determine the shapes of the two arrays: a.shape is (4,1) and b.shape is (3,). According to Rule 1, we have to add ones to the shape of b such that its dimensions match those of a. Thus, b.shape becomes (1,3).\nNext, Rule 2 states that we need to expand each of the 1s in b.shape to match the corresponding size of the other array. Consequently, a.shape becomes (4,3), and b.shape becomes (4,3) since 1 was replicated three times to match the size of a.\nSince the shapes of the two arrays now match, they are compatible.\n\nThis entire process can be depicted visually as follows:\n\n\n\nNext, let’s look at an example in which the two arrays are incompatible!\n\nM = np.ones((3, 2))\na = np.arange(3)\n\nM.shape, a.shape\n\n((3, 2), (3,))\n\n\n\nFirst, we need to determine the shapes of the two arrays: M.shape is (3,2), and a.shape is (3,). As per Rule 1, we must pad ones to the shape of a such that its number of dimensions matches that of M. Consequently, a.shape becomes (1, 3), while M.shape remains the same.\nNext, Rule 2 requires that we stretch the first dimension of a to match that of M. Therefore, a.shape becomes (3,3), while M.shape stays the same.\nHowever, Rule 3 comes into play, here since the final shapes of the two arrays do not match. As a result, these two arrays are incompatible.\n\nThis incompatibility is evident when we attempt to perform this operation.\n\nM + a\n\nValueError: operands could not be broadcast together with shapes (3,2) (3,) \n\n\n\n\n9.5.2.3 Comparing arrays\nBoth individual values and other arrays can be compared in NumPy. The comparisons are carried out element-wise, producing arrays of Boolean values where the value of each element represents the outcome of the comparison, either True or False:\n\nnumbers &gt;= 13 # numbers = array([11, 12, 13, 14, 15, 16])\n\narray([False, False,  True,  True,  True,  True])\n\n\nNote that the above expression implicitly used broadcasting!\n\nnumbers2 &lt; numbers # numbers2 = array([ 1.1,  2.2,  3.3,  4.4,  5.5, 6.6])\n\narray([ True,  True,  True,  True,  True,  True])\n\n\n\nnumbers == numbers2\n\narray([False, False, False, False, False, False])\n\n\n\nnumbers == numbers\n\narray([ True,  True,  True,  True,  True,  True])\n\n\n\n\n\n9.5.3 Universal Functions (Vectorization)\nNow we will delve into how NumPy perform element-wise operations on arrays without using the for loop: NumPy provides more operators/functions as standalone universal functions (also known as ufuncs) that perform various operations element-wise, meaning that they apply the same operation to each element in an array. These functions operate on one or two array-like arguments (such as lists) and are utilized to perform tasks. Some of these functions are automatically invoked when operators like + and * are used with arrays. Each ufunc generates a new array that contains the results of the operation.\nNumPy offers a practical interface for various kinds of operations that directly access statically typed and compiled routines. These operations are called vectorized operations. Vectorization is achieved using array operations, such as addition, subtraction, multiplication, and division. In addition, it can also be achieved by using ufunc. These vectorized methods are intended to move the loop to the compiled layer that underpins NumPy, leading to considerably quicker execution.\nWe can view the complete list, their descriptions and more information about universal functions at https://numpy.org/doc/stable/reference/ufuncs.html\n\nSee here for more vectorization examples in different thinking levels.\n\n\n9.5.3.1 Exploring NumPy’s Ufuncs\nLet’s add two arrays with the same shape, using the add() universal function:\n\nnumbers2 = np.arange(1, 7) * 10  # array([10, 20, 30, 40, 50, 60])\nnp.add(numbers, numbers2)        # equivalent to numbers + numbers2, numbers = array([11, 12, 13, 14, 15, 16])\n\narray([21, 32, 43, 54, 65, 76])\n\n\n\n\n9.5.3.2 Broadcasting with Universal Functions\nLet’s use the multiply() universal function to multiply every element of numbers2 by the scalar value 5:\n\nnp.multiply(numbers2, 5) # equivalent to numbers2 * 5\n\narray([ 50, 100, 150, 200, 250, 300])\n\n\nLet’s reshape numbers2 into a 2-by-3 array, then multiply its values by a one-dimensional array of three elements:\n\nnumbers3 = numbers2.reshape(2, 3)\nnumbers4 = np.array([2, 4, 6])\nnumbers3, numbers4\n\n(array([[10, 20, 30],\n        [40, 50, 60]]),\n array([2, 4, 6]))\n\n\n\nnp.multiply(numbers3, numbers4) # Equivalent to numbers3 * numbers4\n\narray([[ 20,  80, 180],\n       [ 80, 200, 360]])\n\n\nIn this case, numbers4 has the same length as each row of numbers3, allowing NumPy to apply the multiplication operation by treating numbers4 as an array with the following values:\narray([[2, 4, 6],\n       [2, 4, 6]])\nIf a universal function receives two arrays with different shapes that do not support broadcasting, a ValueError is raised. Vectorization and ufunc functions are closely associated with broadcasting in NumPy, as they are frequently employed together to perform element-wise operations on arrays with varying shapes. By combining vectorization, ufunc functions, and broadcasting, we can effectively execute complex arithmetic operations on NumPy arrays.\nThere are other special mathematical ufunc. Let’s create an array and calculate the square root of its values using the sin() universal function:\n\nnumbers = np.array([1, 4, 9, 16, 25, 36])\nnp.sin(numbers)\n\narray([ 0.84147098, -0.7568025 ,  0.41211849, -0.28790332, -0.13235175,\n       -0.99177885])\n\n\n\n\n9.5.3.3 Create our own vectorizing functions\nThe vectorized operation are often more concise, and it is thus advisable to avoid element-wise looping over vectors and matrices and instead employ vectorized algorithms. The initial step in converting a scalar algorithm to a vectorized algorithm involves verifying that the functions we create can function with vector inputs:\n\ndef Theta(x, th):\n    \"\"\"\n    Scalar implemenation of a variant of Heaviside step function.\n    \"\"\"\n    if x &gt;= th:\n        return 1\n    else:\n        return 0\n\nWe can achieve this using np.vectorize function:\n\nTheta_vec = np.vectorize(Theta)\nTheta_vec(np.array([-3,-2,-1,0,1,2,3]), 1)\n\narray([0, 0, 0, 0, 1, 1, 1])\n\n\n\nDon’t assume np.vectorize() is faster. It is mainly for convenient and concise purposes as described here.\n\n\n9.5.4 Exercise 2: Suppose we are dealing with a spreadsheet that records the grade of students. The grade contains the homework, midterm and finals as follows:\n\n\n\n\n\nName\nHW1\nHW2\nHW3\nHW4\nMidterm\nFinal\n\n\n\n\nAlice\n90\n80\n70\n100\n90\n95\n\n\nBob\n80\n90\n100\n70\n85\n80\n\n\nCharlie\n70\n100\n90\n80\n95\n90\n\n\nDavid\n60\n70\n80\n90\n85\n100\n\n\nEve\n50\n60\n70\n80\n75\n90\n\n\n\n\nWe would like to calculate the semester score of each student by the following rules:\n\nThe weight of each score is 0.2 (the summation of four homework accounts for 20% of the total scores and each homework has the same weight), 0.4 and 0.4 for HW, Midterm and Final, respectively.\nWe adjust each student’s score so that the top performer in the class gets a score of 100 by adding the same constant score to each student’s score.\n\nWe use a 2D array to model the grades so that each row corresponds to a student’s score. Use the following template to complete the task:\ngrades = np.array([[90, 80, 70, 100, 90, 95],\n                   [80, 90, 100, 70, 85, 80],\n                   [70, 100, 90, 80, 95, 90],\n                   [60, 70, 80, 90, 85, 100],\n                   [50, 60, 70, 80, 75, 90]])\n\nweights = np.array([])\nscores\n\n# Your code here\n\n\n\n\n9.5.5 Type casting\nDue to the nature of static typing, the type of a NumPy array does not change once created. However, we can explicitly convert an array of one type to another using the astype() function. This operation always generates a new array with a new type.\n\nM = np.random.rand(5,5)\nM.dtype\n\ndtype('float64')\n\n\n\nM2 = M.astype(np.int64)\nM2\n\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0]], dtype=int64)\n\n\nSee https://scipy-lectures.org/intro/numpy/elaborate_arrays.html for more details."
  },
  {
    "objectID": "10_11_NumPy.html#file-io",
    "href": "10_11_NumPy.html#file-io",
    "title": "9  Array-Oriented Programming with NumPy",
    "section": "9.6 File I/O",
    "text": "9.6 File I/O\nNumPy has its own binary format, not portable but with efficient I/O. This is useful when storing and reading back array data. Use the functions numpy.save() and numpy.load().\n\nnp.save(\"random-matrix.npy\", M)\nM2 = np.load(\"random-matrix.npy\")\nM2\n\narray([[0.38791019, 0.93061564, 0.33040029, 0.9810319 , 0.92882123],\n       [0.87579212, 0.57436978, 0.99856211, 0.83380903, 0.34188505],\n       [0.30067505, 0.99334148, 0.89929337, 0.78057549, 0.10613898],\n       [0.71493999, 0.02124826, 0.95090779, 0.12435095, 0.55611604],\n       [0.05511708, 0.7047183 , 0.26478257, 0.21195283, 0.77090752]])\n\n\nIn summary:\nTo make the code faster using NumPy\n\nIn place operations: a *= 3 instead of a = 3*a\nUse views instead of copies whenever possible\nBroadcasting: Use broadcasting to do operations on arrays\nVectorizing for loops: Find tricks to avoid for loops using NumPy arrays.\n\nThe comparisons between list and array are summarized as follows:\nPython objects:\n\nPython lists are very general. They can contain any kind of object and are dynamically typed\nHowever, they do not support mathematical functions such as matrix multiplications. Implementing such functions for Python lists would not be very efficient because of the dynamic typing\n\nNumPy provides:\n\nNumpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created\nBecause of the static typing, fast implementation of mathematical functions such as multiplication and addition of NumPy arrays can be implemented in a compiled language (C and Fortran is used). Moreover, Numpy arrays are memory efficient"
  },
  {
    "objectID": "12_Matplotlib.html#introduction",
    "href": "12_Matplotlib.html#introduction",
    "title": "10  Visualization with Matplotlib",
    "section": "10.1 Introduction",
    "text": "10.1 Introduction\nMatplotlib is a multiplatform data visualization library built on NumPy arrays and designed to work with the broader SciPy stack. Matplotlib supports numerous backends and output types, which means we can count on it to work regardless of the operating system we are using or the output format we desire. It has led to a large user base, which in turn has resulted in an active developer base and Matplotlib’s powerful tools and ubiquity within the scientific Python world. Let’s install the package first:\n\npackage_name = \"matplotlib\"\n\ntry:\n    __import__(package_name)\n    print(f\"{package_name} is already installed.\")\nexcept ImportError:\n    print(f\"{package_name} not found. Installing...\")\n    %pip install {package_name}\n\nmatplotlib is already installed.\n\n\nCreating interactive plots within a Jupyter notebook can be accomplished using the %matplotlib command. Additionally, we have the option to embed graphics directly in the notebook using inline option:\n\n#Static backend\n%matplotlib inline \n#Interactive backend\n#%matplotlib widget \n#Interactive backend\n#%matplotlib ipympl \n\nJust as we use the np shorthand for NumPy, we will use some standard shorthands for Matplotlib imports:\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.style.use('seaborn-v0_8-whitegrid')\n\nWe can choose the style we would like from the here."
  },
  {
    "objectID": "12_Matplotlib.html#two-interfaces-for-the-matplotlib",
    "href": "12_Matplotlib.html#two-interfaces-for-the-matplotlib",
    "title": "10  Visualization with Matplotlib",
    "section": "10.2 Two interfaces for the matplotlib",
    "text": "10.2 Two interfaces for the matplotlib\nA feature of Matplotlib that may cause confusion is its dual interfaces: a user-friendly functional-style state-based interface and a more powerful object-oriented interface. We’ll briefly outline the differences between the two here. Firstly, we create the data we would like to plot. The simplest method, plot() accept two arrays (x and y) as inputs. It will plot y versus x as lines and/or markers.\n\nx = np.linspace(-np.pi, np.pi, 256)\nC, S = np.cos(x), np.sin(x)\n\nx is now a array with 256 values ranging from \\(-\\pi\\) to \\(\\pi\\) (included). C is the cosine (256 values) and S is the sine (256 values).\n\n10.2.1 Functional Interface\nMatplotlib was initially developed as a Python alternative for MATLAB users, and many aspects of its syntax reflect this origin. The MATLAB-style tools can be found in the pyplot (plt) interface. For instance, the following code might appear quite familiar to MATLAB users:\n\n# 1. create a plot figure\nplt.figure() \n\n# 2. create the first of two panels and set current axis\nplt.subplot(2, 1, 1) # (rows, columns, panel number)\nplt.plot(x, S)\n\n# 3. create the second panel and set current axis\nplt.subplot(2, 1, 2)\nplt.plot(x, C)\nplt.savefig(\"test.jpg\");\n# Note that the semicolon at the end of the last line is intentional: it suppresses the textual\n# representation of the plot from the output\n\n\n\n\nIt’s crucial to understand that this interface is stateful: it maintains information about the “current” figure and axes, which serve as the targets for all plt commands. We can obtain a reference to these by using the plt.gcf() (get current figure) and plt.gca() (get current axes) functions.\n\nplt.gca();\n\n\n\n\nAlthough the stateful interface is quick and convenient for basic plots, it can lead to difficulties. For instance, after creating the second panel, how can we return to the first one and add something? While this can be achieved using the MATLAB-style interface, it may be somewhat awkward. Thankfully, there is a more efficient solution.\n\n\n10.2.2 Object-oriented interface\nFor more complex scenarios or when greater control over the figure is desired, the object-oriented interface comes in handy. Instead of relying on the concept of an “active” figure or axes, the object-oriented interface treats plotting functions as methods of explicit Figure and Axes objects.\n\n# 1. First create a grid of plots\n# ax will be an array of two Axes objects\nfig, ax = plt.subplots(2)\n\n# 2. Call plot() method on the appropriate object\nax[0].plot(x, S)\nax[1].plot(x, C);\n\n\n\n\nFor basic plots, the choice between the two styles is mainly a matter of personal preference. However, as plots become more intricate, the object-oriented approach may be essential.\n\nfig.savefig(\"test.pdf\")"
  },
  {
    "objectID": "12_Matplotlib.html#simple-plots",
    "href": "12_Matplotlib.html#simple-plots",
    "title": "10  Visualization with Matplotlib",
    "section": "10.3 Simple plots",
    "text": "10.3 Simple plots\n\n10.3.1 Simple line plots\nTo create a 2D line plot, follow these general steps:\n\nCall the plt.figure() to create a new figure. (optional for %matplotlib inline)\nGenerate a sequence of \\(x\\) values usually using linspace().\nGenerate a sequence of \\(y\\) values usually by substitute the x values into a function.\nInput plt.plot(x, y, [format], **kwargs) where [format] is an (optional) format string, and **kwargs are (optional) keyword arguments specifying the line properties of the plot.\nUtilize plt functions to enhance the figure with features such as a title, legend, grid lines, etc.\nInput plt.show() to display the resulting figure (this step is optional in a Jupyter notebook).\n\nLet’s begin with a basic example where we try plotting the parabola using 5 points:\n\nx = [-2,-1,0,1,2]\ny = [4,1,0,1,4]\n\nplt.plot(x,y);\n\n\n\n\nKey aspects to pay attention to are:\n\nThe sequences x and y determine the coordinates of the points in the plot.\nThe plot’s line is formed by connecting these points with straight lines.\n\nThe second observation suggests that if we aim to display a smooth curve, we need to plot numerous points; otherwise, the plot will not appear smooth. Let’s attempt this again, using the NumPy function np.linspace() to create 200 points:\n\nx = np.linspace(-2,2,200)\ny = x**2\nplt.plot(x,y);\n\n\n\n\nLooks much better!\nLet’s try another example with a simple sinusoid:\n\nx = np.linspace(0, 10, 1000)\nplt.plot(x, np.sin(x));\n# let the figure and axes be created for us in the background\n\n\n\n\nIf we want to create a single figure with multiple lines, we can simply call the plot() function multiple times:\n\nplt.plot(x, np.sin(x))\nplt.plot(x, np.cos(x));\n\n\n\n\n\n10.3.1.1 Adjusting the plot: Line colors, styles and widths\nOne of the initial modifications you might want to make to a plot is adjusting the line colors and styles. The plt.plot() function accepts additional arguments that can be employed to define these aspects. To change the color, you can use the color keyword, which takes a string argument representing a wide range of possible colors.\n\nplt.plot(x, np.cos(x - 0), color='blue')         # specify color by name\nplt.plot(x, np.cos(x - 1), color='g')            # short color code (rgbcmyk)\nplt.plot(x, np.cos(x - 2), color='0.75')         # grayscale between 0 and 1\nplt.plot(x, np.cos(x - 4), color=(1.0,0.2,0.3)); # RGB tuple, values 0 to 1\n\n\n\n\nSimilarly, the line style can be adjusted using the linestyle keyword:\n\nplt.plot(x, x - 0, linestyle='-')  # solid\nplt.plot(x, x - 1, linestyle='--') # dashed\nplt.plot(x, x - 2, linestyle='-.') # dashdot\nplt.plot(x, x - 3, linestyle=':')  # dotted\nplt.plot(x, x - 4, ':k');          # dotted black \n# You can save some keystrokes by combining these linestyle and color codes into a single non-keyword argument\n\n\n\n\nFinally, you can also adjust the width using linewidth keyword:\n\nplt.plot(x, np.cos(x - 0)) \nplt.plot(x, np.cos(x - 1), linewidth='5');\n\n\n\n\n\n\n10.3.1.2 Adjusting the plot: Axes limits\nMatplotlib generally provides suitable default axes limits for your plot, but in certain cases, having more control can be advantageous. The simplest method to fine-tune the limits is by utilizing the plt.xlim() and plt.ylim() functions:\n\nplt.plot(x, np.cos(x))\n\nplt.xlim(-0.5, 10.5)\nplt.ylim(-1.5, 1.5);\n\n\n\n\n\n\n10.3.1.3 Labeling plots\nLet’s take a quick look at labeling plots. Titles and axis labels are the most basic types of labels — there are methods available to set them quickly. Moreover, when multiple lines appear within a single set of axes, a plot legend can be helpful in labeling each line type. Once again, Matplotlib has a built-in method for swiftly creating such a legend, achieved through the plt.legend() method:\n\nplt.plot(x, np.sin(x), '-g', label='sin(x)') # solid green line\nplt.plot(x, np.cos(x), ':b', label='cos(x)') # dotted blue line\n\nplt.title(\"A Sin/Cos Curve\", fontsize=18)       # we can also specify the font size\nplt.xlabel(\"x\", fontsize=14)\nplt.ylabel(\"sin(x)\", fontsize=14)\nplt.legend(fontsize=12)\n\nplt.axis('equal');\n\n\n\n\nNote that we can specify color and style of the line simultaneously using the format string. In addition, we use the function plt.axis('equal') to force the scaling to be equal on both axes. In addition, the plt.legend() function keeps track of the line style and color, and matches these with the correct label!\nFor more anatomy of a figure, you can refer to the following figure (which is created using the code available here):\n\n\n\n\n\n10.3.1.4 Matplotlib tips\nWhile many plt functions (Functional interface) have direct ax method (OOP interface) equivalents (plt.plot() → ax.plot(), plt.legend() → ax.legend(), etc.), this does not apply to all commands. Specifically, functions for setting limits, labels, and titles undergo slight modifications. To transition between MATLAB-style functions and object-oriented methods, implement the following changes:\n\n\n\n\nFunctional\nOOP\n\n\n\n\nplt.xlabel()\nax.set_xlabel()\n\n\nplt.ylabel()\nax.set_ylabel()\n\n\nplt.xlim()\nax.set_xlim()\n\n\nplt.ylim()\nax.set_ylim()\n\n\nplt.title()\nax.set_title()\n\n\n\n\n\n\n\n10.3.2 Simple scatter plots\nAnother frequently used plot type is the basic scatter plot. In this case, points are depicted individually with a dot, circle, or other shape, rather than being connected by line segments. It turns out that the same function can also generate scatter plots:\n\nx = np.linspace(0, 10, 30)\ny = np.sin(x)\nplt.plot(x, y, 'o', color='black');\n\n\n\n\nThe third argument in the function call is a character representing the type of symbol used for plotting. Similar to specifying options like ‘-’ or ‘–’ to control the line style, marker styles also have their own set of brief string codes:\n\nnp.random.seed(42)\n\nfor marker in ['o', '.', ',', 'x', '+', 'v', '^', '&lt;', '&gt;', 's', 'd']:\n    plt.plot(np.random.random(1), np.random.random(1), marker, color='black', label=f'marker={marker}')\n\nplt.legend(fontsize=13)\nplt.xlim(0, 1.8);\n\n\n\n\nFor even greater versatility, these character codes can be combined with line and color codes to plot points accompanied by a connecting line. Furthermore, the size or color of the markers can be customized:\n\nplt.plot(x, y, '-vb', markersize=15, linewidth=4, markerfacecolor='orange', markeredgewidth=2)\nplt.ylim(-1.2, 1.2);\n\n\n\n\n\n10.3.2.1 Scatter Plots with plt.scatter()\nA more advanced method for creating scatter plots is the plt.scatter() function. The main advantage of plt.scatter() over plt.plot() is its ability to generate scatter plots where the properties of each individual point (size, face color, edge color, etc.) can be individually controlled or mapped to data. To demonstrate this, let’s create a random scatter plot with points of various colors and sizes. To better visualize the overlapping points, we’ll also use the alpha keyword to adjust the transparency level:\n\nnp.random.seed(42)\n\nx = np.random.randn(100)\ny = np.random.randn(100)\ncolors = np.random.rand(100)\nsizes = 1000 * np.random.rand(100)\n\nplt.scatter(x, y, c=colors, s=sizes, alpha=0.3, cmap='viridis')\nplt.colorbar(); # show color scale\n\n\n\n\nObserve that the color argument is automatically mapped to a color scale (demonstrated here by the colorbar() command). Moreover, we can choose a color map using the cmap keyword. To view all Matplotlib color maps, refer to the list of colormaps.\n\n\n\n10.3.3 Density plots\n\n10.3.3.1 Histograms, binnings, and density\nA basic histogram can be an excellent initial step in comprehending a dataset. We can use plt.hist() to calculate and generate a histogram of sample data:\n\nnp.random.seed(42)\ndata = np.random.normal(size=1000)\nplt.hist(data);\n\n\n\n\nThe hist() function provides numerous options for fine-tuning both the computation and display. Here’s an example of a more customized histogram:\n\nplt.hist(data, bins=30, density=True, alpha=0.5, color='steelblue', edgecolor='none')\nx = np.linspace(-4,4,100)\ny = 1/(2*np.pi)**0.5 * np.exp(-x**2/2)\nplt.plot(x,y,'b',alpha=0.8);\n\n\n\n\nThe density=True keyword argument normalizes the histogram and displays it on the same axes as the data. The bins keyword argument specifies the number of bins to use for the histogram. Here, we also superimpose the normal distribution \\(y = \\frac{1}{\\sqrt{2\\pi}} e^{-x^2/2}\\).\n\n10.3.4 Exercise 1: Try to plot the function \\(\\sin(x)/x\\) within the range -10 to 10 with evenly spaced 200 points using the solid blue line. Use visual inspection and the following code to check the value of the function when x approaches 1.\n\n# Find the x coordinates closest to 0 using isclose() and masking\nx[np.isclose(x, 0, atol=1e-01)]\ny[np.isclose(x, 0, atol=1e-01)]\nFinally, plot the above points with red circle markers on the same plot.\n\n# Your code here"
  },
  {
    "objectID": "12_Matplotlib.html#advance-plot",
    "href": "12_Matplotlib.html#advance-plot",
    "title": "10  Visualization with Matplotlib",
    "section": "10.4 Advance plot",
    "text": "10.4 Advance plot\n\n10.4.1 Filling the area between lines\nSometimes, it may be useful to fill areas between plots using plt.fill_between():\n\nx = np.linspace(0, 2*np.pi, 1000)\n\nplt.plot(x, np.sin(x), 'r')\nplt.plot(x, np.cos(x), 'g')\nplt.fill_between(x, np.cos(x), np.sin(x), color='red', alpha=0.1)\n\n&lt;matplotlib.collections.PolyCollection at 0x287cedb7fa0&gt;\n\n\n\n\n\n\n\n10.4.2 Plot in polar coordinate\nTo plot the figure in different coordinate system, we can use projection option of the plt.axes() method:\n\nt = np.linspace(0, 2*np.pi, 64)\n\n# plot in polar coordinates\nplt.axes(projection='polar')\nplt.plot(t, np.sin(t), '-');\n\n\n# Set ticks for polar coordinate\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2], ['0', '$\\pi/2$', '$\\pi$', '$3\\pi/2$']);\n\n\n\n\nNote that we would expect that a radius of 0 designates the origin, and a negative radius is reflected across the origin; in particular, the polar coordinates \\((r, t)\\) and \\((-r, t+\\pi)\\) should designate the same point. We can enforce this behavior using the following code:\n\nt = np.linspace(0, 2*np.pi, 64)\nr = np.sin(t)\n# plot in polar coordinates\nplt.axes(projection='polar')\nplt.plot(t+(r&lt;0)*np.pi, np.abs(r), '-')\n\n# Set ticks for polar coordinate\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2], ['0', '$\\pi/2$', '$\\pi$', '$3\\pi/2$']);"
  },
  {
    "objectID": "12_Matplotlib.html#customizing-plot",
    "href": "12_Matplotlib.html#customizing-plot",
    "title": "10  Visualization with Matplotlib",
    "section": "10.5 Customizing Plot",
    "text": "10.5 Customizing Plot\n\n10.5.1 Customizing plot legends\nPlot legends provide context to a visualization, attributing meaning to the various plot elements. For instance, we can designate the location and display the frame:\n\nx = np.linspace(0, 10, 100)\nplt.plot(x, np.sin(x), '-g', label='sin(x)')\nplt.plot(x, np.cos(x), ':b', label='cos(x)')\nplt.axis('equal')\n\nplt.legend(loc='upper left', frameon=True);\n\n\n\n\n\n10.5.1.1 Text and Annotation\nCrafting an effective visualization entails leading the viewer so that the figure narrates a tale. In certain situations, this narrative can be communicated solely through visual means, without the need for supplementary text, but in others, brief textual indicators and labels are required. Axis labels and titles are the most fundamental types of annotations that we’ll employ.\nWhen visualizing data, it’s frequently beneficial to annotate particular features of the plot to attract the viewer’s attention. This can be done manually using the plt.text() function, which positions text at a specified x/y value. Furthermore, we can use the plt.annotate() function, which generates text and an arrow and enables the arrows to be specified with great flexibility.\n\nplt.figure() \nx = np.linspace(0, 20, 1000)\nplt.plot(x, np.cos(x))\nplt.axis('equal')\n\nplt.annotate('local maximum', xy=(6.28, 1), xytext=(10, 4), arrowprops=dict(facecolor='black'), fontsize=14)\nplt.annotate('local minimum', xy=(5 * np.pi, -1), xytext=(2, -6), arrowprops=dict(arrowstyle=\"-&gt;\"), fontsize=14)\nplt.text(3.14, -1, 'local minimum', fontsize=14, ha='center'); # (x, y, text)\n\n\n\n\nThe arrow style is controlled through the arrowprops dictionary, which has numerous options available.\n\n\n10.5.1.2 Customizing ticks and splines\nMatplotlib’s default tick locators and formatters are generally sufficient for many common situations but are not optimal for every plot. Within each axis, there are major tick marks and minor tick marks. As the names suggest, major ticks are typically more prominent or larger, while minor ticks are usually smaller. You can modify the ticks using the xticks() and yticks() functions. The first argument is a list of tick locations, and the second argument is a list of tick labels:\n\nx = np.linspace(0, 20, 1000)\nplt.plot(x, np.cos(x))\nplt.plot(x, np.sin(x))\nplt.axis('equal')\n\n# Set the ticks and tick labels\nplt.xticks([0, np.pi, 2 * np.pi, 3 * np.pi, 4 * np.pi],\n           [r'$0$', r'$\\pi$', r'$2\\pi$', r'$3\\pi$', r'$4\\pi$'], fontsize=14)\nplt.yticks([-1, 0, +1],  [r'$-1$', r'$0$', r'$+1$'], fontsize=14);\n\n\n\n\nSpines are the lines connecting the axis tick marks and indicating the boundaries of the data area. They can be positioned at arbitrary locations, and by default, they are positioned at the borders of the axis. We’ll change that and position them in the middle instead. Since there are four spines (top, bottom, left, and right), we’ll remove the top and right spines and move the bottom and left spines to the center:\n\nplt.figure(figsize=(8,5), dpi=80)\nX = np.linspace(-np.pi, np.pi, 256, endpoint=True)\nC = np.cos(X)\nS = np.sin(X)\n\nplt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\")\nplt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\")\n\nax = plt.gca()\nax.spines[['top', 'right']].set_visible(False)\nax.spines['bottom'].set_position(('data',0))\nax.spines['left'].set_position(('data',0))\n\n\n\n\nNote that here we also use plt.figure(figsize=(8,5), dpi=80) to set the figure size and resolution."
  },
  {
    "objectID": "12_Matplotlib.html#multiple-subplots",
    "href": "12_Matplotlib.html#multiple-subplots",
    "title": "10  Visualization with Matplotlib",
    "section": "10.6 Multiple Subplots",
    "text": "10.6 Multiple Subplots\nAt times, it’s beneficial to compare different views of data side by side. To achieve this, Matplotlib has the notion of subplots: collections of smaller axes that can coexist within a single figure. These subplots may be insets, grids of plots, or other more complex layouts.\n\n10.6.1 plt.subplots()\nAligned rows or columns of subplots are a common enough requirement that Matplotlib has several convenience routines that make it easy to create them. plt.subplots() is the easiest tool to use. Instead of creating a single subplot, this function creates a complete grid of subplots in one line, and returns them as a NumPy array. The arguments are the number of rows and the number of columns, along with optional keywords sharex and sharey, which allow you to specify the relationships between different axes.\nLet’s create a \\(2 \\times 3\\) grid of subplots, and adjust the spacing between them:\n\nfig, ax = plt.subplots(2, 3)\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\nfor i in range(2):\n    for j in range(3):\n        ax[i, j].text(0.5, 0.5, str((i, j)), fontsize=18, ha='center', va='center')\n\n\n\n\nThe command plt.subplots_adjust() can be used to adjust the spacing between subplots (in this case, the space is set to 40% of the subplot width and height). We can then use the subplots to plot different figures:\n\nfig, ax = plt.subplots(2, 2, figsize=(8,8))\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\n\nx = np.linspace(0, 10, 1000)\nax[0,0].plot(x, np.sin(x))\nax[0,1].plot(x, np.cos(x))\nax[1,0].plot(x, x**2)\nax[1,0].set_xscale('log') # Set the scale to log scale\nax[1,0].set_yscale('log')\nax[1,1].plot(x, x**2);\n\n\n\n\n\n10.6.2 Exercise 2: Try to plot the function \\(\\frac{1}{x(x-1)}\\) within the range -2 to 3 with evenly spaced points. Try to set the point at the discontinuity to np.nan so that the point won’t be plotted in the figure for better visualization purposes.\n\nHint: You can use np.close() function to find the index of the point closest to the discontinuity.\n\n# Your code here\n\nIn summary, Matplotlib is a data visualization library for creating visualizations in Python. It provides a wide variety of customizable plots, charts, and graphs, making it a powerful tool for data analysis and communication. With Matplotlib, we can create line plots, scatter plots, histograms, and many other types of visualizations. You can customize the appearance of your plots with a wide range of options, including color schemes, fonts, axes labels, and annotations. Refer to https://matplotlib.org/cheatsheets/ for more details."
  },
  {
    "objectID": "13_SymPy.html#introduction",
    "href": "13_SymPy.html#introduction",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.1 Introduction",
    "text": "11.1 Introduction\nSymPy is a Python library designed for symbolic mathematics. Its goal is to serve as an alternative to systems like Mathematica, Maple, or Sage while maintaining a simple and easily extensible codebase. SymPy is written entirely in Python and does not necessitate any external libraries.\nThe standard way of importing the module is:\n\npackage_name = \"sympy\"\n\ntry:\n    __import__(package_name)\n    print(f\"{package_name} is already installed.\")\nexcept ImportError:\n    print(f\"{package_name} not found. Installing...\")\n    %pip install {package_name}\n\nsympy is already installed.\n\n\n\nimport sympy as sp\nsp.init_printing()\n\nWhen you call sp.init_printing(), it sets up your session to be able to print SymPy objects in a more visually appealing and understandable way."
  },
  {
    "objectID": "13_SymPy.html#using-sympy-as-a-calculator",
    "href": "13_SymPy.html#using-sympy-as-a-calculator",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.2 Using SymPy as a calculator",
    "text": "11.2 Using SymPy as a calculator\nThe core module in the SymPy package includes the Number class, which represents atomic numbers. This class has two subclasses: the Float and Rational classes. The Rational class is further extended by the Integer class. First, let’s create an Integer object from SymPy and perform some calculations:\n\nu = sp.Integer(24)\nu/8, u/7\n\n\\(\\displaystyle \\left( 3, \\  \\frac{24}{7}\\right)\\)\n\n\n\ntype(u/8), type(u/7)\n\n(sympy.core.numbers.Integer, sympy.core.numbers.Rational)\n\n\nAs demonstrated, if an exact result can be obtained, SymPy will return it. If not, SymPy will provide an expression instead.\nThe Rational class represents a rational number as a pair of two Integers: the numerator and the denominator. Thus, Rational(1, 2) represents 1/2, Rational(5, 2) represents 5/2, and so on:\n\na = sp.Rational(1, 3)\na, a*6\n\n\\(\\displaystyle \\left( \\frac{1}{3}, \\  2\\right)\\)\n\n\n\ntype(a), type(a*6)\n\n(sympy.core.numbers.Rational, sympy.core.numbers.Integer)\n\n\nLastly, there is a Float class that can represent a floating-point number with arbitrary precision:\n\nprint(sp.Float(3.53) + sp.Float(3))\n\n6.53000000000000\n\n\nNote that this is in contrast to normal Python where we may get approximated results:\n\nprint(3.53 + 3)\n\n6.529999999999999\n\n\nFor more about the discussion of floating point math, see here or here for more information.\nIn addition to the numerical classes, SymPy features constant objects, such as pi, E, oo (infinity) and others. SymPy employs mpmath in the background, enabling computations using arbitrary-precision arithmetic. Consequently, certain special constants, like \\(e\\), \\(\\pi\\), and \\(\\infty\\), can also be evaluated:\n\nsp.pi**2, sp.pi.evalf()\n\n\\(\\displaystyle \\left( \\pi^{2}, \\  3.14159265358979\\right)\\)\n\n\n\n(sp.pi + sp.E).evalf()\n\n\\(\\displaystyle 5.85987448204884\\)\n\n\nAs demonstrated, the evalf() method can be used to evaluate an expression as a floating-point number. To evaluate results with arbitrary precision, simply pass the desired number of digits to the evalf() method:\n\nsqrt2 = sp.sqrt(2).evalf(100)\nsqrt2\n\n\\(\\displaystyle 1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641573\\)\n\n\nAs we have mentioned, there is also a object representing mathematical infinity called oo:\n\nsp.oo &gt; 99999\n\n\\(\\displaystyle \\text{True}\\)\n\n\nFinally, we also have other common functions like sin, cos, tan, exp, log, etc. in SymPy:\n\nsp.sin(sp.pi/2), sp.exp(0), sp.log(1)\n\n\\(\\displaystyle \\left( 1, \\  1, \\  0\\right)\\)"
  },
  {
    "objectID": "13_SymPy.html#defining-symbols-and-perform-symbolic-operations",
    "href": "13_SymPy.html#defining-symbols-and-perform-symbolic-operations",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.3 Defining symbols and perform symbolic operations",
    "text": "11.3 Defining symbols and perform symbolic operations\nSymbols serve as the foundation of symbolic math. When we write the statement \\(x + x + 1\\), Python evaluates it, resulting in a numerical value. But what if we want the result in terms of the symbol \\(x\\)? SymPy enables us to write programs where we can express and evaluate mathematical expressions using such symbols. First, we import the Symbol class from SymPy and create an object of this class, passing 'x' as a parameter:\n\nx = sp.Symbol('x') # the symbol you create has to be specified as a string\nx + x + 1\n\n\\(\\displaystyle 2 x + 1\\)\n\n\nAfter defining symbols, you can perform basic mathematical operations on them using the same operators you’re already familiar with:\n\nx,y = sp.symbols('x,y') # you can create multiple symbols at once using multiple assignment\np = (x + 3)*(y/3+x)\np\n\n\\(\\displaystyle \\left(x + 3\\right) \\left(x + \\frac{y}{3}\\right)\\)\n\n\nNote that symbols() is a function while Symbol is a class!\nYou might have anticipated that SymPy would multiply everything out. However, SymPy only automatically simplifies the most elementary expressions and requires the programmer to explicitly request further simplification. To expand an expression, utilize the expand() function:\n\np2 = sp.expand(p)\np2\n\n\\(\\displaystyle x^{2} + \\frac{x y}{3} + 3 x + y\\)\n\n\nYou can also factor expressions using the factor() function:\n\nsp.factor(p2)\n\n\\(\\displaystyle \\frac{\\left(x + 3\\right) \\left(3 x + y\\right)}{3}\\)\n\n\nThe terms are organized in the order of x powers, from highest to lowest. If you prefer the expression in the reverse order, with the highest power of x appearing last, you can achieve that using the init_printing() function, as shown below:\n\nsp.init_printing(order='rev-lex')\np2\n\n\\(\\displaystyle y + 3 x + \\frac{x y}{3} + x^{2}\\)\n\n\nThe above code demonstrates that we want SymPy to display the expressions in reverse lexicographical order. In this instance, the keyword argument instructs Python to print terms with lower powers first.\nWe can also employ SymPy to substitute values into an expression. This allows us to compute the value of the expression for specific variable values. Take the mathematical expression \\(x^2 + 2xy + y^2\\), which can be defined as follows:\n\nsp.init_printing(order='lex')\np3 = x*x + x*y + x*y + y*y\np3\n\n\\(\\displaystyle x^{2} + 2 x y + y^{2}\\)\n\n\nTo evaluate this expression, you can substitute numbers for the symbols by using the subs() method:\n\np3.subs({x:1, y:2}) # We use dictionary to specify the values of x and y\n\n\\(\\displaystyle 9\\)\n\n\nAdditionally, you can express one symbol in terms of another and perform substitutions accordingly, using the subs() method. For instance, if you know that \\(x = 1 - y\\), this is how you could evaluate the previous expression:\n\np3.subs({x:1-y})\n\n\\(\\displaystyle y^{2} + 2 y \\left(- y + 1\\right) + \\left(- y + 1\\right)^{2}\\)\n\n\nIf you desire a more simplified result — for example, if there are terms that cancel each other out — you can utilize SymPy’s simplify() function:\n\nsp.simplify(p3.subs({x:1-y})) # The result turns out to be 1 because the other terms of the expression cancel each other.\n\n\\(\\displaystyle 1\\)\n\n\nThis example reiterates that SymPy will not perform any complex simplification unless explicitly requested to do so.\n\n11.3.1 Exercise 1: Try to solve the following problems using SymPy:\nExpand the following expression: \\(\\sin(4x)\\cos(5x)\\) so that the final results only contains sin(x) and its power term (\\(\\sin^n(x)\\)).\n\nHint: You can use simplify(), subs() and expand() function to simplify the expression. You may find keyowrd trig=True argument in expand() function useful. Finally, if you want to perform symbolic manipulation, be sure to use functions in SymPy.\n\n# Your code here"
  },
  {
    "objectID": "13_SymPy.html#solving-equations-symbolically",
    "href": "13_SymPy.html#solving-equations-symbolically",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.4 Solving equations symbolically",
    "text": "11.4 Solving equations symbolically\nSymPy’s solve() function can be employed to find solutions to equations. When you input an expression with a symbol representing a variable, such as x, solve() computes the value of that symbol. This function always performs its calculation by assuming the expression you enter is equal to zero — that is, it outputs the value that, when substituted for the symbol, makes the entire expression equal zero.\nLet’s start with the simple equation \\(x - 5 = 7\\). If we want to use solve() to find the value of x, we first need to make one side of the equation equal zero (\\(x - 5 - 7 = 0\\)). Then, we’re ready to use solve(), as shown below:\n\nx = sp.Symbol('x')\nexpr = x - 5 - 7\nsp.solve(expr)\n\n\\(\\displaystyle \\left[ 12\\right]\\)\n\n\nObserve that the result 12 is returned within a list. An equation can have multiple solutions — for instance, a quadratic equation has two solutions. In such cases, the list will include all the solutions as its elements. Let’s look at an example:\n\nx = sp.Symbol('x')\nexpr = x**2 + 5*x + 4\nsp.solve(expr), sp.solve(expr, dict=True)\n\n\\(\\displaystyle \\left( \\left[ -4, \\  -1\\right], \\  \\left[ \\left\\{ x : -4\\right\\}, \\  \\left\\{ x : -1\\right\\}\\right]\\right)\\)\n\n\nIt’s worth noting that we can set dict=True as an argument to retrieve a dictionary instead of a list.\nIn addition to finding the roots of equations, we can leverage symbolic math to utilize the solve() function to express one variable in an equation in terms of the others. Let’s examine finding the roots for the general quadratic equation \\(ax^2 + bx + c = 0\\). To accomplish this, we’ll define x and three additional symbols — a, b, and c, which correspond to the three coefficients:\n\nx = sp.Symbol('x')\na = sp.Symbol('a')\nb = sp.Symbol('b')\nc = sp.Symbol('c')\n\nexpr = a*x*x + b*x + c\nsp.solve(expr, x, dict=True)\n\n\\(\\displaystyle \\left[ \\left\\{ x : \\frac{- b - \\sqrt{- 4 a c + b^{2}}}{2 a}\\right\\}, \\  \\left\\{ x : \\frac{- b + \\sqrt{- 4 a c + b^{2}}}{2 a}\\right\\}\\right]\\)\n\n\nIn this example, we must include an additional argument, x, to the solve() function. Because there’s more than one symbol in the equation, we need to inform solve() which symbol it should solve for, which we indicate by passing in x as the second argument. As anticipated, solve() outputs the quadratic formula: the general formula for determining the value(s) of x in a polynomial expression.\nWe can also sove the expression using nsolve() function. nsolve() function is a numerical solver that uses numerical methods to find the roots of an equation given a starting point. For example, we can solve the equation \\(x^2 - 2 = 0\\) using nsolve() function:\n\nx = sp.Symbol('x')\nexpr = x**2 - 2\nsp.nsolve(expr, -1), sp.nsolve(expr, 1), sp.solve(expr) # -1 and 1 are the starting points\n\n\\(\\displaystyle \\left( -1.4142135623731, \\  1.4142135623731, \\  \\left[ - \\sqrt{2}, \\  \\sqrt{2}\\right]\\right)\\)\n\n\n\n11.4.1 Solving a system of linear equations\nConsider the following two equations:\n\\[\n\\begin{align}\n2x + 3y &= 6 \\\\\n3x + 2y &= 12\n\\end{align}\n\\]\nSuppose we want to find the pair of values (x, y) that satisfies both equations. We can use the solve() function to find the solution for a system of equations like this one. First, we define the two symbols and construct the two equations:\n\nx = sp.Symbol('x')\ny = sp.Symbol('y')\nexpr1 = 2*x + 3*y - 6\nexpr2 = 3*x + 2*y - 12\n\nsp.solve((expr1, expr2), dict=True) # Enclose the equations in a tuple\n\n\\(\\displaystyle \\left[ \\left\\{ x : \\frac{24}{5}, \\  y : - \\frac{6}{5}\\right\\}\\right]\\)\n\n\nObserve how we’ve rearranged the expressions so that they both equal zero. Retrieving the solution as a dictionary is beneficial in this scenario because we can verify whether the solution we obtained indeed satisfies the equations:\n\nsol = sp.solve((expr1, expr2), dict=True)\nexpr1.subs({x:sol[0][x], y:sol[0][y]}), expr2.subs({x:sol[0][x], y:sol[0][y]})\n\n\\(\\displaystyle \\left( 0, \\  0\\right)\\)\n\n\nThe output of substituting the values of x and y corresponding to the solution in the two expressions is zero, which confirms that the solution satisfies both equations.\nIf we’re unable to obtain the exact solution, we can still obtain the numerical solution using the nroots() function:\n\nexpr1 = x**3 + 2*x**2 -1\nsp.solve(expr1), sp.nroots(expr1, n=3) # n is the number of digits to calculate\n\n\\(\\displaystyle \\left( \\left[ -1, \\  - \\frac{1}{2} + \\frac{\\sqrt{5}}{2}, \\  - \\frac{\\sqrt{5}}{2} - \\frac{1}{2}\\right], \\  \\left[ -1.62, \\  -1.0, \\  0.618\\right]\\right)\\)"
  },
  {
    "objectID": "13_SymPy.html#plotting-using-sympy",
    "href": "13_SymPy.html#plotting-using-sympy",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.5 Plotting using SymPy",
    "text": "11.5 Plotting using SymPy\nWith SymPy, you can simply provide the equation of the line you wish to plot, and SymPy will create the graph for you. Let’s plot a line whose equation is given by \\(y = 2x + 3\\):\n\nx = sp.Symbol('x')\nsp.plot(2*x+3);\n\n\n\n\n\nThe graph reveals that a default range of x values was automatically selected: −10 to 10. In reality, SymPy employs matplotlib in the background to generate the graphs.\n\nSuppose you wanted to constrain the values of x in the previous graph to lie within the range of −5 to 5. Additionally, we can use other keyword arguments in the plot() function, such as title to specify a title or xlabel and ylabel to label the x-axis and the y-axis, respectively. Here’s how to accomplish this:\n\nsp.plot(2*x + 3, (x, -5, 5), title='A Line', xlabel='x', ylabel='2x+3'); #(symbol, start, end) to specify the range\n\n\n\n\nYou can plot more than one expression on the same graph by providing multiple expressions when calling the SymPy plot() function. Here’s the code:\n\nx = sp.Symbol('x')\np = sp.plot(2*x+3, 3*x+1, legend=True)\np[0].line_color = 'b'\np[1].line_color = 'r'\n\n\n\n\nWe use the plot() function with the equations for the two lines but also pass two additional keyword arguments — legend. By setting the legend argument to True, we add a legend to the graph. p[0] refers to the first line, \\(2x + 3\\), and we set its line_color attribute to 'b', indicating that we want this line to be blue. Similarly, we set the color of the second plot to red using the string 'r'.\nYou can even plot an implicit function using plot_implicit() function. For example, let’s plot the circle \\(x^2 + y^2 = 1\\):\n\nsp.plot_implicit(x**2 + y**2 -1, aspect_ratio=(1,1));\n\n\n\n\n\n11.5.1 Exercise 2: Find all the intersection points between \\(f(x)=4\\cos(3x)\\) and \\(g(x)=x^3\\) using SymPy by first plotting the function and using the graph to narrow down the range of the intersection points. Then, use nsolve() function to find the intersection points.\n\nHint: You may find solve() and nroots() can not be used to solve this problem. In addition, you may need to zoom in around 0 to find all the possible intersection points.\n\n# Your code here"
  },
  {
    "objectID": "13_SymPy.html#calculus-with-sympy",
    "href": "13_SymPy.html#calculus-with-sympy",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.6 Calculus with SymPy",
    "text": "11.6 Calculus with SymPy\n\n11.6.1 Series expansion\nSymPy is also capable of calculating the Taylor series of an expression at a specific point. Utilize series(expr, x, x0, n) to determine the series expansion of expr around the point x = x0 up to O(x^n) (where n is an integer):\n\nsp.series(sp.cos(x), x, 0, 10)\n\n\\(\\displaystyle 1 - \\frac{x^{2}}{2} + \\frac{x^{4}}{24} - \\frac{x^{6}}{720} + \\frac{x^{8}}{40320} + O\\left(x^{10}\\right)\\)\n\n\n\nsp.series(sp.sin(x), x, 0, 10).removeO()\n\n\\(\\displaystyle \\frac{x^{9}}{362880} - \\frac{x^{7}}{5040} + \\frac{x^{5}}{120} - \\frac{x^{3}}{6} + x\\)\n\n\nAdditionally, we can eliminate the O(x^n) term by applying the removeO() method:\n\n\n11.6.2 lambdify()\nThe lambdify() function translates SymPy expressions into Python functions so that they can be evaluated numerically.\n\nexpr = sp.series(sp.cos(x), x, 0, 10).removeO()\nf = sp.utilities.lambdify(x, expr)\nf(0)\n\n\\(\\displaystyle 1.0\\)\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-2*np.pi, 2*np.pi, 100)\nplt.plot(x, f(x));\n\n\n\n\n\n\n11.6.3 Limits\nTo find limits of functions in SymPy, we can create objects of the Limit class as follows:\n\nx = sp.Symbol('x')\nl = sp.Limit(1/x, x, sp.oo) # (function, variable(symbol), limit)\nl\n\n\\(\\displaystyle \\lim_{x \\to \\infty} \\frac{1}{x}\\)\n\n\nThe result is returned as an unevaluated object. To obtain the value of the limit, we can use the doit() method:\n\nl.doit()\n\n\\(\\displaystyle 0\\)\n\n\nBy default, the limit is calculated from a positive direction unless the value at which the limit is to be computed is positive or negative infinity. If the limit is at positive infinity, the direction is negative, and if it is at negative infinity, the direction is positive. We can change the default direction as follows:\n\nsp.Limit(1/x, x, 0).doit(), sp.Limit(1/x, x, 0, dir='+').doit(), sp.Limit(1/x, x, 0, dir='-').doit()\n\n\\(\\displaystyle \\left( \\infty, \\  \\infty, \\  -\\infty\\right)\\)\n\n\nWe can change the default direction of limit calculation using the dir argument. The symbol dir='-' specifies that we are approaching the limit from the negative side. Alternatively, instead of using the Limit class, we can use the limit() function to find the limit of a function directly:\n\nsp.limit(sp.sin(x)/x, x, 0), sp.limit((1+1/x)**x, x, sp.oo)\n\n\\(\\displaystyle \\left( 1, \\  e\\right)\\)\n\n\n\n\n11.6.4 Finding the derivative of functions\nTo find the derivative of a function, we can create an object of Derivative class:\n\nt = sp.Symbol('t')\nSt = 5*t**2 + 2*t + 8\nsp.Derivative(St, t)\n\n\\(\\displaystyle \\frac{d}{d t} \\left(5 t^{2} + 2 t + 8\\right)\\)\n\n\nSimilar to the Limit class, when we create an object of Derivative class, it doesn’t calculate the derivative right away. Instead, we need to call the doit() method on the unevaluated Derivative object to evaluate and obtain the derivative:\n\nd = sp.Derivative(St, t)\nd.doit()\n\n\\(\\displaystyle 10 t + 2\\)\n\n\nIf we want to calculate the value of the derivative at a specific value of \\(t\\) such as \\(t = t_1\\) or \\(t = 1\\), we can use our subs() method:\n\nt1 = sp.Symbol('t1')\nd.doit().subs({t:t1}), d.doit().subs({t:1})\n\n\\(\\displaystyle \\left( 10 t_{1} + 2, \\  12\\right)\\)\n\n\nSimilarly, we can also use the diff() function to find the derivative of a function directly:\n\nsp.diff(St, t)\n\n\\(\\displaystyle 10 t + 2\\)\n\n\nTo calculate higher derivatives, we can provide the third argument to specify the order:\n\nsp.diff(St, t, 2) # Order equals 2\n\n\\(\\displaystyle 10\\)\n\n\n\n\n11.6.5 Finding the integrals of functions\nWe can determine either the indefinite integral (antiderivative) or the definite integral by generating an Integral object:\n\nx = sp.Symbol('x')\nsp.Integral(sp.sin(x), x)\n\n\\(\\displaystyle \\int \\sin{\\left(x \\right)}\\, dx\\)\n\n\nJust as with the Limit and Derivative classes, we can evaluate the integral by employing the doit() method:\n\nsp.Integral(sp.sin(x), x).doit()\n\n\\(\\displaystyle - \\cos{\\left(x \\right)}\\)\n\n\nAdditionally, the integrate() function can be utilized to directly compute the integral of a given function:\n\nsp.integrate(sp.sin(x), x), sp.integrate(sp.log(x), x)\n\n\\(\\displaystyle \\left( - \\cos{\\left(x \\right)}, \\  x \\log{\\left(x \\right)} - x\\right)\\)\n\n\n\nAgain, it’s important to note that we should use the elementary math functions sin() and log() from the SymPy library in the above expression, rather than from alternative libraries such as NumPy.\n\nTo calculate the definite integral, we just need to provide the variable (symbol), the lower limit, and the upper limit as a tuple:\n\n# sp.Integral(sp.sin(x), (x, 0, sp.pi / 2)).doit()\nsp.integrate(sp.sin(x), (x, 0, sp.pi / 2)) # (function, (integration_variable, lower_limit, upper_limit))\n\n\\(\\displaystyle 1\\)\n\n\nImproper integrals are supported as well:\n\nsp.integrate(sp.exp(-x), (x, 0, sp.oo))\n\n\\(\\displaystyle 1\\)"
  },
  {
    "objectID": "13_SymPy.html#linear-algebra-with-sympy",
    "href": "13_SymPy.html#linear-algebra-with-sympy",
    "title": "11  Symbolic Mathematics in Python with SymPy",
    "section": "11.7 Linear algebra with SymPy",
    "text": "11.7 Linear algebra with SymPy\nMatrices can be generated as instances of the Matrix class:\n\na, b, c, x, y, z = sp.symbols('a, b, c, x, y, z')\n\nWhen creating a matrix in SymPy, the syntax resembles that of NumPy: you supply a list of lists, with each list representing a row in the matrix:\n\nm1 = sp.Matrix([[a, b, c], [x, y, z], [a, b, c]])\nm1\n\n\\(\\displaystyle \\left[\\begin{matrix}a & b & c\\\\x & y & z\\\\a & b & c\\end{matrix}\\right]\\)\n\n\nA matrix with a, b, c as diagonal elements can be constructed utilizing the diag() function:\n\nm2 = sp.diag(a,b,c)\nm2\n\n\\(\\displaystyle \\left[\\begin{matrix}a & 0 & 0\\\\0 & b & 0\\\\0 & 0 & c\\end{matrix}\\right]\\)\n\n\nMatrix multiplication can then be performed using the * operator:\n\nm1*m2.T # Instead of using @, we use * to multiply matrices\n\n\\(\\displaystyle \\left[\\begin{matrix}a^{2} & b^{2} & c^{2}\\\\a x & b y & c z\\\\a^{2} & b^{2} & c^{2}\\end{matrix}\\right]\\)\n\n\nScalar multiplication and addition function as anticipated:\n\n3*m1 + m2\n\n\\(\\displaystyle \\left[\\begin{matrix}4 a & 3 b & 3 c\\\\3 x & b + 3 y & 3 z\\\\3 a & 3 b & 4 c\\end{matrix}\\right]\\)\n\n\n\nm1 + 2 # This is not allowed since broadcasting is not directly supported\n\nThe inverse of the matrix can be acquired using the inv() method:\n\nm2.inv()\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{a} & 0 & 0\\\\0 & \\frac{1}{b} & 0\\\\0 & 0 & \\frac{1}{c}\\end{matrix}\\right]\\)\n\n\nThe matrix’s eigenvalues and eigenvectors can be derived using the eigenvals() and eigenvects() methods:\n\nm2.eigenvals(), m2.eigenvects()\n\n\\(\\displaystyle \\left( \\left\\{ a : 1, \\  b : 1, \\  c : 1\\right\\}, \\  \\left[ \\left( a, \\  1, \\  \\left[ \\left[\\begin{matrix}1\\\\0\\\\0\\end{matrix}\\right]\\right]\\right), \\  \\left( b, \\  1, \\  \\left[ \\left[\\begin{matrix}0\\\\1\\\\0\\end{matrix}\\right]\\right]\\right), \\  \\left( c, \\  1, \\  \\left[ \\left[\\begin{matrix}0\\\\0\\\\1\\end{matrix}\\right]\\right]\\right)\\right]\\right)\\)\n\n\nIf you would like more information about the Matrix class and linear algebra with SymPy, refer to the official documentation.\nYou can also explore the Sympy Gamma and SymPy Live websites to learn more about SymPy.\nAll in all, SymPy is a Python library for symbolic mathematics. It aims to provide a computer algebra system that is both easy to use and extensible. Unlike numerical libraries, which focus on approximations and numerical computations, SymPy is designed to perform algebraic manipulations and simplifications symbolically, allowing for exact solutions to mathematical problems.\nSymPy offers a wide range of features, including basic arithmetic operations, algebraic manipulation, calculus, equation solving, linear algebra, and more. It is particularly well-suited for tasks that require manipulation of symbolic expressions or solving equations symbolically."
  },
  {
    "objectID": "00_Copilot.html#get-started-with-github-copilot-in-python",
    "href": "00_Copilot.html#get-started-with-github-copilot-in-python",
    "title": "Appendix A — Increase productivity and learning with Github Copilot in Python",
    "section": "A.1 Get Started With GitHub Copilot in Python",
    "text": "A.1 Get Started With GitHub Copilot in Python\nGitHub Copilot offers a virtual AI-powered assistant integrated into your code editor, creating significant buzz upon its public release. This tool provides exceptional support for languages such as Python.\nGitHub Copilot is the first commercial product based on the OpenAI Codex system, capable of converting natural language into code across more than a dozen programming languages. OpenAI Codex comes from the GPT-3 language learning model. It was taught using both regular text and a vast number of code examples found on GitHub, which has hundreds of millions of public code projects.\n\nA.1.1 Trial or get your free access to GitHub Copilot\nYou can enjoy a thirty-day trial period without paying anything, but only after providing your billing information (Be sure to cancel the unpaid subscription plan before it expires to avoid unwanted charges!).\nStudents can get a free GitHub Copilot subscription. GitHub will verify your status once a year based on proof of academic enrollment, such as a picture of your school ID or an email address in the .edu domain. For detailed instructions on setting up, follow the steps in our notes.\n\n\nA.1.2 Install a Visual Studio Code Extension\nBecause Microsoft owns GitHub, it’s no surprise that their Visual Studio Code editor was the first tool to receive GitHub Copilot support. There are a few ways to install extensions in Visual Studio Code, but the quickest is that you can find the Extensions icon in the Activity Bar located on the left-hand side of the window and try searching for the “GitHub Copilot” and “Github Copilot Labs” extension on the Visual Studio Marketplace.\n\n\n\nAfter the installation is complete, Visual Studio Code will ask you to sign in to GitHub to give it access to your GitHub profile, which your new extension requires. Visual Studio Code needs to know who you are to verify your GitHub Copilot student status.\n\nHowever, granting access to your GitHub profile will allow the editor to read your private repositories. If you change your mind, then you can revoke this authorization at any time by going to your GitHub profile settings and finding GitHub for VS Code in the Authorized OAuth Apps.\n\n\n\nA.1.3 Keyboard shortcut\nTo make working with GitHub Copilot in Visual Studio Code even more productive, here are the most common keyboard shortcuts worth remembering:\n\n\n\n\nAction\nWindows / Linux\nmacOS\n\n\n\n\nTrigger inline suggestions\nAlt+\\\nOption+\\\n\n\nSee the next suggestion\nAlt+]\nOption+]\n\n\nSee the previous suggestion\nAlt+[\nOption+[\n\n\nAccept a suggestion\nTab\nTab\n\n\nDismiss an inline suggestion\nEsc\nEsc\n\n\nShow all suggestions in a new tab\nCtrl+Enter\nCtrl+Enter\n\n\n\n\n\nYou can change the keyboard shortcut by going to File → Preferences → Keyboard Shortcuts or Code → Preferences → Keyboard Shortcuts on macOS.\n\nSometimes GitHub Copilot suggestions may get in your way. If that’s the case, then you can disable them globally or for a particular programming language by clicking on the extension’s icon in the bottom right corner of the editor’s window:\n\n\n\n\nsource: https://realpython.com/github-copilot-python/#install-a-visual-studio-code-extension\n\n\n\nA.1.4 Hand Over the Reins to GitHub Copilot\nNow it’s time to make sure GitHub Copilot is working as expected in either Visual Studio Code. To check if GitHub Copilot is working as expected start writing a sample function signature, such as def hello:\nAs soon as you type the colon (:) at the end of the first line to introduce a new code block, GitHub Copilot fills in the suggested function body for you. Until you either accept it by hitting Tab or reject it with Esc, it’ll show up in gray font. The suggested code calls the print() function to display the Hello World text on the screen in this case. While that wasn’t spectacular, it confirms that GitHub Copilot is working correctly! Now let’s try another function signature such as def add(a, b):\nSure enough, GitHub Copilot gives a very sensible suggestion, which returns the sum of a and b. Notice the difference between returning a value from the function and printing the result on the screen. Your clever virtual assistant can infer the intent from the function’s name and arguments!"
  },
  {
    "objectID": "00_Copilot.html#synthesize-python-code-from-natural-language",
    "href": "00_Copilot.html#synthesize-python-code-from-natural-language",
    "title": "Appendix A — Increase productivity and learning with Github Copilot in Python",
    "section": "A.2 Synthesize Python Code From Natural Language",
    "text": "A.2 Synthesize Python Code From Natural Language\nBecause GitHub Copilot was trained in natural language and curated samples of different programming languages, it’s perfectly possible to explain an abstract problem using plain English or another natural language and expect it to generate the corresponding code in the desired programming language.\n\nThe underlying machine learning model is also capable of doing the opposite — explaining a piece of code in a natural language or even translating one programming language into another, as we will see later on!\n\n\n\n\n\nsource: https://nira.com/github-copilot/\n\n\nA.2.1 Use a Python Comment to Describe the Problem\nComments can sometimes help explain why a certain piece of code looks the way it does. You typically write comments for your future self or your teammates working on the same codebase. When you add GitHub Copilot into the mix, it becomes another target audience who can read your code comments. Consider the following single-line comment in Python, which describes the classic Hello, World! Program:\n# Print \"Hello, World!\"\nAfter typing that comment into your code editor, you’ll notice that GitHub Copilot doesn’t automatically pick it up. When you choose to communicate with it through comments, you must sometimes\n\nOpen the GitHub Copilot side panel or tab to see the suggestions (CTRL+ENTER)\nAlternatively, you may start typing a bit of code to have it auto-completed.\n\nNotice that GitHub Copilot understands that you wish to treat the quoted fragment \"Hello, world!\" of your comment as literal text rather than an instruction!\nApparently, that was too easy for GitHub Copilot. How about raising the bar by requesting a more specific output? For example, you may want to print Hello, World! backward in Chinese.\n# Print \"Hello, World!\" in Chinese in reverse order \nNow, that’s impressive! GitHub Copilot nails it by generating not only correct but also Pythonic code that experienced Pythonistas would write themselves. The suggestions will get even more interesting when you include more comments.\n\n\nA.2.2 Add More Comments to Increase the Problem Complexity\nUsing a single-line comment to describe a problem is fine, but you can only pack so much content in it. Fortunately, it’s possible to combine multiple consecutive comments into a logical and cohesive story that GitHub Copilot will treat as a whole. You can use multiline comments to achieve this:\n\"\"\"\nWrite a program that does the following:\n1.  Create a dictionary called `grades` that maps subject names to lists of grades for each student. Assume that each student has the same number of grades for each subject.\n2.  Create a dictionary called `subject_averages` that maps subject names to their average grades across all students.\n3.  Create a dictionary called `student_totals` that maps student names to their total grades across all subjects.\n4.  Create a variable called `top_student` that contains the name of the student with the highest total grade.\n5.  Print out the top-performing student's name and total grade, as well as the average grade for each subject.\n\"\"\"\n\ngrades = {\n    'Math': [[90, 85, 92, 87, 94], [95, 88, 91, 89, 92], [87, 83, 85, 90, 89]],\n    'Science': [[82, 88, 89, 91, 85], [90, 86, 88, 87, 92], [85, 83, 87, 84, 89]],\n    'English': [[88, 85, 92, 86, 90], [91, 87, 89, 92, 85], [83, 86, 88, 87, 90]],\n}\nIsn’t that amazing? You gave GitHub Copilot a natural language description of a task, and it got the right solution for you.\n\nKeep in mind that the suggestions you’ll might get different results from those presented here. Sometimes it takes trial and error before getting the desired result, so try tweaking your comments a little bit if you’re not getting satisfactory results immediately.\n\nYou can edit the code generated by GitHub Copilot just like your own code. Sometimes, you may not like its formatting, the naming conventions it applied, or a specific fragment of the logic you’d instead rewrite. On other occasions, seeing a suggestion may inspire you to come up with a more clever alternative.\n\n\nA.2.3 Receive Even More Intelligent Code Completion Suggestions\nYou can think of GitHub Copilot as an intelligent code completion mechanism on steroids that understands the context of your project at a deep level, providing the most appropriate suggestions for you. When you work with GitHub Copilot long enough, it may sometimes give you the creepy feeling that it can read your mind. Say that you want to find the roots of the second-degree polynomial, also known as the quadratic function, with three coefficients: a, b, and c:\ndef find_roots(a, b, c):\n\nfind_roots(1, 2, 1)  # Function f(x) = x^2 + 2x + 1\n\n(-1.0,)\n\n\n\nA.2.3.1 Provide Context to Get Better Suggestions\nThe fundamental theorem of algebra states that a degree 𝑛 polynomial with complex coefficients has exactly n complex roots. In other words, a quadratic function, which is a second-degree polynomial, always has exactly two complex roots even when there are none in the real domain. How can you request that GitHub Copilot change the implementation so that you’ll get the complex roots instead of the real ones? You need to add constraints to the problem by giving GitHub Copilot some context to draw from. For example, you may import a module that you wish to be used or write a Python docstring that describes the expected result in natural language:\nimport cmath # For complex numbers\n\ndef find_roots(a, b, c):\n    \"\"\"Return a tuple of complex roots.\"\"\"\n\nfind_roots(1, 0, 1)  # Function f(x) = x^2 + 1\n\nThe solution are -1j and 1j\n\n\n\n\n\nA.2.4 Always Have the API Documentation at Your Fingertips\nSay you wanted to write a small Python function to process the word file. In the traditional approach, you’d start by making a web search for word API. Then, you’d probably get overwhelmed by their guides, quick starts, and reference documentation. Fortunately, you have GitHub Copilot, which has been trained to use well-known APIs, so you can give it a minimal hint about which API to call:\n# Install library that process word file for python\n# Download the word file from 'https://asc.nsysu.edu.tw/var/file/10/1010/img/3362/344961432.docx' using Python\n# Getting the Full Text from a demo.docx File\nExploring new libraries in Python with GitHub Copilot is an enjoyable experience. Perhaps you’re revisiting a framework for which your knowledge has become a little rusty, and you’re struggling to remember where to begin. But even when you’re familiar with a given tool, GitHub Copilot can sometimes surprise you by suggesting more efficient solutions or parts of its API you had no idea about.\nThe name Copilot was a clever choice by GitHub to describe this product. It avoids misleading people into thinking it could take control and replace you as the programmer. You must remember that the code produced by GitHub Copilot isn’t always ideal. It can sometimes be suboptimal or insecure, and it might follow bad programming practices.\n\nIt’s less of a problem when the code contains syntactical errors or if it’s completely nonsensical because that’s easy to spot. However, the code that looks plausible at first glance can still be incorrect and contain logical errors. Therefore, you should never trust GitHub Copilot without carefully reviewing and testing the code it generates!\nIt may make us lazy and discourage us from thinking independently. Like with every powerful tool, you can use GitHub Copilot for right or wrong purposes.\n\nGitHub Copilot is a revolutionary programming aid that can increase your speed and productivity as a software engineer. It saves you time by generating boilerplate code and sparing you from diving into documentation. Because it understands the context of your project, the instant suggestions you get are tailor-made and usually work the way you intended.\n\n\nA.2.5 Exercise 1: Install the pdfplumber, requests and pandas libray. Then download the file from the internet “https://rpb28.nsysu.edu.tw/static/file/183/1183/img/1373/625717409.pdf” using Python. Finally, extract the table from the pdf file and organize it into a table by excluding the first column and newline.\n\n# 1.\n\n\n# 2. \n\n\n# 3. \n\n\n\nA.2.6 Prompt-engineer\nTry\n# Create a list of the first 10 prime numbers\n\n\n\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n\nTry\n# Create a list of the first 10 prime numbers using a list comprehension\n\n\n\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]"
  },
  {
    "objectID": "00_Copilot.html#copilot-labs",
    "href": "00_Copilot.html#copilot-labs",
    "title": "Appendix A — Increase productivity and learning with Github Copilot in Python",
    "section": "A.3 Copilot Labs",
    "text": "A.3 Copilot Labs\nTry the following program from the midterm:\n\ndef isLeapYear(year):\n    # Your code here\n    # Years divisible by 400 are leap years:\n    if ____:\n        return True\n    # Otherwise, years divisible by 100 are not leap years:\n    elif ____:\n        return False\n    # Otherwise, years divisible by 4 are leap years:\n    elif ____:\n        return True\n    # Otherwise, every other year is not a leap year:\n    else:\n        return False\n\n# Use a while loop and isLeapYear() to determine the upcomming year \ndef upcoming_leap_year(current_year):\n    # Your code here\n    ____\n        current_year += 1\n \nassert upcoming_leap_year(2023) == 2024\nassert upcoming_leap_year(1999) == 2000\nassert upcoming_leap_year(2099) == 2104"
  },
  {
    "objectID": "00_SciPy.html#introduction",
    "href": "00_SciPy.html#introduction",
    "title": "Appendix B — High-level scientific computing with SciPy",
    "section": "B.1 Introduction",
    "text": "B.1 Introduction\nServing as the central package for scientific operations in Python, SciPy is specifically designed to work efficiently with NumPy arrays. Before we develop a new routine, it’s advisable to verify if SciPy already offers the required data processing functionality. As non-professional programmers, scientists may sometimes duplicate existing solutions, leading to error-prone, suboptimal, hard-to-share, and unmaintainable code. In contrast, SciPy provides optimized and tested routines, which we should utilize whenever feasible.\nSciPy is composed of task-specific sub-modules:\n\n\n\n\nModule\nFunctionality\n\n\n\n\nscipy.integrate\nIntegration routines\n\n\nscipy.linalg\nLinear algebra routines\n\n\nscipy.optimize\nOptimization\n\n\nscipy.stats\nStatistics\n\n\n\n\nThey all depend on NumPy, but are mostly independent of each other. The standard way of importing these modules is:\n\npackage_name = \"scipy\"\n\ntry:\n    __import__(package_name)\n    print(f\"{package_name} is already installed.\")\nexcept ImportError:\n    print(f\"{package_name} not found. Installing...\")\n    %pip install {package_name}\n\nscipy is already installed.\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom scipy import linalg    # same for other sub-modules\nfrom scipy import integrate # same for other sub-modules\nfrom scipy import optimize  # same for other sub-modules\nfrom scipy import stats     # same for other sub-modules\n\nThe primary SciPy namespace predominantly includes functions that actually belong to NumPy. These functions are exposed for historical reasons, and there’s no need to use import scipy in our code."
  },
  {
    "objectID": "00_SciPy.html#linear-algebra-with-scipy",
    "href": "00_SciPy.html#linear-algebra-with-scipy",
    "title": "Appendix B — High-level scientific computing with SciPy",
    "section": "B.2 Linear algebra with SciPy",
    "text": "B.2 Linear algebra with SciPy\nNumPy provides some tools for handling linear algebra applications within the numpy.linalg module. However, it is typically more advantageous to use scipy.linalg instead, unless you want to avoid adding SciPy as a dependency to your project. There are a few reasons for this preference:\n\nAs the official documentation points out, scipy.linalg encompasses all the functions found in numpy.linalg, along with additional advanced functions not present in numpy.linalg.\nscipy.linalg always includes support for BLAS and LAPACK, which are libraries containing routines for executing numerical operations in an optimized manner. Conversely, the use of BLAS and LAPACK in numpy.linalg is optional. As a result, depending on your NumPy installation, scipy.linalg functions could be faster than those in numpy.linalg.\n\nIn summary, given that scientific and technical applications usually don’t impose limitations on dependencies, opting for scipy.linalg over numpy.linalg is generally a wise decision.\n\nB.2.1 Using scipy.linalg.solve() to solve linear systems\nLinear systems can be valuable tools in finding solutions to various practical and significant problems. A linear system of equations consists of a set of linear equations:\n\\[\\begin{align}\na_{0,0}x_0 + a_{0,1}x_1 + \\cdots + a_{0,n}x_n & = b_0 \\\\\\\na_{1,0}x_0 + a_{1,1}x_1 + \\cdots + a_{1,n}x_n & = b_1 \\\\\\\n& \\vdots \\\\\\\na_{m,0}x_0 + a_{m,1}x_1 + \\cdots + a_{m,n}x_n & = b_m \\\\\\\n\\end{align}\\]a_{1,0}x_0 + a_{1,1}x_1 + + a_{1,n}x_n & = b_1 \\\n& \\\na_{m,0}x_0 + a_{m,1}x_1 + + a_{m,n}x_n & = b_m \\\n\\end{align}\nUsing matrix notation, a linear system can be represented as \\(A \\mathbf{x}= \\mathbf{b}\\), where\n\\[\nA = \\begin{bmatrix}\na_{0,0} & a_{0,1} & \\cdots & a_{0,n} \\\\\\\na_{1,0} & a_{1,1} & \\cdots & a_{1,n} \\\\\\\n\\vdots & & & \\vdots \\\\\\\na_{m,0} & a_{m,1} & \\cdots & a_{m,n} \\\\\\\n\\end{bmatrix}\n\\ \\ , \\ \\\n\\mathbf{x} = \\begin{bmatrix}\nx_0 \\\\\\ x_1 \\\\\\ \\vdots \\\\\\ x_n\n\\end{bmatrix}\n\\ \\ , \\ \\\n\\mathbf{b} = \\begin{bmatrix}\nb_0 \\\\\\ b_1 \\\\\\ \\vdots \\\\\\ b_m\n\\end{bmatrix}\n\\]\nIn this section, you will explore how to leverage scipy.linalg.solve() for solving linear systems. To illustrate its application, consider the example system below:\n\\[\n\\begin{align}\n3x + 2y &= 12 \\\\\n2x - y &= 1\n\\end{align}\n\\]\nTo take advantage of scipy.linalg.solve(), you must first represent the linear system as a matrix product, as demonstrated in the following equation:\n\\[\n\\begin{bmatrix}\n3 & 2 \\\\\n2 & -1\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n12 \\\\\n1\n\\end{bmatrix}\n\\]\nOnce this is done, you can utilize scipy.linalg.solve() to determine the solution to the system:\n\nA = np.array([\n    [3, 2],\n    [2, -1],\n])\n\n# To make it a column vector with two lines\nb = np.array([12, 1]).reshape((2, 1))\n\nx = linalg.solve(A, b)\nx\n\narray([[2.],\n       [3.]])\n\n\nWe can verify that the solution is correct by:\n\nA @ x\n\narray([[12.],\n       [ 1.]])\n\n\nAlternatively, matrix inversion can also be employed to solve the system. We can compute the inverse of matrix \\(A\\) using scipy.linalg.inv() and then multiply it with vector \\(b\\):\n\nA_inv = linalg.inv(A)\nx = A_inv @ b\nx\n\narray([[2.],\n       [3.]])\n\n\nSince this system possesses a unique solution, the determinant of matrix \\(A\\) must be non-zero. You can verify this by calculating the determinant using det() from scipy.linalg:\n\nlinalg.det(A)\n\n-6.999999999999999\n\n\nAs anticipated, the determinant is not zero. This confirms that the inverse of \\(A\\), denoted as \\(A^{-1}\\) and computed using inv(A), does exist, implying that the system possesses a unique solution.\n\nB.2.1.1 Solve or matrix inverse?\nUtilizing the inverse \\(A^{-1}\\) to solve \\(A \\mathbf{x} = \\mathbf{b}\\) is not recommended for large matrices, as it can be computationally expensive. To demonstrate, let’s create a large random matrix \\(A\\) and vector \\(\\mathbf{b}\\), and then compute the solution \\(\\mathbf{x}\\) using two different methods:\n\nN = 10_000\nA = np.random.rand(N,N)\nb = np.random.rand(N,1)\n\nNow we compare the speed of scipy.linalg.solve() with scipy.linalg.inv():\n\n%%timeit\nx = linalg.solve(A,b)\n\n18 s ± 849 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\n%%timeit\nx = linalg.inv(A) @ b\n\n55.3 s ± 1.86 s per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\nSolving with scipy.linalg.solve() is faster!\n\n\n\nB.2.2 Exploring eigenvalues and eigenvectors using scipy.linalg.eig()\nLet \\(A\\) be a square matrix. A non-zero vector \\(\\mathbf{v}\\) is considered an eigenvector for \\(A\\) with eigenvalue \\(\\lambda\\) if\n\\[\nA\\mathbf{v} = \\lambda \\mathbf{v}\n\\]\nBy rearranging the equation, it becomes apparent that \\(\\mathbf{v}\\) is a solution to the homogeneous system of equations\n\\[\n\\left( A - \\lambda I \\right) \\mathbf{v} = \\mathbf{0}\n\\]\nHere, \\(I\\) represents the identity matrix of size \\(n\\). Non-trivial solutions can only exist if the matrix \\(A - \\lambda I\\) is singular, which implies \\(\\mathrm{det}(A - \\lambda I) = 0\\). Consequently, the eigenvalues of \\(A\\) are the roots of the characteristic polynomial\n\\[\np(\\lambda) = \\mathrm{det}(A - \\lambda I)\n\\]\nThe scipy.linalg.eig() function calculates the eigenvalues and eigenvectors of a square matrix \\(A\\). Let’s examine a basic example featuring a diagonal matrix:\n\nA = np.array([[1,0],[0,-2]])\nA\n\narray([[ 1,  0],\n       [ 0, -2]])\n\n\nThe linalg.eig() function returns a tuple (eigvals, eigvecs), where eigvals is a 1D NumPy array containing complex numbers representing the eigenvalues of \\(A\\), and eigvecs is a 2D NumPy array with the corresponding eigenvectors arranged in the columns:\n\neigvals, eigvecs = linalg.eig(A)\neigvals, eigvecs\n\n(array([ 1.+0.j, -2.+0.j]),\n array([[1., 0.],\n        [0., 1.]]))\n\n\nIf we are certain that the eigenvalues are real numbers (i.e., if \\(A\\) is symmetric), we can apply the NumPy array method real() to convert the array of eigenvalues into real numbers:\n\neigvals = eigvals.real\neigvals\n\narray([ 1., -2.])\n\n\nNotice that the position of an eigenvalue in the eigvals array corresponds to the column in eigvecs containing its associated eigenvector:\n\nlambda1 = eigvals[1]\nv1 = eigvecs[:,1].reshape(2,1)\nlambda1, v1\n\n(-2.0,\n array([[0.],\n        [1.]]))\n\n\nWe can verify that the solution is correct:\n\nA @ v1 == lambda1 * v1\n\n(array([[ 0.],\n        [-2.]]),\n array([[-0.],\n        [-2.]]))\n\n\n\nB.2.2.1 Symmetric Matrices\nIndeed, for a symmetric matrix, the eigenvalues are always real and the eigenvectors are always orthogonal. Let’s confirm these properties using some random matrices:\n\nn = 4\nP = np.random.randint(0,10,(n,n))\nP\n\narray([[7, 7, 8, 4],\n       [8, 2, 1, 2],\n       [4, 9, 7, 2],\n       [3, 7, 8, 4]])\n\n\nWe can create symmetric matrix using \\(S = P P^T\\):\n\nS = P @ P.T\nprint(S)\n\n[[178  86 155 150]\n [ 86  73  61  54]\n [155  61 150 139]\n [150  54 139 138]]\n\n\nLet’s unpack the eigenvalues and eigenvectors of \\(S\\):\n\nevals, evecs = linalg.eig(S)\nevals\n\narray([4.85858726e+02+0.j, 4.71560580e+01+0.j, 2.82127092e-01+0.j,\n       5.70308921e+00+0.j])\n\n\nAs observed, the eigenvalues have zero imaginary parts, confirming that they are indeed real numbers. Now, let’s verify that the eigenvectors are orthogonal to one another:\n\nv1 = evecs[:,0] # First column is the first eigenvector\nv2 = evecs[:,1] # Second column is the second eigenvector\n\nv1 @ v2\n\n8.326672684688674e-17\n\n\nThe dot product of eigenvectors \\(\\mathbf{v}_1\\) and \\(\\mathbf{v}_2\\) is zero (the number shown is very close to zero, attributable to rounding errors in the computations), which confirms their orthogonality!\n\n\nB.2.2.2 Diagonalization\nA square matrix \\(M\\) is diagonalizable if there exists an invertible matrix \\(P\\) such that \\(D = P^{-1}MP\\) is a diagonal matrix. A remarkable result in linear algebra states that a square matrix \\(M\\) of size \\(n\\) is diagonalizable if and only if \\(M\\) has \\(n\\) independent eigenvectors. Moreover, \\(M = PDP^{-1}\\), where the columns of \\(P\\) consist of the eigenvectors of \\(M\\) and \\(D\\) has the corresponding eigenvalues along the diagonal.\nUsing this, let’s create a matrix with given eigenvalues \\(\\lambda_1 = 3, \\lambda_2 = 1\\) using np.diag(), and eigenvectors \\(v_1 = [1,1]^T, v_2 = [1,-1]^T\\).\n\nP = np.array([[1,1],[1,-1]])\nD = np.diag((3,1))\nM = P @ D @ linalg.inv(P)\n\nLet’s verify that the eigenvalues of \\(M\\) are 3 and 1:\n\nevals, evecs = linalg.eig(M)\nevals\n\narray([3.+0.j, 1.+0.j])"
  },
  {
    "objectID": "00_SciPy.html#numerical-integration-with-scipy",
    "href": "00_SciPy.html#numerical-integration-with-scipy",
    "title": "Appendix B — High-level scientific computing with SciPy",
    "section": "B.3 Numerical Integration with SciPy",
    "text": "B.3 Numerical Integration with SciPy\n\nB.3.1 Definite integral\nThe definite integral of a function \\(f(x)\\) over an interval \\([a,b]\\) is the limit\n\\[\n\\int_a^b f(x) \\, dx = \\lim_{N \\to \\infty} \\sum_{i=1}^N f(x_i^ * ) (x_i - x_{i-1}) \\ \\ , \\ x_i^* \\in [x_{i-1},x_i]\n\\]\nwhere, for each \\(x_i\\),\n\\[\nx_0 = a &lt; x_1 &lt; \\cdots &lt; x_N = b\n\\]\nis a partition of \\([a,b]\\) with \\(N\\) subintervals, and the values \\(x_i^ * \\in [x_{i-1},x_i]\\) chosen in each subinterval are arbitrary. The definite integral represents the area under the curve of the graph of \\(y=f(x)\\) on the interval \\([a,b]\\).\n\\[\n\\int_a^b f(x) \\, dx = \\text{area under the curve } y = f(x) \\text{ on } [a,b]\n\\]\nNote that the area above the \\(x\\)-axis is considered positive, while the area below the \\(x\\)-axis counts as negative area. For instance, we can visualize the integral:\n\\[\n\\int_{\\pi/2}^{3\\pi/2} \\left( \\sin(0.2 x) + \\sin(2x)\\right) dx\n\\]\n\nf = lambda x: np.sin(0.2*x) + np.sin(2*x)\n\nx = np.linspace(0,2*np.pi,100)\ny = f(x)\nplt.plot(x,y)\n\nX = np.linspace(np.pi/2,3*np.pi/2,100)\nY = f(X)\nplt.fill_between(X, 0, Y, Y &gt; 0, color='blue', alpha=.25)\nplt.fill_between(X, 0, Y, Y &lt; 0, color='red',  alpha=.25)\n\nplt.xticks([np.pi/2,3*np.pi/2],['$\\pi/2$','$3\\pi/2$'])\nplt.xlim([0,2*np.pi]); plt.ylim([-2,3]);\n\n\n\n\nIn this case, the positive area and negative area are represented by blue and red colors, respectively. We can calculate the area using scipy.integrate.quad():\n\nintegrate.quad(f, np.pi, np.pi*3/2) # quad(f, a, b)\n\n(2.106158710412371, 2.3383058938146415e-14)\n\n\nThe second item in the above tuple is the error. In introductory calculus courses, we typically concentrate on integrals that can be solved exactly using the Fundamental Theorem of Calculus, such as:\n\\[\n\\int_0^{\\pi/2} \\cos(x) \\, dx = \\sin(\\pi/2) - \\sin(0) = 1\n\\]\nThis result can be verified as follows:\n\nf = lambda x: np.cos(x)\n\nintegrate.quad(f, 0, np.pi/2) # quad(f, a, b)\n\n(0.9999999999999999, 1.1102230246251564e-14)\n\n\nNevertheless, most definite integrals cannot be solved exactly. For instance, the well-known error function in probability\n\\[\n\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt\n\\]\nis a definite integral for which there is no explicit formula. In such cases, we can still compute the integral value using numerical integration:\n\nf = lambda x: 2/np.pi**(0.5)*np.exp(-x**2)\n\nintegrate.quad(f, 0, 1.96) # quad(f, a, b)\n\n(0.9944262754648279, 1.1040349473132902e-14)\n\n\nIf you’re interested in performing numerical differentiation, you can refer to the following libraries:\n\nFindiff: https://github.com/maroba/findiff\nNumdifftools: https://github.com/pbrod/numdifftools"
  },
  {
    "objectID": "00_SciPy.html#optimization",
    "href": "00_SciPy.html#optimization",
    "title": "Appendix B — High-level scientific computing with SciPy",
    "section": "B.4 Optimization",
    "text": "B.4 Optimization\nOptimization is the process of finding a numerical solution to a minimization or equality problem. The scipy.optimize module offers algorithms for function minimization (scalar or multi-dimensional), curve fitting, and root finding.\nWhen optimizing input parameters for a function, scipy.optimize offers various helpful methods suitable for different types of functions:\n\ncurve_fit() for fitting a function to a set of data\nminimize() for minimizing a function of one variable or multiple variables\nroot() for finding the zeros of a function of one variable or multiple variables\n\nIn practice, all of these functions perform optimization in some form. The distinction lies in the type of function being optimized and the constraints applied to the optimization process.\n\nB.4.1 Curve fitting\nSuppose we have data on a sine wave, with some noise:\n\nx_data = np.linspace(-5, 5, num=50)\ny_data = 2.9 * np.sin(1.5 * x_data) + np.random.normal(size=50)\nplt.scatter(x_data, y_data)\n\n&lt;matplotlib.collections.PathCollection at 0x7f0fe5904370&gt;\n\n\n\n\n\nIf we have data that we know follows a sine wave but are unsure of the amplitudes or the period, we can determine those values using least squares curve fitting. To begin, we need to define the test function to fit. In this case, it’s a sine function with unknown amplitude and period:\n\ndef test_func(x, a, b):\n    return a * np.sin(b * x)\n\nWe then use scipy.optimize.curve_fit() to find a and b:\n\nparams, params_covariance = optimize.curve_fit(test_func, x_data, y_data, p0=[2,2])\n\n\nplt.figure(figsize=(6, 4))\nplt.scatter(x_data, y_data, label='Data')\nplt.plot(x_data, test_func(x_data, params[0], params[1]),\n         label='Fitted function')\n\nplt.legend(loc='best')\n\n&lt;matplotlib.legend.Legend at 0x7f0fe59335e0&gt;\n\n\n\n\n\n\n\nB.4.2 Finding the minimum of a scalar function\nscipy.optimize also features the more versatile minimize() function. This function is capable of handling multivariate inputs and outputs and employs more advanced optimization algorithms to manage this complexity. Additionally, minimize() can accommodate constraints on the solution to your problem. Let’s explore a simple example to demonstrate its functionality:\n\nf = lambda x: x**2 + 10*np.sin(x)\n\n\nx = np.arange(-10, 10, 0.1)\nplt.plot(x, f(x)) \nplt.show() \n\n\n\n\nThis function has a global minimum around -1.3 and a local minimum around 3.8. To search for the minimum, you can use scipy.optimize.minimize(). By providing a starting point x0, the function returns the location of the minimum it has discovered:\n\nresult = optimize.minimize(f, x0=0)\nxmin_global = result.x\nresult, type(result)\n\n(  message: Optimization terminated successfully.\n   success: True\n    status: 0\n       fun: -7.945823375615215\n         x: [-1.306e+00]\n       nit: 5\n       jac: [-1.192e-06]\n  hess_inv: [[ 8.589e-02]]\n      nfev: 12\n      njev: 6,\n scipy.optimize._optimize.OptimizeResult)\n\n\nThe output of minimize() is an instance of the OptimizeResult class. This class gathers various relevant details from the optimizer’s run, including information on whether the optimization was successful or not. In this case, it finds the global minimum.\nA potential issue with this approach is that if the function has local minima, the algorithm might find one of these local minima instead of the global minimum, depending on the choice of the initial point x0. This is because many optimization algorithms are sensitive to the starting point and can get trapped in local minima, preventing them from reaching the global minimum. For instance, let’s try to set x0 to 3:\n\nres = optimize.minimize(f, x0=3)\nxmin_local = res.x\nxmin_local\n\narray([3.83746709])\n\n\nIn this case, it finds the local minimum. Besides the starting point x0, we can constrain the variable to the interval (0, 10) using the bounds argument:\n\nres = optimize.minimize(f, x0=1, bounds=((0,10),))\nres\n\n  message: CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL\n  success: True\n   status: 0\n      fun: 0.0\n        x: [ 0.000e+00]\n      nit: 1\n      jac: [ 1.000e+01]\n     nfev: 4\n     njev: 2\n hess_inv: &lt;1x1 LbfgsInvHessProduct with dtype=float64&gt;\n\n\nIf the optimization was successful, then fun is the value of the objective function at the optimal value x. We can see from the output that, as expected, the minimum value at this range is x = 0.\nAs we may know, not every function has a minimum. For instance, if our objective function is \\(y = x^3\\), it will result in a Desired error not necessarily achieved due to precision loss because the optimizer eventually tries a number that is too big to be calculated by the computer.\n\nf1 = lambda x: x**3\noptimize.minimize(f1, x0=-3)\n\n  message: Desired error not necessarily achieved due to precision loss.\n  success: False\n   status: 2\n      fun: -1115932097.8874247\n        x: [-1.037e+03]\n      nit: 1\n      jac: [ 3.228e+06]\n hess_inv: [[-3.204e-04]]\n     nfev: 236\n     njev: 112\n\n\n\n\nB.4.3 Finding the roots of a scalar function\nTo find a root, that is, a point where \\(f(x) = 0\\), of the function \\(f\\) mentioned earlier, we can utilize scipy.optimize.root():\n\nroot = optimize.root(f, x0=1)  # our initial guess is 1\nroot\n\n message: The solution converged.\n success: True\n  status: 1\n     fun: [ 0.000e+00]\n       x: [ 0.000e+00]\n    nfev: 10\n    fjac: [[-1.000e+00]]\n       r: [-1.000e+01]\n     qtf: [ 1.333e-32]\n\n\nKeep in mind that only one root is discovered. Examining the plot of \\(f\\) indicates that there is a second root around -2.5. We can determine the exact value of this root by modifying our initial estimate:\n\nroot2 = optimize.root(f, x0=-2)\nroot2.x\n\narray([-2.47948183])\n\n\nThe following figure displays the roots and minimum we have identified up to this point:\n\nfig = plt.figure(figsize=(6, 4))\nax = fig.add_subplot(111)\n\n# Plot the function\nax.plot(x, f(x), 'b-', label=\"f(x)\")\n\n# Plot the minima\nxmins = np.array([xmin_global[0], xmin_local[0]])\nax.plot(xmins, f(xmins), 'go', label=\"Minima\")\n\n# Plot the roots\nroots = np.array([root.x, root2.x])\nax.plot(roots, f(roots), 'kv', label=\"Roots\")\n\n# Decorate the figure\nax.legend(loc='best')\nax.set_xlabel('x')\nax.set_ylabel('f(x)')\nax.axhline(0, color='gray')\nplt.show()"
  },
  {
    "objectID": "00_SciPy.html#statistics",
    "href": "00_SciPy.html#statistics",
    "title": "Appendix B — High-level scientific computing with SciPy",
    "section": "B.5 Statistics",
    "text": "B.5 Statistics\nThe scipy.stats module encompasses statistical tools and probabilistic representations of random processes.\n\nB.5.1 Distributions: histogram and probability density function\nGiven observations of a random variable that adheres to a normal distribution:\n\nsamples = np.random.normal(size=1000)\nbins = np.arange(-4, 5)\nbins\n\narray([-4, -3, -2, -1,  0,  1,  2,  3,  4])\n\n\nThe histogram of these observations serves as an estimator of the random process’s PDF (probability density function):\n\nhistogram = np.histogram(samples, bins=bins, density=True)[0]\nbins = 0.5*(bins[1:] + bins[:-1])\nbins\n\narray([-3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,  3.5])\n\n\nWe can overlap the estimation with the actual PDF calculated using scipy.stats.norm():\n\npdf = stats.norm.pdf(bins)  # norm is a distribution object\nplt.plot(bins, histogram, label=\"Histogram of samples\")\nplt.plot(bins, pdf, label=\"PDF\")\nplt.legend();\n\n\n\n\nWe can see that the estimate using histogram is quite close to the true PDF.\n\n\nB.5.2 Hypothesis testing\nA statistical test is a decision indicator. For instance, if we have two sets of observations, that we assume are generated from Gaussian processes:\n\n# Generates 2 sets of observations\nsamples1 = np.random.normal(0, size=50)\nsamples2 = np.random.normal(1, size=50)\n\n# Compute a histogram of the sample\nbins = np.linspace(-4, 4, 30)\nhistogram1, bins = np.histogram(samples1, bins=bins, density=True)\nhistogram2, bins = np.histogram(samples2, bins=bins, density=True)\n\nplt.figure(figsize=(6, 4))\nplt.hist(samples1, bins=bins, density=True, label=\"Samples 1\")\nplt.hist(samples2, bins=bins, density=True, label=\"Samples 2\")\nplt.legend(loc='best')\n\n&lt;matplotlib.legend.Legend at 0x7f0fe5b07df0&gt;\n\n\n\n\n\nWe can use a T-test using scipy.stats.ttest_ind() to decide whether the means of two sets of observations are significantly different:\n\nstats.ttest_ind(samples1, samples2)\n\nTtest_indResult(statistic=-4.547017710744573, pvalue=1.5576418947888603e-05)\n\n\nThe resulting output is composed of: - The T statistic value: it is a number the sign of which is proportional to the difference between the two random processes and the magnitude is related to the significance of this difference. - The p value: the probability of both processes being identical. If it is close to 1, the two process are almost certainly identical. The closer it is to zero, the more likely it is that the processes have different means.\nFor the above test, we can reject the null hypotheis that these two samples have the same mean.\nAll in all, SciPy is an open-source library designed for scientific computing in Python. It builds upon the core functionality provided by the NumPy and offers a comprehensive suite of additional tools for various scientific domains, including linear algebra, optimization, statistics and more. SciPy is widely used in research, education, and industry for applications in fields like physics, engineering, and data science. Its extensive documentation, active community, and frequent updates make it an essential tool for anyone working with numerical computations in Python."
  },
  {
    "objectID": "04_Algorithms_sol.html#a-taste-of-algorithm",
    "href": "04_Algorithms_sol.html#a-taste-of-algorithm",
    "title": "Appendix C — Algorithms",
    "section": "C.1 A taste of algorithm",
    "text": "C.1 A taste of algorithm\nAn informal definition of an algorithm is:\n\nAlgorithm: a step-by-step method for solving a problem or doing a task.\n\nIn this definition, an algorithm is independent of the computer system. More specifically, we should also note that the algorithm accepts input data and creates output data\n\n\n\nLet us elaborate on this simple definition with an example. We want to develop an algorithm for finding the largest integer among a list of positive integers. It is obvious that finding the largest integer among many integers is a task that cannot be done in one step. The algorithm needs to test each integer one by one.\nTo solve this problem, we need an intuitive approach. First use a small number of integers (for example, five), then extend the solution to any number of integers. Assume that the algorithm handles the integers one by one. It looks at the first integer without knowing the values of the remaining integers. After it handles the first one, it looks at the second integer, and so on.\n\n\n\nThe above figure does not show what should be done in each step. We can modify the figure to show more details.\n\n\n\nThere are two problems for the above figure to become an algorithm that can be programmed. First, the action in the first step is different than those for the other steps. Second, the wording is not the same in steps 2 to 5. The reason that the first step is different than the other steps is because Largest is not initialized! If we initialize Largest to \\(-∞\\), then the first step can be the same as the other steps!\n\n\n\nIs it possible to generalize the algorithm? We want to find the largest of n positive integers, where n can be 1000, 1000000, or more. We can tell the computer to repeat the steps n times!"
  },
  {
    "objectID": "04_Algorithms_sol.html#algorithm-representations",
    "href": "04_Algorithms_sol.html#algorithm-representations",
    "title": "Appendix C — Algorithms",
    "section": "C.2 Algorithm representations",
    "text": "C.2 Algorithm representations\nComputer scientists have defined three constructs for a structured program or algorithm. The idea is that a program must be made of a combination of only these three constructs: sequence, decision, and repetition.\n\nIt has been proven there is no need for any other constructs!\n\n\n\n\n\nx = 150\nif x%2 == 0:\n  print('x is even')\nelse:\n  print('x is odd')\n\nx is even\n\n\n\nn = 0\nwhile (n &lt; 10):\n  print(n)\n  n = n + 1\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nC.2.1 Example 1: Write an algorithm that finds the sum of two integers.\nThis is a simple problem that can be solved using only the sequence construct. Note also that we name the algorithm, define the input to the algorithm and, at the end, we use a return instruction to return the sum\n\ndef SumOfTwo(first, second):\n  \"\"\"\n    Parameters\n    ----------\n    first: int\n        The first integer\n    second: int\n        The second integer\n    Returns\n    -------\n    sum : int\n        The sum of two integers\n  \"\"\"\n  # Your code here\n  sum = first + second\n  return sum\n\n\nassert(SumOfTwo(3,5)==8)\nassert(SumOfTwo(-7,-3)==-10)\n\n\n\nC.2.2 Example 2: Write an algorithm to change a numeric grade to a pass/no pass grade.\nThis problem cannot be solved with only the sequence construct. We also need the decision construct. The computer is given an integer between 0 and 100. It returns ‘pass’ if the integer is greater than or equal to 70, and returns ‘no pass’ if the integer is less than 60.\n\ndef Pass_NoPass(score):\n  \"\"\"\n    Parameters\n    ----------\n    score: int\n        The score to be changed to grade\n    Returns\n    -------\n    grade : str\n        The grade\n  \"\"\"\n  # Your code here\n  if score &gt;= 60:\n    grade = \"pass\"\n  else:\n    grade = \"nopass\"\n  return grade\n\n\nassert(Pass_NoPass(90)==\"pass\")\nassert(Pass_NoPass(55)==\"nopass\")\n\n\n\nC.2.3 Example 3: Write an algorithm to find the largest of a set of integers. We do not know the number of integers.\nWe use the concept before to write an algorithm for this problem\n\nimport math\n\ndef FindLargest(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: list\n        The input list that contains integers\n    Returns\n    -------\n    largest : int\n        The largest integer\n  \"\"\"\n  # Your code here\n  largest = - math.inf\n  for current in ilist:\n    if current &gt; largest:\n      largest = current\n    else:\n      pass\n  return largest\n\n\nassert(FindLargest([])==-math.inf)\nassert(FindLargest([7,3,5,10])==10)\nassert(FindLargest([-7,-2,5,18])==18)\n\n\nC.2.4 Exercise 1: Write an algorithm to find the smallest of the first 5 integers in a set of integers.\n\nHere we need a counter to count the number of integers.\n\ndef FindSmallest(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: list\n        The input list that contains integers\n    Returns\n    -------\n    largest : int\n        The smallest integer of the first 5 integers in the list\n  \"\"\"\n  # Your code here\n  smallest = math.inf\n  if len(ilist) != 0:\n    counter = 0\n    while(counter&lt;5):\n      if ilist[counter] &lt; smallest:\n        smallest = ilist[counter]\n      counter = counter +1\n  return smallest\n\n\nassert(FindSmallest([])== math.inf)\nassert(FindSmallest([7,3,5,10,6])==3)\nassert(FindSmallest([7,4,5,10,6,1])==4)"
  },
  {
    "objectID": "04_Algorithms_sol.html#a-more-formal-definition",
    "href": "04_Algorithms_sol.html#a-more-formal-definition",
    "title": "Appendix C — Algorithms",
    "section": "C.3 A more formal definition",
    "text": "C.3 A more formal definition\nNow that we have discussed the concept of an algorithm and shown its representation, here is a more formal definition.\n\nAlgorithm: An ordered set of unambiguous steps that produces a result and terminates in a finite time.\n\n\nWell-Defined: An algorithm must be a well-defined, ordered set of instructions.\nUnambiguous steps: Each step in an algorithm must be clearly and unambiguously defined. If one step is to add two integers, we must define both ‘integers’ as well as the ‘add’ operation\nProduce a result: An algorithm must produce a result, otherwise it is useless. The result can be data returned to the calling algorithm, or some other effect (for example, printing).\nTerminate in a finite time: An algorithm must terminate (halt). If it does not (that is, it has an infinite loop), we have not created an algorithm."
  },
  {
    "objectID": "04_Algorithms_sol.html#basic-algorithms",
    "href": "04_Algorithms_sol.html#basic-algorithms",
    "title": "Appendix C — Algorithms",
    "section": "C.4 Basic algorithms",
    "text": "C.4 Basic algorithms\nSeveral algorithms are used in computer science so prevalently that they are considered ‘basic’.\n\nC.4.0.1 Summation\nOne commonly used algorithm in computer science is summation. The solution is simple: we use the add operator in a loop\n\n\n\n\ndef summation(numbers):\n  \"\"\"\n    Parameters\n    ----------\n    numbers: list\n        The input list.\n    Returns\n    -------\n    sum : int\n        The summation of the input list, if the input is empty please return None\n  \"\"\"\n  # Your code here\n  # Special case: If the numbers list is empty, return None:\n  if len(numbers) == 0:\n    return None\n\n  # Start the total at 0:\n  sum = 0\n\n  # Loop over each number in numbers:\n  for current in numbers:\n    # Add the number to the total:\n    sum += current\n\n  return sum\n\n\nassert summation([1, 2, 3]) == sum([1, 2, 3])\nassert summation([12, 20, 37]) == sum([12, 20, 37])\nassert summation([]) == None\n\n\n\nC.4.0.2 Product\nAnother common algorithm is finding the product of a list of integers.\n\n\n\n\ndef product(numbers):\n  \"\"\"\n    Parameters\n    ----------\n    numbers: list\n        The input list.\n    Returns\n    -------\n    product : int\n        The product of the input list, if the input is empty please return None\n  \"\"\"\n  # Special case: If the numbers list is empty, return None:\n  if len(numbers) == 0:\n    return None\n\n  # Your code here\n  product = 1\n\n  # Loop over each number in numbers:\n  for current in numbers:\n    # Multiply the number to the total:\n    product *= current\n\n  return product\n\n\n# For Python 3.8 or later\nassert product([1, 2, 3]) == math.prod([1, 2, 3])\nassert product([12, 20, 37]) == math.prod([12, 20, 37])\nassert product([]) == None\n\n\n# For Python 3.7 or earlier\nimport numpy as np\nassert product([1, 2, 3]) == np.prod([1, 2, 3])\nassert product([12, 20, 37]) == np.prod([12, 20, 37])\nassert product([]) == None\n\n\n\nC.4.0.3 Smallest and largest"
  },
  {
    "objectID": "04_Algorithms_sol.html#sorting",
    "href": "04_Algorithms_sol.html#sorting",
    "title": "Appendix C — Algorithms",
    "section": "C.5 Sorting",
    "text": "C.5 Sorting\nOne of the most common applications in computer science is sorting, which is the process by which data is arranged according to its values. People are surrounded by data. If the data was not ordered, it would take hours and hours to find a single piece of information. Imagine the difficulty of finding someone’s telephone number in a telephone book that is not ordered!\n\nC.5.1 Selection sorts\nIn a selection sort, the list to be sorted is divided into two sublists — sorted and unsorted— which are separated by an imaginary wall. We find the smallest element from the unsorted sublist and swap it with the element at the beginning of the unsorted sublist. After each selection and swap, the imaginary wall between the two sublists moves one element ahead, increasing the number of sorted elements and decreasing the number of unsorted ones. Each time we move one element from the unsorted sublist to the sorted sublist, we have completed a sort pass.\nA list of n elements requires n  − 1 passes to completely rearrange the data.\n\n\n\nThe visualization is as follows:\n\n\n\nThe figure shows how the wall between the sorted and unsorted sublists moves in each pass. As we study the figure, we will see that the list is sorted after five passes, which is one less than the number of elements in the list. Thus, if we use a loop to control the sorting, the loop will have one less iteration than the number of elements to be sorted.\n\n\n\n\nsource: https://github.com/hustcc/JS-Sorting-Algorithm\n\nRefer to https://visualgo.net/en/sorting for more visualization of sorting algorithms.\n\n\n\nThe algorithm uses two loops, one inside the other. The outer loop is iterated for each pass: the inner loop finds the smallest element in the unsorted list.\n\nC.5.2 Exercise 2: Write a selection sort for list of intergers that sorts the integer from smallest to largest\n\n\ndef selection_sort(arr):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    Returns\n    -------\n    arr : list\n        The sorted list\n  \"\"\"\n  n = len(arr)\n  ## Move the wall one element to the right\n  for wall in range(n-1):\n    ## Place the wall at the leftmost of the list\n    min_index = wall\n    ## Find smallest element in the unsorted list\n    for cur in range(min_index+1,n):\n      if arr[cur] &lt; arr[min_index]:\n        min_index = cur\n    ## Swap smallest element with first element in the unsorted list\n    arr[wall], arr[min_index] = arr[min_index], arr[wall]\n  return arr\n\n\nassert(selection_sort([89,78,61,53,23,21,17,12,9,7,6,2,1])==sorted([89,78,61,53,23,21,17,12,9,7,6,2,1]))\nassert(selection_sort([1,5,8,9])==sorted([1,5,8,9]))\nassert(selection_sort([78,12,15,8,61,53,23,27])==sorted([78,12,15,8,61,53,23,27]))\nassert(selection_sort([5])==sorted([5]))\n\n\n\nC.5.3 Bubble sort\nIn the bubble sort method, the list to be sorted is also divided into two sublists—sorted and unsorted. The smallest element is bubbled up from the unsorted sublist and moved to the sorted sublist. After the smallest element has been moved to the sorted list, the wall moves one element ahead, increasing the number of sorted elements and decreasing the number of unsorted ones.\nEach time an element moves from the unsorted sublist to the sorted sublist, one sort pass is completed. Given a list of n elements, bubble sort requires up to n − 1 passes to sort the data.\n\n\n\nThe following shows how the wall moves one element in each pass. Looking at the first pass, we start with 56 and compare it to 32. Since 56 is not less than 32, it is not moved, and we step down one element. No exchanges take place until we compare 45 to 8. Since 8 is less than 45, the two elements are exchanged, and we step down one element. Because 8 was moved down, it is now compared to 78, and these two elements are exchanged. Finally, 8 is compared to 23 and exchanged. This series of exchanges places 8 in the first location, and the wall is moved up one position. The algorithm gets its name from the way in which numbers — in this example, 8 — appear to move to the start, or top, of the list in the same way that bubbles rise through water.\n\n\n\n\n\n\n\nsource: https://github.com/hustcc/JS-Sorting-Algorithm\n\n\n\n\n\nC.5.4 Exercise 3: Write a bubble sort for list of intergers that sorts the integer from smallest to largest\n\n\ndef bubble_sort(arr):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    Returns\n    -------\n    arr : list\n        The sorted list\n  \"\"\"\n  n = len(arr)\n  ## Move the wall one element to the right\n  for wall in range(n-1):\n    #swapped = False\n    ## bubble each element up to the left\n    for j in range(n-1, wall, -1):\n      if arr[j] &lt; arr[j-1]:\n        arr[j], arr[j-1] = arr[j-1], arr[j]\n        #swapped = True\n  return arr\n\n\nassert(bubble_sort([89,78,61,53,23,21,17,12,9,7,6,2,1])==sorted([89,78,61,53,23,21,17,12,9,7,6,2,1]))\nassert(bubble_sort([1,5,8,9])==sorted([1,5,8,9]))\nassert(bubble_sort([78,12,15,8,61,53,23,27])==sorted([78,12,15,8,61,53,23,27]))\nassert(bubble_sort([5])==sorted([5]))\n\n\n\nC.5.5 Insertion sort\nThe insertion sort algorithm is one of the most common sorting techniques, and it is often used by card players. Each card a player picks up is inserted into the proper place in their hand of cards to maintain a particular sequence. (Card sorting is an example of a sort that uses two criteria for sorting: suit and rank.)\nIn an insertion sort, as in the other two sorting algorithms discussed above, the list is divided into two parts—sorted and unsorted. In each pass, the first element of the unsorted sublist is transferred to the sorted sublist and inserted at the appropriate place. Note that a list of n elements will take n − 1 passes to sort the data.\n\n\n\n\n\n\nAs you can perceive from the above figure, the wall moves with each pass as an element is removed from the unsorted sublist and inserted into the sorted sublist.\n\n\n\n\nsource: https://github.com/hustcc/JS-Sorting-Algorithm\n\nThe design of insertion sort follows the same pattern seen in both selection sort and bubble sort. The outer loop is iterated for each pass, and the inner loop finds the position of insertion.\n\n\n\n\nC.5.6 Exercise 4: Write a insertion sort for list of intergers that sorts the integer from smallest to largest\n\n\ndef insertion_sort(arr):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    Returns\n    -------\n    arr : list\n        The sorted list\n  \"\"\"\n  n = len(arr)\n  ## Move the wall one element to the right\n  for wall in range(1,n):\n    temp = arr[wall]\n    cur =  wall -1\n    while arr[cur] &gt; temp and cur &gt;= 0:\n      arr[cur+1] = arr[cur]\n      cur = cur -1 \n    arr[cur+1] = temp\n  return arr\n\n\nassert(insertion_sort([89,78,61,53,23,21,17,12,9,7,6,2,1])==sorted([89,78,61,53,23,21,17,12,9,7,6,2,1]))\nassert(insertion_sort([1,5,8,9])==sorted([1,5,8,9]))\nassert(insertion_sort([78,12,15,8,61,53,23,27])==sorted([78,12,15,8,61,53,23,27]))\nassert(insertion_sort([5])==sorted([5]))\n\nThe three sorting algorithms discussed here are the least efficient sorting algorithms, and should not be used if the list to be sorted has more than a few hundred elements. There are however several reasons for discussing these sorting algorithms in an introductory book:\n\nThey are the simplest algorithms to understand and analyze.\nThey are the foundation of more efficient algorithms such as quicksort, heap sort, Shell sort, bucket sort, merge sort, radix sort, and so on.\n\nMost such advanced sorting algorithms are discussed in books on data structures. You may ask why there are so many sorting algorithms. The reason lies in the type of data that needs to be sorted. One algorithm may be more efficient for a list that is partially sorted, whereas another algorithm may be more efficient for a list that is completely unsorted.\nSee https://www.sortvisualizer.com/ for more details"
  },
  {
    "objectID": "04_Algorithms_sol.html#searching",
    "href": "04_Algorithms_sol.html#searching",
    "title": "Appendix C — Algorithms",
    "section": "C.6 Searching",
    "text": "C.6 Searching\nAnother common algorithm in computer science is searching, which is the process of finding the location of a target among a list of objects. In the case of a list, searching means that given a value, we want to find the location of the first element in the list that contains that value. There are two basic searches for lists: sequential search and binary search. Sequential search can be used to locate an item in any list, whereas binary search requires the list first to be sorted.\n\nC.6.1 Sequential search\nSequential search is used if the list to be searched is not ordered. Generally, we use this technique only for small lists, or lists that are not searched often. In other cases, the best approach is to first sort the list and then search it using the binary search discussed later.\nIn a sequential search, we start searching for the target from the beginning of the list. We continue until we either find the target or reach the end of the list. The following figure traces the steps to find the value 62. The search algorithm needs to be designed so that the search stops when we find the target or when we reach the end of the list.\n\n\n\n\nC.6.2 Exercise 5: Write a sequential search for a list of intergers that return the index of the target value. Note that we should return None if the target does not in the list!\n\n\ndef sequential_search(arr, target):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The unsorted input list that contains integers\n    target: int\n        The target we are trying to search\n    Returns\n    -------\n    location : int\n        The location or index of the target. Return None if it does not contain the target \n  \"\"\"\n  location = 0\n  while location &lt; len(arr) and arr[location] != target:\n    location += 1\n\n  if location == len(arr):\n    return None\n  return location\n\n\nassert(sequential_search([0,5,7,10,15], 0)==[0,5,7,10,15].index(0))\nassert(sequential_search([0,3,10,15,7], 15)==[0,3,10,15,7].index(15))\nassert(sequential_search([0,3,10,15,7], 7)==[0,3,10,15,7].index(7))\nassert(sequential_search([0,3,10,15,7], 6)==None)\n\n\n\nC.6.3 Binary search\nThe sequential search algorithm is very slow. If we have a list of a million elements, we must do a million comparisons in the worst case. If the list is not sorted, this is the only solution. If the list is sorted, however, we can use a more efficient algorithm called binary search. Generally speaking, programmers use a binary search when a list is large.\nA binary search starts by testing the data in the element at the middle of the list. This determines whether the target is in the first half or the second half of the list. If it is in the first half, there is no need to further check the second half. If it is in the second half, there is no need to further check the first half. In other words, we eliminate half the list from further consideration.\nWe repeat this process until we either find the target or satisfy ourselves that it is not in the list. The following figure shows how to find the target, 22, in a list of 12 numbers using three references: first, mid, and last.\n\nAt the beginning, first shows 1 and last shows 12. Let mid show the middle position, (1 + 12)/ 2, or 6 if truncated to an integer. Now compare the target (22) with data at position 6 (21). The target is greater than this value, so we ignore the first half of the list.\nMove first after mid, to position 7. Let mid show the middle of the second half, (7  +  12) / 2, or 9. Now compare the target (22) with data at position 9 (62). The target is smaller than this value, so we ignore the integers from this value (62) to the end.\nMove last before mid to position 8. Recalculate mid again, (8 + 7) / 2, or 7. Compare the target (22) with the value at this position (22). We have found the target and can quit.\n\n\n\n\nThe algorithm for binary search needs to be designed to find the target or to stop if the target is not in the list. It can be shown that if the target is not found in the list, the value of last becomes smaller than the value of first, an abnormal condition that helps us to know when to come out of the loop.\n\nC.6.4 Exercise 6: Write a binary search for a sorted list of intergers that return the index of the target value. Note that we should return None if the target does not in the list!\n\n\ndef binary_search(arr, target):\n  \"\"\"\n    Parameters\n    ----------\n    arr: list\n        The sorted input list that contains integers\n    target: int\n        The target we are trying to search\n    Returns\n    -------\n    location : int\n        The location or index of the target. Return None if it does not contain the target \n  \"\"\"\n  first, last = 0, len(arr) - 1\n  while first &lt;= last:\n    mid = (first + last) // 2\n    val = arr[mid]\n    if val == target:\n      return mid\n    if val &lt; target:\n      first = mid + 1\n    else:\n      last = mid - 1\n  return None\n\n\nassert(binary_search(sorted([0,5,7,10,15]), 0)==sorted([0,5,7,10,15]).index(0))\nassert(binary_search(sorted([0,3,10,15,7]), 15)==sorted([0,3,10,15,7]).index(15))\nassert(binary_search(sorted([0,3,10,15,7]), 7)==sorted([0,3,10,15,7]).index(7))\nassert(binary_search(sorted([0,3,10,15,7]), 6)==None)"
  },
  {
    "objectID": "04_Algorithms_sol.html#recursion",
    "href": "04_Algorithms_sol.html#recursion",
    "title": "Appendix C — Algorithms",
    "section": "C.7 Recursion",
    "text": "C.7 Recursion\nIn general, there are two approaches to writing algorithms for solving a problem. One uses iteration, the other uses recursion. Recursion is a process in which an algorithm calls itself.\n\nC.7.1 Iterative\nTo study a simple example, consider the calculation of a factorial. The factorial of a integer is the product of the integral values from 1 to the integer. The definition is iterative as shown below. An algorithm is iterative whenever the definition does not involve the algorithm itself.\n\n\n\n\n\nC.7.2 Recursive\nAn algorithm is defined recursively whenever the algorithm appears within the definition itself. For example, the factorial function can be defined recursively as shown below.\n\n\n\nThe decomposition of factorial (3), using recursion, is shown below. If we study the figure carefully, we will note that the recursive solution for a problem involves a two-way journey. First we decompose the problem from top to bottom, and then we solve it from bottom to top.\nAlthough the recursive calculation looks more difficult when using paper and pencil, it is often a much easier and more elegant solution when using computers. Additionally, it offers a conceptual simplicity to the creator and the reader!\n\n\n\n\n\nC.7.3 Example 4: Let us write an algorithm to solve the factorial problem iteratively!\n\ndef Factorial(n):\n  \"\"\"\n    Parameters\n    ----------\n    n: int\n        The target factorial which is a nonnegative integer\n    Returns\n    -------\n    results : int\n        The result number \n  \"\"\"\n  results = 1\n  for i in range(1,n+1):\n    results *=i\n  return results\n\n\nassert(Factorial(5)==math.factorial(5))\nassert(Factorial(10)==math.factorial(10))\nassert(Factorial(1)==math.factorial(1))\nassert(Factorial(0)==math.factorial(0))\n\n\n\nC.7.4 Exercise 7: Try to write an algorithm to solve the factorial problem using recursion!\n\ndef Factorial_r(n):\n  \"\"\"\n    Parameters\n    ----------\n    n: int\n        The target factorial which is a positive integer\n    Returns\n    -------\n    results : int\n        The result number \n  \"\"\"\n  if n == 0:\n    return 1\n  else:\n    return n*Factorial_r(n-1)\n\n\nassert(Factorial_r(5)==math.factorial(5))\nassert(Factorial_r(10)==math.factorial(10))\nassert(Factorial_r(1)==math.factorial(1))\nassert(Factorial_r(0)==math.factorial(0))"
  },
  {
    "objectID": "05_Data_Structure_sol.html#a-taste-of-data-structure",
    "href": "05_Data_Structure_sol.html#a-taste-of-data-structure",
    "title": "Appendix D — Data Structure",
    "section": "D.1 A taste of data structure",
    "text": "D.1 A taste of data structure\n\nA data structure uses a collection of related variables that can be accessed individually or as a whole.\n\nIn other words, a data structure represents a set of data items that share a specific relationship."
  },
  {
    "objectID": "05_Data_Structure_sol.html#objects",
    "href": "05_Data_Structure_sol.html#objects",
    "title": "Appendix D — Data Structure",
    "section": "D.2 Objects",
    "text": "D.2 Objects\nAs it turns out, we have been using objects. Python provides us with many built-in objects. Here is some simple code where the first few lines should feel very simple and natural to you.\n\nstuff = list()\nstuff.append('python')\nstuff.append('chuck')\nstuff.sort()\nprint(stuff[0])\nprint(stuff.__getitem__(0))\nprint(list.__getitem__(stuff,0))\n\nchuck\nchuck\nchuck\n\n\nThe first line constructs an object of type list, the second and third lines call the append() method, the fourth line calls the sort() method, and the fifth line retrieves the item at position 0. The sixth line calls the __getitem__() method in the stuff list with a parameter of zero. The seventh line is an even more verbose way of retrieving the 0th item in the list. In this code, we call the __getitem__ method in the list class and pass the list and the item we want retrieved from the list as parameters.\nWe can take a look at the capabilities of an object by looking at the output of the dir() function:\n\ndir(stuff)\n\n['__add__',\n '__class__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__iadd__',\n '__imul__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__mul__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__reversed__',\n '__rmul__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n 'append',\n 'clear',\n 'copy',\n 'count',\n 'extend',\n 'index',\n 'insert',\n 'pop',\n 'remove',\n 'reverse',\n 'sort']\n\n\nAn object can contain a number of functions (which we call methods) as well as data that is used by those functions. We call data items that are part of the object attributes.\nWe use the class keyword to define the data and code that will make up each of the objects. The class keyword includes the name of the class and begins an indented block of code where we include the attributes (data) and methods (code).\n\nclass PartyAnimal:\n   x = 0\n\n   def party(self) :\n     self.x = self.x + 1\n     print(\"So far\",self.x)\n\nan = PartyAnimal()\nan.party()\nan.party()\nan.party()\n\nSo far 1\nSo far 2\nSo far 3\n\n\nEach method looks like a function, starting with the def keyword and consisting of an indented block of code. This object has one attribute (x) and one method (party). The methods have a special first parameter that we name by convention self.\nJust as the def keyword does not cause function code to be executed, the class keyword does not create an object. We need instruct Python to construct (i.e., create) an object or instance of the class PartyAnimal. It looks like a function call to the class itself. Python constructs the object with the right data and methods and returns the object which is then assigned to the variable an\nan = PartyAnimal()\nWhen the PartyAnimal class is used to construct an object, the variable an is used to point to that object. We use an to access the code and data for that particular instance of the PartyAnimal class.\nEach Partyanimal object/instance contains within it a variable x and a method/function named party. We call the party method in this line:\nan.party()\nWhen the party method is called, the first parameter (which we call by convention self) points to the particular instance of the PartyAnimal object that party is called from. Within the party method, we see the line:\nself.x = self.x + 1\nThis syntax using the dot operator is saying ‘the x within self.’ Each time party() is called, the internal x value is incremented by 1 and the value is printed out.\n\nD.2.1 Object lifecycle\nIn the previous examples, we define a class (template), use that class to create an instance of that class (object), and then use the instance. When the program finishes, all of the variables are discarded. Usually, we don’t think much about the creation and destruction of variables, but often as our objects become more complex, we need to take some action within the object to set things up as the object is constructed and possibly clean things up as the object is discarded.\nIf we want our object to be aware of these moments of construction and destruction, we add specially named methods to our object:\n\nclass PartyAnimal:\n   def __init__(self):\n     self.x = 0\n     print('I am constructed')\n\n   def party(self, y=5): # We can pass parameter like this\n     self.x = self.x + y\n     print('So far',self.x)\n\n   def __del__(self):\n     print('I am destructed', self.x)\n\nan = PartyAnimal()\nan.party()\nan.party(10)\nan.party(10)\nan = 42\nprint('an contains',an)\n\nI am constructed\nSo far 5\nSo far 15\nSo far 25\nI am destructed 25\nan contains 42\n\n\nAs Python constructs our object, it calls our __init__ method to give us a chance to set up some default or initial values for the object. When Python encounters the line:\nan = 42\nIt actually “throws our object away” so it can reuse the an variable to store the value 42. Just at the moment when our an object is being “destroyed” our destructor code (__del__) is called. We cannot stop our variable from being destroyed, but we can do any necessary cleanup right before our object no longer exists."
  },
  {
    "objectID": "05_Data_Structure_sol.html#array",
    "href": "05_Data_Structure_sol.html#array",
    "title": "Appendix D — Data Structure",
    "section": "D.3 Array",
    "text": "D.3 Array\nTo process large amounts of data, we need a data structure such as an array. An array is a sequenced collection of elements, of the same data type. We can refer to the elements in the array as the first element, the second element, and so forth until we get to the last element.\nIf we were to put our 100 scores into an array, we could designate the elements as scores[0], scores[1], and so on. The index indicates the ordinal number of the element, counting from the beginning of the array. The array as a whole has a name, scores, but each score can be accessed individually using its subscript as follows:\n\n\n\n\nD.3.1 Array in Python\nBecause arrays store information in adjoining blocks of memory, they’re considered contiguous data structures. In Python, we can use list or array from numpy library to implement array. See here for more information.\nPython list: - Python lists are very general. They can contain any kind of object and are dynamically typed - However, they do not support mathematical functions such as matrix and dot multiplications. Implementing such functions for Python lists would not be very efficient because of the dynamic typing\nNumPy array: - Extension package to Python for multi-dimensional arrays - Numpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created - Because of the static typing, fast implementation of mathematical functions such as multiplication and addition of numpy arrays can be implemented in a compiled language (C and Fortran is used). Moreover, Numpy arrays are memory efficient\n\nA string can be considered as an array of characters, see here.\n\nThe numpy package (module) is used in almost all numerical computation using Python. It is a package that provides high-performance vector, matrix and higher-dimensional data structures for Python. It is implemented in C and Fortran so when calculations are vectorized (formulated with vectors and matrices) it can provides good performance\n\nYou can easily create 1D array (Vector) using a Python list\n\nR1 = [1,9,2,8]\nR2 = 3\nR3 = []\n\nfor r in R1:\n  R3.append(r*R2)\nR1 = np.array([1,9,2,8])\nR2 = 3\nR3 = R1*R2\n\n\n\n\nSource: https://en.wikipedia.org/wiki/SIMD\n\n\nimport numpy as np\nfrom timeit import default_timer as timer\n\n\n# a vector: the argument to the array function is a Python list\nv = np.array([1,2,3,4])\nv, type(v), v.dtype, v.shape\n\n(array([1, 2, 3, 4]), numpy.ndarray, dtype('int64'), (4,))\n\n\n\nD.3.1.1 Example 1: Try to compare the speed of increment an array of integers containing 0 to 9999 by 1 using python list and numpy array.\n\n\na = list(range(10000))\n\n\nstart = timer()\n# Your code here\nfor i in range(10000):\n  a[i] = a[i]+1\nend = timer()\nprint(\"Total time : %.3f ms\" % (10**3 * (end - start)))\n\nTotal time : 2.783 ms\n\n\n\nb = np.arange(10000) # arguments: start, stop, step\n\n\nstart = timer()\nb = b + 1\nend = timer()\nprint(\"Total time : %.3f ms\" % (10**3 * (end - start)))\n\nTotal time : 0.169 ms\n\n\n\nnp.array_equal(np.array(a) , b)\n\nTrue\n\n\n\n\nD.3.2 Multidimensional arrays\nThe arrays discussed so far are known as one-dimensional arrays because the data is organized linearly in only one direction. Many applications require that data be stored in more than one dimension. One common example is a table, which is an array that consists of rows and columns. The following figure shows a table, which is commonly called a two-dimensional array (Matrix).\nThe array shown below holds the scores of students in a class. There are five students in the class and each student has four different scores for four subjects. The variable scores[2][3] show the score of the second student in the third quiz. Arranging the scores in a two-dimensional array can help us to find the average of scores for each student (the average over the row values) and find the average for each subject (the average over the column values), as well as the average of all subjects (the average of the whole table). Note that multidimensional arrays — arrays with more than two dimensions — are also possible.\n\n\n\n\nIn 2D, the first dimension corresponds to rows, the second to columns.\n\n\n\n\n\nsource: https://scipy-lectures.org/intro/numpy/operations.html\n\n\n# a matrix: the argument to the array function is a nested Python list\nM = np.array([[1, 1], [2, 2]]) # You can use nested list to implement 2D array in Python\nM, type(M), M.dtype, M.shape\n\n(array([[1, 1],\n        [2, 2]]), numpy.ndarray, dtype('int64'), (2, 2))\n\n\nNote the slicing of array works the same way as python list!\n\nM[0,:] # row 0\n\narray([1, 1])\n\n\n\nM[:,0] # column 0\n\narray([1, 2])\n\n\n\nM[1,1] #row1, column1\n\n2\n\n\n\n\nD.3.3 Memory layout\nThe indexes in a one-dimensional array directly define the relative positions of the element in actual memory. A two-dimensional array, however, represents rows and columns. How each element is stored in memory depends on the computer. Most computers use row-major storage, in which an entire row of an array is stored in memory before the next row. However, a computer may store the array using column-major storage, in which the entire column is stored before the next column. The following figure shows a two-dimensional array and how it is stored in memory using row-major or column-major storage. Row-major storage is more common.\n\n\n\nBy default, numpy array are row-major (C_CONTIGUOUS)\n\nM.flags\n\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\nYou can change to column major (F_CONTIGUOUS) but it will be much slower in numpy due to the cache effect (functions in numpy assumes that the array are stored in column major)\n\nM = np.array([[1, 1], [2, 2]], order='F')\nM.flags\n\n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\n\nD.3.3.1 Exercise 1: We have stored the two-dimensional array students in the memory. The array is 100 × 4 (100 rows and 4 columns). Show the address of the element students[5][3] assuming that the element student[0][0] is stored in the memory location with address 0 and each element occupies only one memory location. The computer uses row-major storage.\n\n\nstudent = np.random.randint(0,100,size=(100,4)) #2D array\ns = student.flatten() #1D array\n\nWe can use the following formula to find the location of an element, assuming each element occupies one memory location:\n\\(y = x + Cols \\times i + j\\)\nwhere x defines the start address, Cols defines the number of columns in the array, i defines the row number of the element, j defines the column number of the element, and y is the address we are looking for. In our example, x is 0, Cols is 4, i is 5 and j is 3. We are looking for the value of y:\n\\(y = 0 + 4 \\times i + j = 23\\)\n\nassert student[5][3] == s[23]\n\n\n\nD.3.4 Operations on array\nTraditionally, computer languages require that the size of an array (the number of elements in the array) be defined at the time the program is written and prevent it from being changed during the execution of the program. Recently, some languages have allowed variable-size arrays. Even when the language allows variable-sized arrays, insertion of an element into an array needs careful attention! See here for more information.\n\nBoth list and array can be considered as dynamic array\n\n\nD.3.4.1 Searching for elements\nWe often need to find the index of an element when we know the value. This type of search was discussed in Chapter 8. We can use sequential search for unsorted arrays or binary search on sorted arrays\n\n\nD.3.4.2 Insertion at the end\nIf the insertion is at the end of an array this can be done easily. For example, if an array has 30 elements, we increase the size of the array to 31 and insert the new item as the 31st item.\n\nstudent = list(range(1,31))\nstudent.append(31)\nprint(student)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]\n\n\n\nstudent = np.arange(1,31)\nstudent = np.append(student,31)\nstudent\n\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n\n\n\n\nD.3.4.3 Insertion at the beginning or middle\nIf the insertion is to be at the beginning or in the middle of an array, the process is lengthy and time consuming. For example, if we want to insert an element as the 9th element in an array of 30 elements, elements 9 to 30 should be shifted one element towards the end of the array to open an empty element at position 9 for insertion. The following shows\n\nD.3.4.4 Example 2: Try to insertion an element 31 as the 9th element in an array of 30 elements.\n\nElements 9 to 30 should be shifted one element towards the end of the array to open an empty element at position 9 for insertion. The following shows how to do it:\n\nstudent = np.arange(1,31)\nprint(student)\n\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n 25 26 27 28 29 30]\n\n\n\ni = 30\nstudent = np.append(student,0) # Need to enlarge the space of array first!\nwhile(i&gt;=9):\n  student[i] = student[i-1]\n  i = i-1\nstudent[i] = 31\nprint(student)\n\n[ 1  2  3  4  5  6  7  8 31  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n 24 25 26 27 28 29 30]\n\n\nNote that the shifting needs to take place from the end of the array to prevent losing the values of the elements. The code first copies the value of the 30th element into the 31st element, then copies the value of the 29th element into the 30th element, and so on. When the code comes out of the loop, the 9th element is already copied to the 10th element. The last line copies the value of the new item into the 9th element.\n\n\n\nD.3.5 Delete element\nDeletion of an element in an array is as lengthy and involved as insertion. For example, if the ninth element should be deleted, we need to shift elements 10 to 30 one position towards the start of the array.\n\nD.3.5.1 Exercise 2: Try to delete an the element in the 9th position of an array of 30 elements.\n\n\nstudent = np.arange(1,31)\nprint(student)\n\n[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n 25 26 27 28 29 30]\n\n\nWe need to shift elements 10 to 30 one position towards the start of the array\n\ni = 9\nwhile(i&lt;30):\n  student[i-1] = student[i]\n  i = i+1\nprint(student)\n\n[ 1  2  3  4  5  6  7  8 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n 26 27 28 29 30 30]\n\n\n\nD.3.5.2 Accessing array\nan array is a random-access structure, which means that each element of an array can be accessed randomly without the need to access the elements before or after it.\n\n\n\nD.3.6 Traversing array\nArray traversal refers to an operation that is applied to all elements of the array, such as reading, writing, applying mathematical operation, and so on. You can use loop like list but vectorization usually works better as we have seen earlier.\n\nAn array is a suitable structure when a small number of insertions and deletions are required, but a lot of searching and retrieval is needed."
  },
  {
    "objectID": "05_Data_Structure_sol.html#records",
    "href": "05_Data_Structure_sol.html#records",
    "title": "Appendix D — Data Structure",
    "section": "D.4 Records",
    "text": "D.4 Records\nA record is a collection of related elements, possibly of different types, having a single name. Each element in a record is called a field. A field differs from a variable primarily in that it is part of a record. The following figure contains two examples of records. The first example, fraction, has two fields, both of which are integers. The second example, student, has three fields made up of three different types.\n\n\n\n\nThe elements in a record can be of the same or different types, but all elements in the record must be related.\n\n\nD.4.1 Records in Python\nUsing dictionaries as a record data type or data object in Python is possible. Dictionaries are easy to create in Python as they have their own syntactic sugar built into the language.\n\nfraction = {\"numerator\":13, \"denominator\":17}\nstudent = {\"id\":2005, \"name\":\"George Boole\", \"grade\":'A'}\n\n\n\nD.4.2 Record name versus field name\nThe name of the record is the name of the whole structure, while the name of each field allows us to refer to that field. For example, in the student record of previous Figure, the name of the record is student, the name of the fields are student[\"id\"], student[\"name\"], and student[\"grade\"].\n\nstudent[\"id\"] = 2006\n\nSome programming languages use a period (.) to separate the name of the structure (record) from the name of its components (fields). You can implement this in Python using the following class.\n\nclass AttrDict(dict):\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.__dict__ = self\n\n\nstudent = AttrDict(student)\n\n\nstudent.id = 2006\n\n\n\nD.4.3 Comparison of records and arrays\nWe can conceptually compare an array with a record. This helps us to understand when we should use an array and when a record. An array defines a combination of elements, while a record defines the identifiable parts of an element. For example, an array can define a class of students (40 students), but a record defines different attributes of a student, such as id, name, or grade.\n\n\nD.4.4 Array of records\nIf we need to define a combination of element and at the same time some attributes of each element, we can use an array of records. For example, in a class of 30 students, we can have an array of 30 records, each record representing a student. The following figure shows an array of 30 student records called students.\n\n\n\n\nstudents = []\nfor i in range(30):\n  s = dict()\n  s[\"id\"] = i+2000\n  s[\"name\"] = \"Bob\"+str(i)\n  s[\"grade\"] = \"A\"\n  students.append(s)\n\n\nstudents\n\n[{'id': 2000, 'name': 'Bob0', 'grade': 'A'},\n {'id': 2001, 'name': 'Bob1', 'grade': 'A'},\n {'id': 2002, 'name': 'Bob2', 'grade': 'A'},\n {'id': 2003, 'name': 'Bob3', 'grade': 'A'},\n {'id': 2004, 'name': 'Bob4', 'grade': 'A'},\n {'id': 2005, 'name': 'Bob5', 'grade': 'A'},\n {'id': 2006, 'name': 'Bob6', 'grade': 'A'},\n {'id': 2007, 'name': 'Bob7', 'grade': 'A'},\n {'id': 2008, 'name': 'Bob8', 'grade': 'A'},\n {'id': 2009, 'name': 'Bob9', 'grade': 'A'},\n {'id': 2010, 'name': 'Bob10', 'grade': 'A'},\n {'id': 2011, 'name': 'Bob11', 'grade': 'A'},\n {'id': 2012, 'name': 'Bob12', 'grade': 'A'},\n {'id': 2013, 'name': 'Bob13', 'grade': 'A'},\n {'id': 2014, 'name': 'Bob14', 'grade': 'A'},\n {'id': 2015, 'name': 'Bob15', 'grade': 'A'},\n {'id': 2016, 'name': 'Bob16', 'grade': 'A'},\n {'id': 2017, 'name': 'Bob17', 'grade': 'A'},\n {'id': 2018, 'name': 'Bob18', 'grade': 'A'},\n {'id': 2019, 'name': 'Bob19', 'grade': 'A'},\n {'id': 2020, 'name': 'Bob20', 'grade': 'A'},\n {'id': 2021, 'name': 'Bob21', 'grade': 'A'},\n {'id': 2022, 'name': 'Bob22', 'grade': 'A'},\n {'id': 2023, 'name': 'Bob23', 'grade': 'A'},\n {'id': 2024, 'name': 'Bob24', 'grade': 'A'},\n {'id': 2025, 'name': 'Bob25', 'grade': 'A'},\n {'id': 2026, 'name': 'Bob26', 'grade': 'A'},\n {'id': 2027, 'name': 'Bob27', 'grade': 'A'},\n {'id': 2028, 'name': 'Bob28', 'grade': 'A'},\n {'id': 2029, 'name': 'Bob29', 'grade': 'A'}]\n\n\nIn an array of records, the name of the array defines the whole structure, the group of students as a whole. To define each element, we need to use the corresponding index. To define the parts (attributes) of each element, we need to use the dot operator. In other words, first we need to define the element, then we can define part of that element. Therefore, the id of the third student is defined as:\n\nstudents[2][\"id\"]\n\n2002\n\n\n\n\nD.4.5 Arrays versus array of records\nBoth an array and an array of record represents a list of items. An array can be thought of as a special case of an array of records in which each element is a record with only a single field!"
  },
  {
    "objectID": "05_Data_Structure_sol.html#linked-lists",
    "href": "05_Data_Structure_sol.html#linked-lists",
    "title": "Appendix D — Data Structure",
    "section": "D.5 Linked Lists",
    "text": "D.5 Linked Lists\nA linked list is a collection of data in which each element contains the location of the next element — that is, each element contains two parts: data and link. The data part holds the value information: the data to be processed. The link is used to chain the data together, and contains a pointer (an address) that identifies the next element in the list. In addition, a pointer variable identifies the first element in the list. The name of the list is the same as the name of the first pointer variable.\nThe following figure shows a linked list called scores that contains four elements. The link in each element, except the last, points to its successor. The link in the last element contains a null pointer, indicating the end of the list. We define an empty linked list to be only a null pointer:\n\n\n\nThe elements in a linked list are traditionally called nodes. A node in a linked list is a record that has at least two fields: one contains the data, and the other contains the address of the next node in the sequence (the link).\nBefore further discussion of linked lists, we need to explain the notation we use in the figures. We show the connection between two nodes using a line. One end of the line has an arrowhead, the other end has a solid circle. The arrowhead represents a copy of the address of the node to which the arrow head is pointed. The solid circle shows where this copy of the address is stored. The figure also shows that we can store a copy of the address in more than one place!\n\n\n\n\nD.5.1 Arrays versus linked lists\nBoth an array and a linked list are representations of a list of items in memory. The only difference is the way in which the items are linked together. In an array of records, the linking tool is the index. The element scores[3] is linked to the element scores[4] because the integer 4 comes after the integer 3. In a linked list, the linking tool is the link that points to the next element — the pointer or the address of the next element.\n\n\n\nThe list is contiguous. The nodes of a linked list can be stored with gaps between them: the link part of the node ‘glues’ the items together. In other words, the computer has the option to store them contiguously or spread the nodes through the whole memory. This has an advantage: insertion and deletion in a linked list is much easier. The only thing that needs to be changed is the pointer to the address of the next element. However, this comes with an overhead: each node of a linked list has an extra field, the address of the next node in memory.\n\n\nD.5.2 Linked-list in Python\nIn Python, there’s a specific object in the collections module that you can use for linked lists called deque (pronounced “deck”), which stands for double-ended queue.\nhttps://realpython.com/linked-lists-python/\n\nfrom collections import deque\ndeque()\n\ndeque([])\n\n\nBut we can create a linked list using custom class in order to help our understanding! First things first, create a class to represent your linked list:\n\nclass LinkedList:\n  def __init__(self):\n    self.head = None\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\nThe only information you need to store for a linked list is where the list starts (the head of the list). Next, create another class to represent each node of the linked list:\n\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.link = None\n  def __repr__(self):\n    return str(self.data)\n\nIn the above class definition, you can see the two main elements of every single node: data and link.\n\nscore = LinkedList()\nfirst_node = Node(66)\nscore.head = first_node\nscore\n\n66 -&gt; None\n\n\n\nsecond_node = Node(72)\nthird_node = Node(96)\nfirst_node.link = second_node\nsecond_node.link = third_node\nscore\n\n66 -&gt; 72 -&gt; 96 -&gt; None\n\n\nBy defining a node’s data and link values, you can create a linked list quite quickly. Here’s a slight change to the linked list’s __init__() that allows you to quickly create linked lists with some data:\n\nclass LinkedList:\n  def __init__(self, nodes=None):\n    self.head = None\n    if nodes:\n      node = Node(data=nodes.pop(0)) #pop will pop out the first entry of the list\n      self.head = node\n      for elem in nodes:\n        node.link = Node(data=elem)\n        node = node.link\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\n\nscore = LinkedList([66,72,96,85,74])\nscore\n\n66 -&gt; 72 -&gt; 96 -&gt; 85 -&gt; 74 -&gt; None\n\n\n\n\nD.5.3 Operations on linked lists\nThe same operations we defined for an array can be applied to a linked list.\n\nD.5.3.1 Searching a linked list\nThe search algorithm for a linked list can only be sequential (see Chapter 8) because the nodes in a linked list have no specific names (unlike the elements in an array) that can be found using a binary search. Since nodes in a linked list have no names, we use two pointers, pre (for previous) and cur (for current).\nAt the beginning of the search, the pre pointer is null and the cur pointer points to the first node. The search algorithm moves the two pointers together towards the end of the list. The following figure shows the movement of these two pointers through the list in an extreme case scenario: when the target value is larger than any value in the list. For example, in the five-node list, assume that our target value is 220, which is larger than any value in the list.\n\n\n\nWhen the search stops, the cur pointer points to the node that stops the search and the pre pointer points to the previous node. If the target is found, the cur pointer points to the node that holds the target value. If the target value is not found, the cur pointer points to the node with a value larger than the target value. In other words, since the list is sorted, and may be very long, we never allow the two pointers to reach the end of the list if we are sure that we have passed the target value. The searching algorithm uses a flag (a variable that can take only true or false values). When the target is found, the flag is set to true: when the target is not found, the flag is set to false. When the flag is true the cur pointer points to the target value: when the flag is false, the cur pointer points to a value larger than the target value.\nThe following shows some different situations. In the first case, the target is 98. This value does not exist in the list and is smaller than any value in the list, so the search algorithm stops while pre is null and cur points to the first node. The value of the flag is false because the value was not found. In the second case, the target is 132, which is the value of the second node. The search algorithm stops while cur is pointing to the second node and pre is pointing to the first node. The value of the flag is true because the target is found. In the third and the fourth cases, the targets are not found so the value of the flag is false.\n\n\n\n\nD.5.3.2 Example 3: The following shows a simplified algorithm for the search. Note how\nwe move the two pointers forward together. This guarantees that the two pointers move together. The search algorithm is used both by the insertion algorithm (if the target is not found) and by the delete algorithm (if the target is found).\n\n\n\n\n\ndef SearchLinkedList(ilist, target):\n  \"\"\"\n    Parameters\n    ----------\n    numbers: ilist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    cur : Node\n        The current pointer\n    pre : Node\n        The pre pointer  \n    flag : bool\n        Whether the taget had been found or not \n  \"\"\"\n  # Your code here\n  pre = None\n  cur = ilist.head\n  while(cur!=None and target &gt; cur.data):\n    pre = cur\n    cur = cur.link\n  if cur!=None and cur.data == target:\n    flag = True\n  else:\n    flag = False\n  return cur, pre, flag\n\n\nscore = LinkedList([102,132,178,201])\nscore\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nSearchLinkedList(score, 98)\n\n(102, None, False)\n\n\n\nSearchLinkedList(score, 132)\n\n(132, 102, True)\n\n\n\nSearchLinkedList(score, 150)\n\n(178, 132, False)\n\n\n\nSearchLinkedList(score, 305)\n\n(None, 201, False)\n\n\n\n\nD.5.3.3 Inserting a node\nBefore insertion into a linked list, we first apply the searching algorithm. If the flag returned from the searching algorithm is false, we will allow insertion, otherwise we abort the insertion algorithm, because we do not allow data with duplicate values. Four cases can arise:\n\nD.5.3.3.1 Insertion into an empty list\nIf the list is empty (ilist = None), the new item is inserted as the first element. One statement can do the job:\n\nilist = LinkedList()\n\n\nilist.head = Node(66)\nilist\n\n66 -&gt; None\n\n\n\n\nD.5.3.3.2 Insertion at the beginning\nIf the searching algorithm returns a flag with value of false and the value of the pre pointer is null, the data needs to be inserted at the beginning of the list. Two statements are needed to do the job:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 95)\ncur, pre, flag\n\n(102, None, False)\n\n\n\nnode = Node(95)\nnode.link = cur \nilist.head = node\nilist\n\n95 -&gt; 102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\nThe first assignment makes the new node become the predecessor of the previous first node. The second statement makes the newly connected node the first node.\n\n\n\n\n\nD.5.3.3.3 Insertion at the end\nIf the searching algorithm returns a flag with value of false and the value of the cur pointer is null, the data needs to be inserted at the end of the list. Two statements are needed to do the job:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 220)\ncur, pre, flag\n\n(None, 201, False)\n\n\n\nnode = Node(220)\npre.link = node\nnode.link = None\nilist\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; 220 -&gt; None\n\n\nThe first assignment connects the new node to the previous last node. The second statement makes the newly connected node become the last node.\n\n\n\n\n\nD.5.3.3.4 Insertion in the middle\nIf the searching algorithm returns a flag with a value of false and none of the returned pointers are null, the new data needs to be inserted at the middle of the list. Two statements are needed to do the job:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 156)\ncur, pre, flag\n\n(178, 132, False)\n\n\n\nnode = Node(156)\nnode.link = cur\npre.link = node\nilist\n\n102 -&gt; 132 -&gt; 156 -&gt; 178 -&gt; 201 -&gt; None\n\n\nThe first assignment connects the new node to its successor. The second statement connects the new node to its predecessor.\n\n\n\n\nD.5.3.4 Exercise 3: The following shows the pseudocode for inserting a new node in a linked list. The first section just adds a node to an empty list.\n\n\n\n\n\ndef InsertLinkedList(ilist, target, new):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    new: Node\n        The node that should be inserted\n    Returns\n    -------\n    ilist : llist\n        The new linked list\n  \"\"\"\n  # Your code here\n  cur, pre, flag = SearchLinkedList(ilist, target)\n  if flag == True:\n    return ilist\n  if ilist.head == None:\n    new.data = target\n    ilist.head = new\n  elif pre == None:\n    new.data = target\n    new.link = cur \n    ilist.head = new\n  elif cur == None:\n    new.data = target\n    pre.link = new\n    new.link = None\n  else:\n    new.data = target\n    new.link = cur\n    pre.link = new\n\n  return ilist\n\n\nilist = LinkedList()\nnew = Node(0)\nilist = InsertLinkedList(ilist, 66, new)\nilist\n\n66 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nnew = Node(0)\nilist = InsertLinkedList(ilist, 95, new)\nilist\n\n95 -&gt; 102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nnew = Node(0)\nilist = InsertLinkedList(ilist, 220, new)\nilist\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; 220 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nnew = Node(0)\nilist = InsertLinkedList(ilist, 156, new)\nilist\n\n102 -&gt; 132 -&gt; 156 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\n\n\nD.5.3.5 Deleting a node\nBefore deleting a node in a linked list, we apply the search algorithm. If the flag returned from the search algorithm is true (the node is found), we can delete the node from the linked list. However, deletion is simpler than insertion: we have only two cases — deleting the first node and deleting any other node. In other words, the deletion of the last and the middle nodes can be done by the same process.\n\nD.5.3.5.1 Deleting the first node\nIf the pre pointer is null, the first node is to be deleted. The cur pointer points to the first node and deleting can be done by one statement:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 102)\ncur, pre, flag\n\n(102, None, True)\n\n\n\nilist.head = cur.link\nilist\n\n132 -&gt; 178 -&gt; 201 -&gt; None\n\n\nThe statement connects the second node to the list pointer, which means that the first node is deleted.\n\n\n\n\n\nD.5.3.5.2 Deleting the middle or the last node\nIf neither of the pointers is null, the node to be deleted is either a middle node or the last node. The cur pointer points to the corresponding node and deleting can be done by one statement:\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 132)\ncur, pre, flag\n\n(132, 102, True)\n\n\n\npre.link = cur.link\nilist\n\n102 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\ncur, pre, flag = SearchLinkedList(ilist, 201)\ncur, pre, flag\n\n(201, 178, True)\n\n\n\npre.link = cur.link\nilist\n\n102 -&gt; 132 -&gt; 178 -&gt; None\n\n\nThe statement connects the successor node to the predecessor node, which means that the current node is deleted.\n\n\n\n\nD.5.3.6 Exercise 4: The following algorithm shows the pseudocode for deleting a node. The algorithm is much simpler than the one for inserting. We have only two cases and each case needs only one statement.\n\n\n\n\n\ndef DeleteLinkedList(ilist, target):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    ilist : llist\n        The new linked list\n  \"\"\"\n  # Your code here\n  cur, pre, flag = SearchLinkedList(ilist, target)\n  if flag == False:\n    return ilist\n  elif pre == None:\n    ilist.head = cur.link\n  else:\n    pre.link = cur.link\n  return ilist\n\n\nilist = LinkedList([102,132,178,201])\nDeleteLinkedList(ilist, 95)\n\n102 -&gt; 132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nDeleteLinkedList(ilist, 102)\n\n132 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\nilist = LinkedList([102,132,178,201])\nDeleteLinkedList(ilist, 132)\n\n102 -&gt; 178 -&gt; 201 -&gt; None\n\n\n\n\n\nD.5.3.7 Retrieving a node\nRetrieving means randomly accessing a node for the purpose of inspecting or copying the data contained in the node. Before retrieving, the linked list needs to be searched. If the data item is found, it is retrieved, otherwise the process is aborted. Retrieving uses only the cur pointer, which points to the node found by the search algorithm.\n\nD.5.3.8 Example 4:\n\n\n\n\n\ndef RetrieveLinkedList(ilist, target):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    cur : Node\n        The node to be retrieved\n  \"\"\"\n  # Your code here\n  cur, pre, flag = SearchLinkedList(ilist, target)\n  if flag == False:\n    return False\n  else:\n    return cur\n\n\nilist = LinkedList([102,132,178,201])\nRetrieveLinkedList(ilist, 95), RetrieveLinkedList(ilist, 201)\n\n(False, 201)\n\n\n\n\nD.5.3.9 Traversing a linked list\nTo traverse the list, we need a ‘walking’ pointer, which is a pointer that moves from node to node as each element is processed. We start traversing by setting the walking pointer to the first node in the list. Then, using a loop, we continue until all of the data has been processed. Each iteration of the loop processes the current node, then advances the walking pointer to the next node. When the last node has been processed, the walking pointer becomes null and the loop terminates.\n\nD.5.3.10 Example 5:\n\n\n\n\n\ndef TraverseLinkedList(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist: llist\n        The input list.\n    target: int \n        The target value.\n    Returns\n    -------\n    cur : Node\n        The node to be retrieved\n  \"\"\"\n  # Your code here\n  walker = ilist.head\n  while walker != None:\n    print(walker)\n    walker = walker.link\n\n\nilist = LinkedList([102,132,178,201])\nTraverseLinkedList(ilist)\n\n102\n132\n178\n201\n\n\n\n\n\nD.5.4 Applications of linked lists\nA linked list is a very efficient data structure for storing data that will go through many insertions and deletions. A linked list is a dynamic data structure in which the list can start with no nodes and then grow as new nodes are needed. A node can be easily deleted without moving other nodes, as would be the case with an array. For example, a linked list could be used to hold the records of students in a school. Each quarter or semester, new students enroll in the school and some students leave or graduate.\nA linked list can grow infinitely and can shrink to an empty list. The overhead is to hold an extra field for each node. A linked list, however, is not a good candidate for data that must be searched often. This appears to be a dilemma, because each deletion or insertion needs a search. We will see that some abstract data types, discussed in the next chapter, have the advantages of an array for searching and the advantages of a link list for insertion and deletion.\n\nA linked list is a suitable structure if a large number of insertions and deletions are needed, but searching a linked list is slower that searching an array."
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#background",
    "href": "06_Abstract_data_types_sol.html#background",
    "title": "Appendix E — Abstract Data Types",
    "section": "E.1 Background",
    "text": "E.1 Background\nProblem solving with a computer means processing data. To process data, we need to define the data type and the operation to be performed on the data. For example, to find the sum of a list of numbers, we should select the type for the number (integer or real) and define the operation (addition). The definition of the data type and the definition of the operation to be applied to the data is part of the idea behind an abstract data type (ADT)—to hide how the operation is performed on the data.\n\nIn other word, the user of an ADT needs only to know that a set of operations are available for the data type, but does not need to know how they are applied.\n\n\nE.1.1 Simple ADTs\nMany programming languages already define some simple ADTs as integral parts of the language. For example, the Python language defines a simple ADT called an integer. The type of this ADT is integer with predefined ranges. Python also defines several operations that can be applied on this data type (addition, subtraction, multiplication, division, and so on). Python  explicitly defines these operations on integers and what we expect as the results. A  programmer who writes a Python program to add two integers should know about the integer ADT and the operations that can be applied to it.\nThe programmer, however, does not need to know how these operations are actually implemented. For example, the programmer uses the expression z = x + y and expects the value of x (an integer) to be added to the value of y (an integer) and the result to be named z (an integer). The programmer does not need to know how the addition is performed. We learned in previous chapters that the way this addition is done by a computer is to store the two integers in two memory locations in two’s complement format, to load them into the CPU register, to add them in binary, and to store the result back to another memory location. The programmer, however, does not need to know this. An integer in Python is a simple abstract data type with predefined operations. How the operations are performed is not a concern for the programmer.\n\n\nE.1.2 Complex ADTs\nAlthough several simple ADTs, such as integer, float, character and so on, have been implemented and are available for use in most languages, many useful complex ADTs are not. As we will see in this chapter, we need a stack ADT, a queue ADT, and so on. To be efficient, these ADTs should be created and stored in the library of the computer to be used. The user of a stack, for example, should only need to know what operations are available for the stack, not how these operations are performed.\nTherefore, with an ADT, users are not concerned with how the task is done, but rather with what it can do. In other words, the ADT consists of a set of definitions that allow programmers to use the operation while their implementation is hidden. This generalization of operations with unspecified implementations is known as abstraction. We abstract the essence of the process and leave the implementation details hidden.\n\nThe concept of abstraction means: 1. We know what a data type can do. 2. How it is done is hidden.\n\nLet us now define an ADT. An abstract data type is a data type packaged with the operations that are meaningful for the data type. We then encapsulate the data and the operations on the data and hide them from the user.\n\nAbstract Data Type 1. Definition of data 2. Definition of operations 3. Encapsulation of data and operation\n\n\n\nE.1.3 Model for an abstract data type\nThe ADT model is shown in the Figure below. The colored area with an irregular outline represents the ADT. Inside the ADT are two different parts of the model: data structure and operations (public and private). The application program can only access the public operations through the interface. An interface is a list of public operations and data to be passed to or returned from those operations. The private operations are for internal use by the ADT. The data structures, such as arrays and linked lists, are inside the ADT and are used by the public and private operations.\n\n\n\nAlthough the public operations and the interface should be independent of the implementation, the private operations are dependent on the data structures chosen during the implementation of the ADT. We will elaborate on this issue when we discuss some of the ADTs."
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#stacks",
    "href": "06_Abstract_data_types_sol.html#stacks",
    "title": "Appendix E — Abstract Data Types",
    "section": "E.2 Stacks",
    "text": "E.2 Stacks\nA stack is a restricted linear list in which all additions and deletions are made at one end, the top. If we insert a series of data into a stack and then remove it, the order of the data is reversed. Data input as 5, 10, 15, 20, for example, would be removed as 20, 15, 10, and 5. This reversing attribute is why stacks are known as a last in, first out (LIFO) data structure.\nWe use many different types of stacks in our daily lives. We often talk of a stack of coins or a stack of books. Any situation in which we can only add or remove an object at the top is a stack. If we want to remove an object other than the one at the top, we must first remove all objects above it. Figure below shows three representations of stacks.\n\n\n\n\nE.2.1 Operations on stacks\n\nE.2.1.1 The stack operation\nThe stack operation creates an empty stack. Python’s built-in list type makes a decent stack data structure as it supports push and pop operations. Python’s lists are implemented as dynamic arrays internally, which means they occasionally need to resize the storage space for elements stored in them when elements are added or removed. The list over-allocates its backing storage so that not every push or pop requires resizing. For optimum performance, stacks based on Python lists should grow towards higher indexes and shrink towards lower ones.\n\nstack = []\n\n\n\nE.2.1.2 The push operation\nThe push operation inserts an item at the top of the stack. This operation returns the new stack with dataItem inserted at the top. Figure below shows the pictorial representation of this operation.\n\n\n\nIn Python we use append method as the push operation to put it into the stack (higher index).\n\nstack.append(20)\nstack.append(78)\nstack.append(30)\nprint(stack)\n\n[20, 78, 30]\n\n\n\n\nE.2.1.3 The pop operation\nThe pop operation deletes the item at the top of the stack. The following shows the pictorial representation of this operation.\n\n\n\n\nPoped = stack.pop()\nprint(Poped)\n\n30\n\n\nThe deleted item can be used by the application program or can be just discarded. After the pop operation, the item that was under the top element before the deletion becomes the top element.\n\n\nE.2.1.4 The empty operation\nThe empty operation checks the status of the stack.\n\ndef empty(lis):\n  if len(lis) == 0:\n    return True\n  else:\n    return False\n\n\nempty(stack)\n\nFalse\n\n\n\nstack.pop()\nstack.pop()\nempty(stack)\n\nTrue\n\n\n\n\n\nE.2.2 Stack ADT\nWe define a stack as an ADT as shown below:\n\n\n\n\n\nE.2.3 Stack applications\n\nE.2.3.1 Reversing data items\nReversing data items requires that a given set of data items be reordered so that the first and last items are exchanged, with all of the positions between the first and last being relatively exchanged also. For example, the list (2, 4, 7, 1, 6, 8) becomes (8, 6, 1, 7, 4, 2).\n\nE.2.3.2 Example 1: In Chapter 2 we gave a simple UML diagram to convert an integer from decimal to any base. Although the algorithm is very simple, if we print the digits of the converted integer as they are created, we will get the digits in reverse order. The print instruction in any computer language prints characters from left to right, but the algorithm creates the digits from right to left. We can use the reversing characteristic of a stack (LIFO structure) to solve the problem.\n\n\n\n\n\n\n\n\n\n\n\ndef DecimalToBinary(number):\n  \"\"\"\n    Parameters\n    ----------\n    number: int\n        The integer to be converted \n    Returns\n    -------\n    print the binary equivalent\n  \"\"\"\n  if number == 0:\n    print(\"0b0\")\n    return \n  S = []\n  while number != 0:\n    remainder = number % 2\n    S.append(remainder)\n    number = number //2\n  \n  print(\"0b\",end =\"\")\n  while len(S)!=0:\n    x = S.pop()\n    print(x,end =\"\")\n\n\nDecimalToBinary(0)\n\n0b0\n\n\n\nDecimalToBinary(35)\n\n0b100011\n\n\nWe create an empty stack first. Then we use a while loop to create the bits, but instead of printing them, we push them into the stack. When all bits are created, we exit the loop. Now we use another loop to pop the bits from the stack and print them. Note that the bits are printed in the reverse order to that in which they have been created.\n\n\nE.2.3.3 Pairing data items\nWe often need to pair some characters in an expression. For example, when we write a mathematical expression in a computer language, we often need to use parentheses to change the precedence of operators.\n3*((3+2)-5)\nWhen we type an expression with a lot of parentheses, we often forget to pair the parentheses. One of the duties of a compiler is to do the checking for us. The compiler uses a stack to check that all opening parentheses are paired with a closing parentheses.\n\nE.2.3.4 Exercise 1: Algorithm 12.2 shows how we can check if every opening parenthesis is paired with a closing parenthesis.\n\n\n\n\n\n\n\n\ndef CheckingParentheses(expression):\n  \"\"\"\n    Parameters\n    ----------\n    expression: str\n        The expression to be checked\n    Returns\n    -------\n    Error messages if unpaired parentheses are found\n  \"\"\"\n\n  S = []\n  for char in expression:\n    if char == '(':\n      S.append(char)\n    else:\n      if char == ')':\n        if len(S) == 0:\n          print(\"a closing parenthes is not matched\")\n        else:\n          S.pop()\n\n  if len(S)!=0:\n    print(\"unmatched opening parenthesis\")\n\n\nCheckingParentheses(\"3*((3+2)-5)\")\n\n\nCheckingParentheses(\"3*(3+2)-5)\")\n\na closing parenthes is not matched\n\n\n\nCheckingParentheses(\"3*(3+(2-5)\")\n\nunmatched opening parenthesis\n\n\n\n\n\nE.2.4 Stack implementation\nIn this section we describe the general ideas behind the implementation of a stack ADT. At the ADT level, we use the stack and its four operations (stack, push, pop, and empty): at the implementation level, we need to choose a data structure to implement it. Stack ADT can be implemented using either an array or a linked list.\n\n\n\nWe can write four algorithms in pseudocode for the four operations we defined for stack in each implementation. We showed algorithms to handle arrays and linked lists in Chapter 11: these algorithms can be modified to create the four algorithms we need for stacks: stack, push, pop, and empty. These algorithms are even easier than those presented in Chapter 11, because the insertion and deletion is done only at the top of stack. \n\nE.2.4.1 Example 2: The linked list implementation is as above, we have an extra record that has the name of the stack. This record also has two fields: a counter, which at each moment shows the number of data items in the stack. Another field is a pointer that points to the top element.\n\n\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.link = None\n  def __repr__(self):\n    return str(self.data)\n\nclass LinkedList:\n  def __init__(self, nodes=None):\n    self.head = None\n    if nodes:\n      node = Node(data=nodes.pop(0)) #pop will pop out the first entry of the list\n      self.head = node\n      for elem in nodes:\n        node.link = Node(data=elem)\n        node = node.link\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\n\nL = LinkedList(0)\n\n\n# Create an empty stack\ndef stack():\n  S={\"count\":0, \"top\":None}\n  return S\n\ndef push(S,L,x):\n  new = Node(x)\n  if S[\"top\"] == None:\n    L.head = new\n    S[\"top\"] = L.head\n  else:\n    new.link = L.head\n    L.head = new\n    S[\"top\"] = L.head\n  S[\"count\"] = S[\"count\"]+1\n\n\ndef pop(S,L):\n  if S[\"count\"] ==0:\n    return None\n  x = L.head\n  L.head = L.head.link\n  S[\"top\"] = L.head\n  S[\"count\"] = S[\"count\"]-1  \n  return x\n\ndef empty(S):\n  if S[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nS = stack()\npush(S,L,20)\nprint(S,L)\npush(S,L,78)\nprint(S,L)\npush(S,L,30)\nprint(S,L)\n\n{'count': 1, 'top': 20} 20 -&gt; None\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n{'count': 3, 'top': 30} 30 -&gt; 78 -&gt; 20 -&gt; None\n\n\n\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\n\n30\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n78\n{'count': 1, 'top': 20} 20 -&gt; None\n20\n{'count': 0, 'top': None} None\n\n\n\npush(S,L,20)\nprint(S,L)\npush(S,L,78)\nprint(S,L)\npush(S,L,30)\nprint(S,L)\n\n{'count': 1, 'top': 20} 20 -&gt; None\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n{'count': 3, 'top': 30} 30 -&gt; 78 -&gt; 20 -&gt; None\n\n\n\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\nprint(pop(S,L))\nprint(S,L)\n\n30\n{'count': 2, 'top': 78} 78 -&gt; 20 -&gt; None\n78\n{'count': 1, 'top': 20} 20 -&gt; None\n20\n{'count': 0, 'top': None} None\n\n\n\nE.2.4.2 Example 3: In the array implementation, we have a record that has two fields. The first field can be used to store information about the array: we have used it as the count field, which at each moment shows the number of data items in the stack. The second field is an integer that holds the index of the top element. Note that the array is shown upside down to match the linked list implementation.\n\n\nimport numpy as np\nn = 10 # number of elements allocated to the array\nA = np.zeros(n, dtype=np.int8)\n\n\n# Create an empty stack\ndef stack():\n  S={\"count\":0, \"top\":-1}\n  return S\n\ndef push(S,A,x):\n  S[\"top\"] = S[\"top\"]+1\n  S[\"count\"] = S[\"count\"]+1\n  A[S[\"top\"]] = x\n\ndef pop(S,A):\n  if S[\"count\"] ==0:\n    return None\n  x = A[S[\"top\"]]\n  A[S[\"top\"]] = 0\n  S[\"top\"] = S[\"top\"]-1\n  S[\"count\"] = S[\"count\"]-1  \n  return x\n\ndef empty(S):\n  if S[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nS = stack()\npush(S,A,20)\nprint(S,A)\npush(S,A,78)\nprint(S,A)\npush(S,A,30)\nprint(S,A)\n\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n{'count': 3, 'top': 2} [20 78 30  0  0  0  0  0  0  0]\n\n\n\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\n\n30\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n78\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n20\n{'count': 0, 'top': -1} [0 0 0 0 0 0 0 0 0 0]\n\n\n\npush(S,A,20)\nprint(S,A)\npush(S,A,78)\nprint(S,A)\npush(S,A,30)\nprint(S,A)\n\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n{'count': 3, 'top': 2} [20 78 30  0  0  0  0  0  0  0]\n\n\n\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\nprint(pop(S,A))\nprint(S,A)\n\n30\n{'count': 2, 'top': 1} [20 78  0  0  0  0  0  0  0  0]\n78\n{'count': 1, 'top': 0} [20  0  0  0  0  0  0  0  0  0]\n20\n{'count': 0, 'top': -1} [0 0 0 0 0 0 0 0 0 0]"
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#queues",
    "href": "06_Abstract_data_types_sol.html#queues",
    "title": "Appendix E — Abstract Data Types",
    "section": "E.3 Queues",
    "text": "E.3 Queues\nA queue is a linear list in which data can only be inserted at one end, called the rear, and deleted from the other end, called the front. These restrictions ensure that the data are processed through the queue in the order in which it is received. In other words, a queue is a first in, first out (FIFO) structure.\nQueues are familiar from everyday life. A line of people waiting for the bus at a bus station is a queue, a list of calls put on hold to be answered by a telephone operator is a queue, and a list of waiting jobs to be processed by a computer is a queue.\nFigure 12.8 shows two representations of queues, one a queue of people and the other a computer queue. Both people and data enter the queue at the rear and progress through the queue until they arrive at the front. Once they are at the front of the queue, they leave the queue and are served.\n\n\n\n\nE.3.1 Operations on queues\n\nE.3.1.1 The queue operation\nThe queue operation creates an empty queue. A queue is a collection of objects that supports fast FIFO semantics for inserts and deletes. The insert and delete operations are sometimes called enqueue and dequeue. Unlike lists or arrays, queues typically don’t allow for random access to the objects they contain. It’s possible to use a regular list as a queue, but this is not ideal from a performance perspective. Lists are quite slow for this purpose because inserting or deleting an element at the beginning requires shifting all the other elements by one!\nThe collections.deque implementation is a great default choice if you’re looking for a queue data structure in Python’s standard library.\n\nfrom collections import deque\n\nqueue = deque()\n\n\n\nE.3.1.2 The enqueue operation\nThe enqueue operation inserts an item at the rear of the queue. After the enqueue operation, the new item becomes the last item in the queue. This operation returns the new queue with new data inserted at the rear. Figure below shows the pictorial representation of this operation.\n\n\n\nIn Python, you can use the append operation for enqueue.\n\nqueue.append(20)\nqueue.append(78)\nqueue.append(30)\nqueue\n\ndeque([20, 78, 30])\n\n\n\n\nE.3.1.3 The dequeue operation\nThe dequeue operation deletes the item at the front of the queue. The deleted item can be used by the application program or can be just discarded. After the dequeue operation, the item that followed the front element becomes the front element. This operation returns the new queue with one less element. Figure below shows the pictorial representation of this operation.\n\n\n\n\nfront = queue.popleft()\nfront\n\n20\n\n\nIn python, you can use the popleft operation for dequeue.\n\n\nE.3.1.4 The empty operation\nThe empty operation checks the status of the queue.\n\ndef empty(q):\n  if len(q) == 0:\n    return True\n  else:\n    return False\n\n\nempty(queue)\n\nFalse\n\n\n\nqueue.popleft()\nqueue.popleft()\nempty(queue)\n\nTrue\n\n\n\n\n\nE.3.2 Queue ADT\nWe define a stack as an ADT as shown below:\n\n\n\n\n\nE.3.3 Queue applications\nQueues are one of the most common of all data processing structures. They are found in virtually every operating system and network and in countless other areas. For example, queues are used in online business applications such as processing customer requests, jobs, and orders. In a computer system, a queue is needed to process jobs and for system services such as print spools.\n\nE.3.3.1 Example 4: Queues can be used to organize databases by some characteristic of the data. For example, imagine we have a list of sorted data stored in the computer belonging to two categories: less than 1000, and greater than 1000. We can use two queues to separate the categories and at the same time maintain the order of data in their own category. Algorithm 12.3 shows the pseudocode for this operation.\n\n\n\n\n\n\n\n\ndef Categorizer(ilist):\n  \"\"\"\n    Parameters\n    ----------\n    ilist1: list\n        Input sorted list\n    Returns\n    -------\n    Categorize data into two categories and create two separate queues and print them out\n  \"\"\"\n\n  Q1 = deque()\n  Q2 = deque()\n  for data in ilist:\n    if data &lt; 1000:\n      Q1.append(data)\n    if data &gt;=1000:\n      Q2.append(data)\n  \n  print(\"Q1:\")\n  while len(Q1)!=0:\n    x = Q1.popleft()\n    print(x, end=' ')\n\n  print(\"\\nQ2:\")\n  while len(Q2)!=0:\n    x = Q2.popleft()\n    print(x, end=' ')\n\n\nCategorizer([150, 350, 500, 700, 1000, 1200, 1550])\n\nQ1:\n150 350 500 700 \nQ2:\n1000 1200 1550 \n\n\n\nCategorizer([50, 250, 900, 999, 1001, 1900, 2550])\n\nQ1:\n50 250 900 999 \nQ2:\n1001 1900 2550 \n\n\nAnother common application of a queue is to adjust and create a balance between a fast producer of data and a slow consumer of data. For example, assume that a CPU is connected to a printer. The speed of a printer is not comparable with the speed of a CPU. If the CPU waits for the printer to print some data created by the CPU, the CPU would be idle for a long time. The solution is a queue. The CPU creates as many chunks of data as the queue can hold and sends them to the queue. The CPU is now free to do other jobs. The chunks are dequeued slowly and printed by the printer. The queue used for this purpose is normally referred to as a spool queue.\n\n\nE.3.4 Queue implementation\nAt the ADT level, we use the queue and its four operations (queue, enqueue, dequeue, and empty): at the implementation level, we need to choose a data structure to implement it. A queue ADT can be implemented using either an array or a linked list.\n\n\n\nWe can write four algorithms in pseudocode for the four operations we defined for queues in each implementation. We described algorithms to handle arrays and linked lists in Chapter 11: we can modify those algorithms to create the four algorithms we need for queues: queue, enqueue, dequeue, and empty. These algorithms are easier than those presented in Chapter 11, because insertion is done only at the end of the queue and deletion is done only at the front of the queue.\n\nE.3.4.1 Exercise 2: In the array implementation we have a record with three fields. The first field can be used to store information about the queue: we have used this as a count field that shows the current number of data items in the queue. The second field is an integer that holds the index of the front element. The third field is also an integer, which holds the index of the rear element.\n\n\nimport numpy as np\nn = 10 # number of elements allocated to the array\nA = np.zeros(n, dtype=np.int8)\n\n\n# Create an empty queue\ndef queue():\n  Q={\"count\":0, \"rear\":-1, \"front\":-1}\n  return Q\n\ndef enqueue(Q,A,x):\n  if Q[\"front\"]==-1:\n    Q[\"front\"] = 0\n  Q[\"rear\"] = Q[\"rear\"]+1\n  Q[\"count\"] = Q[\"count\"]+1\n  A[Q[\"rear\"]] = x\n\ndef dequeue(Q,A):\n  if Q[\"count\"] ==0:\n    return None\n  x = A[Q[\"front\"]]\n  A[Q[\"front\"]] = 0\n  Q[\"front\"] = Q[\"front\"]+1\n  Q[\"count\"] = Q[\"count\"]-1  \n  return x\n\ndef empty(S):\n  if Q[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nQ = queue()\nenqueue(Q,A,20)\nprint(Q,A)\nenqueue(Q,A,78)\nprint(Q,A)\nenqueue(Q,A,30)\nprint(Q,A)\n\n{'count': 1, 'rear': 0, 'front': 0} [20  0  0  0  0  0  0  0  0  0]\n{'count': 2, 'rear': 1, 'front': 0} [20 78  0  0  0  0  0  0  0  0]\n{'count': 3, 'rear': 2, 'front': 0} [20 78 30  0  0  0  0  0  0  0]\n\n\n\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\n\n20\n{'count': 2, 'rear': 2, 'front': 1} [ 0 78 30  0  0  0  0  0  0  0]\n78\n{'count': 1, 'rear': 2, 'front': 2} [ 0  0 30  0  0  0  0  0  0  0]\n30\n{'count': 0, 'rear': 2, 'front': 3} [0 0 0 0 0 0 0 0 0 0]\n\n\n\nenqueue(Q,A,20)\nprint(Q,A)\nenqueue(Q,A,78)\nprint(Q,A)\nenqueue(Q,A,30)\nprint(Q,A)\n\n{'count': 1, 'rear': 3, 'front': 3} [ 0  0  0 20  0  0  0  0  0  0]\n{'count': 2, 'rear': 4, 'front': 3} [ 0  0  0 20 78  0  0  0  0  0]\n{'count': 3, 'rear': 5, 'front': 3} [ 0  0  0 20 78 30  0  0  0  0]\n\n\n\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\nprint(dequeue(Q,A))\nprint(Q,A)\n\n20\n{'count': 2, 'rear': 5, 'front': 4} [ 0  0  0  0 78 30  0  0  0  0]\n78\n{'count': 1, 'rear': 5, 'front': 5} [ 0  0  0  0  0 30  0  0  0  0]\n30\n{'count': 0, 'rear': 5, 'front': 6} [0 0 0 0 0 0 0 0 0 0]\n\n\n\nE.3.4.2 Exercise 3: The linked list implementation is similar: we have an extra record that has the name of the queue. This node also has three fields: a count, a pointer that points to the front element, and a pointer that points to the rear element.\n\n\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.link = None\n  def __repr__(self):\n    return str(self.data)\n\nclass LinkedList:\n  def __init__(self, nodes=None):\n    self.head = None\n    if nodes:\n      node = Node(data=nodes.pop(0)) #pop will pop out the first entry of the list\n      self.head = node\n      for elem in nodes:\n        node.link = Node(data=elem)\n        node = node.link\n  def __repr__(self): #This is to beautify printing, don't worry about this\n    node = self.head\n    nodes = []\n    while node is not None:\n      nodes.append(str(node.data))\n      node = node.link\n    nodes.append(\"None\")\n    return \" -&gt; \".join(nodes)\n\n\nL = LinkedList(0)\n\n\n# Create an empty queue\ndef queue():\n  Q={\"count\":0, \"front\":None, \"rear\":None}\n  return Q\n\ndef enqueue(Q,L,x):\n  new = Node(x)\n  if Q[\"count\"] == 0:\n    L.head = new\n    Q[\"front\"] = L.head\n    Q[\"rear\"] = L.head\n  else:\n    Q[\"rear\"].link = new\n    Q[\"rear\"] = Q[\"rear\"].link\n  Q[\"count\"] = Q[\"count\"]+1\n\n\ndef dequeue(Q,L):\n  if Q[\"count\"] ==0:\n    return None\n  x = Q[\"front\"]\n  if Q[\"count\"] ==1:\n    Q[\"front\"] = None\n    Q[\"rear\"] = None\n  else:\n    Q[\"front\"] = Q[\"front\"].link\n  L.head = Q[\"front\"]\n  Q[\"count\"] = Q[\"count\"] - 1\n  return x\n\ndef empty(Q):\n  if Q[\"count\"] == 0:\n    return True\n  else:\n    return False \n\n\nQ = queue()\nenqueue(Q,L,20)\nprint(Q,L)\nenqueue(Q,L,78)\nprint(Q,L)\nenqueue(Q,L,30)\nprint(Q,L)\n\n{'count': 1, 'front': 20, 'rear': 20} 20 -&gt; None\n{'count': 2, 'front': 20, 'rear': 78} 20 -&gt; 78 -&gt; None\n{'count': 3, 'front': 20, 'rear': 30} 20 -&gt; 78 -&gt; 30 -&gt; None\n\n\n\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\n\n20\n{'count': 2, 'front': 78, 'rear': 30} 78 -&gt; 30 -&gt; None\n78\n{'count': 1, 'front': 30, 'rear': 30} 30 -&gt; None\n30\n{'count': 0, 'front': None, 'rear': None} None\n\n\n\nenqueue(Q,L,20)\nprint(Q,L)\nenqueue(Q,L,78)\nprint(Q,L)\nenqueue(Q,L,30)\nprint(Q,L)\n\n{'count': 1, 'front': 20, 'rear': 20} 20 -&gt; None\n{'count': 2, 'front': 20, 'rear': 78} 20 -&gt; 78 -&gt; None\n{'count': 3, 'front': 20, 'rear': 30} 20 -&gt; 78 -&gt; 30 -&gt; None\n\n\n\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\nprint(dequeue(Q,L))\nprint(Q,L)\n\n20\n{'count': 2, 'front': 78, 'rear': 30} 78 -&gt; 30 -&gt; None\n78\n{'count': 1, 'front': 30, 'rear': 30} 30 -&gt; None\n30\n{'count': 0, 'front': None, 'rear': None} None"
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#general-linear-lists",
    "href": "06_Abstract_data_types_sol.html#general-linear-lists",
    "title": "Appendix E — Abstract Data Types",
    "section": "E.4 General linear lists",
    "text": "E.4 General linear lists\nThis topic is beyond our scope."
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#trees",
    "href": "06_Abstract_data_types_sol.html#trees",
    "title": "Appendix E — Abstract Data Types",
    "section": "E.5 Trees",
    "text": "E.5 Trees\nA tree consists of a finite set of elements, called nodes (or vertices), and a finite set of directed lines, called arcs, that connect pairs of the nodes. If the tree is not empty, one of the nodes, called the root, has no incoming arcs. The other nodes in a tree can be reached from the root by following a unique path, which is a sequence of consecutive arcs. Tree structures are normally drawn upside down with the root at the top as shown below:\n\n\n\nWe can divide the vertices in a tree into three categories: the root, leaves, and the internal nodes. The following showsthe number of outgoing and incoming arcs allowed for each type of node.\n\n\n\n\nType of node\nIncoming arc\nOutgoing arc\n\n\n\n\nroot\n0\n0 or more\n\n\nleaf\n1\n0\n\n\ninternal\n1\n1 or more\n\n\n\n\nA node that is directly accessible (through a single arc) from a given node is called the child: the node from which the child is directly accessible is called a parent. Nodes with a common parent are called siblings. Descendents of a node are all nodes that can be reached by that node, and a node from which all descendents can be reached is called an ancestor. Each node in a tree may have a subtree.\nThe subtree of each node includes one of its children and all descendents of that child. Figure below shows all subtrees for the tree in Figure above\n\n\n\nAlthough trees have many applications in computer science, such as index files, their study is beyond the scope of this book. We introduce trees as a prelude to discussing one special type of tree, binary trees.\n\nE.5.1 Binary trees\nA binary tree is a tree in which no node can have more than two subtrees. In other words, a node can have zero, one, or two subtrees. These subtrees are designated as the left subtree and the right subtree. Figure below shows a binary tree with its two subtrees. Note that each subtree is itself a binary tree.\n\n\n\n\nE.5.1.1 Recursive definition of binary trees\nIn Chapter 8 we introduced the recursive definition of an algorithm. We can also define a structure or an ADT recursively. The following gives the recursive definition of a binary tree. Note that, based on this definition, a binary tree can have a root, but each subtree can also have a root.\n\nA binary tree is either empty or consists of a node, root, with two subtrees, in which each subtree is also a binary tree.\n\nFigure below shows eight trees, the first of which is an empty binary tree (sometimes called a null binary tree).\n\n\n\n\n\n\nE.5.2 Operations on binary trees\nThe six most common operations defined for a binary tree are tree (creates an empty tree) insert, delete, retrieve, empty and traversal. The first five are complex and beyond the scope of this book. We discuss binary tree traversal in this section.\n\nE.5.2.1 Binary tree traversals\nA binary tree traversal requires that each node of the tree be processed once and only once in a predetermined sequence. The two general approaches to the traversal sequence are depth-first and breadth-first traversal.\n\nE.5.2.1.1 Depth-first traversals\nGiven that a binary tree consists of a root, a left subtree, and a right subtree, we can define six different depth-first traversal sequences. Computer scientists have assigned standard names to three of these sequences in the literature: the other three are unnamed but are easily derived. The standard traversals are shown in Figure below.\n\n\n\n\nPreorder traversal. In preorder traversal the root node is processed first, followed by the left subtree and then the right subtree. The prefix pre indicates that the root node is processed before the subtrees.\nInorder traversal. In inorder traversal the left subtree is processed first, then the root node, and finally the right subtree. The prefix in indicates that the root node is processed between the subtrees.\nPostorder traversal. In postorder traversal the root node is processed after the left and right subtrees have been processed. The prefix post indicates that the root is processed after the subtrees.\n\n\nE.5.2.2 Example 5: Figure below shows how we visit each node in a tree using preorder traversal. The figure also shows the walking order. In preorder traversal we visit a node when we pass from its left side. The nodes are visited in this order: A, B, C, D, E, F.\n\n\n\n\n\n\nE.5.2.2.1 Breadth-first traversals\nIn breadth-first traversal of a binary tree we process all the children of a node before proceeding with the next generation. As with depth-first traversals, we can trace the traversal with a walk.\n\nE.5.2.3 Example 6: Figure below shows how we visit each node in a tree using breadth-first traversal. The figure also shows the walking order. The traversal order is A, B, E, C, D, F.\n\n\n\n\n\n\n\nE.5.2.4 Binary tree applications\n\nE.5.2.4.1 Expression trees\nAn arithmetic expression can be represented in three different formats: infix, postfix, and prefix. In an infix notation, the operator comes between the two operands. In postfix notation, the operator comes after its two operands, and in prefix notation it comes before the two operands. These formats are shown below for the addition of two operands A and B.\n\nPrefix: + A B\nInfix: A + B\nPostfix: A B +\n\nAlthough we use infix notation in our algorithms and in programming languages, the compiler often changes them to postfix notation before evaluating them. One way to do this conversion is to create an expression tree. In an expression tree, the root and the internal nodes are operators and the leaves are the operands. The three standard traversals (preorder, inorder, and postorder) then represent the three different expression formats: infix , postfix , and prefix. The inorder traversal produces the infix expression, the postorder traversal produces the postfix expression, and the preorder traversal produces the prefix expression. Figure below shows an expression and its expression tree. Note that only the infix notation needs parentheses.\n\n\n\n\n\n\n\nE.5.3 Binary search trees\nA binary search tree (BST) is a binary tree with one extra property: the key value of each node is greater than the key values of all nodes in each left subtree and smaller than the value of all nodes in each right subtree. Figure below shows the idea.\n\n\n\n\nE.5.3.1 Example 7: Figure below shows some binary trees that are BSTs and some that are not. Note that a tree is a BST if all its subtrees are BSTs and the whole tree is also a BST.\n\n\n\n\n\nE.5.3.1.1 BST implementation\nBSTs can be implemented using either arrays or linked lists. However, linked list structures are more common and more efficient. A linear implementation uses nodes with two pointers, left and right. The left pointer points to the left subtree and the right pointer points to the right subtree. If the left subtree is empty, the left pointer is null: if the right subtree is empty, the right pointer is null. Figure below shows a BST in which the data field of each node is a record.\n\n\n\n\nclass tree:\n  def __init__(self):\n    self.data=0\n    self.left=None\n    self.right=None\n  def __repr__(self):\n    lines, *_ = self._display_aux()\n    return \"\\n\".join(lines)\n  def _display_aux(self):\n    # https://stackoverflow.com/questions/34012886/print-binary-tree-level-by-level-in-python\n    \"\"\"Returns list of strings, width, height, and horizontal coordinate of the root.\"\"\"\n    # No child.\n    if self.right is None and self.left is None:\n      line = '%s' % self.data\n      width = len(line)\n      height = 1\n      middle = width // 2\n      return [line], width, height, middle\n\n    # Only left child.\n    if self.right is None:\n      lines, n, p, x = self.left._display_aux()\n      s = '%s' % self.data\n      u = len(s)\n      first_line = (x + 1) * ' ' + (n - x - 1) * '_' + s\n      second_line = x * ' ' + '/' + (n - x - 1 + u) * ' '\n      shifted_lines = [line + u * ' ' for line in lines]\n      return [first_line, second_line] + shifted_lines, n + u, p + 2, n + u // 2\n\n    # Only right child.\n    if self.left is None:\n      lines, n, p, x = self.right._display_aux()\n      s = '%s' % self.data\n      u = len(s)\n      first_line = s + x * '_' + (n - x) * ' '\n      second_line = (u + x) * ' ' + '\\\\' + (n - x - 1) * ' '\n      shifted_lines = [u * ' ' + line for line in lines]\n      return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2\n\n    # Two children.\n    left, n, p, x = self.left._display_aux()\n    right, m, q, y = self.right._display_aux()\n    s = '%s' % self.data\n    u = len(s)\n    first_line = (x + 1) * ' ' + (n - x - 1) * '_' + s + y * '_' + (m - y) * ' '\n    second_line = x * ' ' + '/' + (n - x - 1 + u + y) * ' ' + '\\\\' + (m - y - 1) * ' '\n    if p &lt; q:\n      left += [n * ' '] * (q - p)\n    elif q &lt; p:\n      right += [m * ' '] * (p - q)\n    zipped_lines = zip(left, right)\n    lines = [first_line, second_line] + [a + u * ' ' + b for a, b in zipped_lines]\n    return lines, n + m + u, max(p, q) + 2, n + u // 2    \n\ndef create_tree(root,val):  # create a binary tree\n  newnode=tree()\n  newnode.data=val\n  newnode.left=None\n  newnode.right=None\n  if root==None:\n    root=newnode\n    return root\n  else:\n    current=root\n    while current!=None:\n      backup=current\n      if current.data &gt; val:\n        current=current.left\n      else:\n        current=current.right\n    if backup.data &gt;val:\n      backup.left=newnode\n    else:\n      backup.right=newnode\n  return root\n\n\ndef inorder(ptr):   # Inorder\n  if ptr!=None:\n    inorder(ptr.left)\n    print(ptr.data, end=' ')\n    inorder(ptr.right)\n\n\ndata=[17,6,3,14,19]\nptr=None\nroot=None\nfor i in range(len(data)):\n  ptr=create_tree(ptr,data[i])\n\n\nptr\n\n  __17_ \n /     \\\n 6_   19\n/  \\    \n3 14    \n\n\nA very interesting property of a BST is that if we apply the inorder traversal of a binary tree, the elements that are visited are sorted in ascending order. For example, the three BSTs in Figure above, when traversed in the order gives the list (3, 6, 17), (17, 19), and (3, 6, 14, 17, 19).\n\nAn inorder traversal of a BST creates a list that is sorted in ascending order.\n\n\nE.5.3.2 Example 8: The code below is the inorder traversal of a binary search tree.\n\n\nprint('=======================================================')\nprint('Inorder：')\ninorder(ptr) \nprint()\n\n=======================================================\nInorder：\n3 6 14 17 19 \n\n\n\nE.5.3.3 Exercise 4: Try to write the postorder and preorder traversal of the above tree.\n\n\ndef postorder(ptr):  # Postorder\n  if ptr!=None:\n    postorder(ptr.left)\n    postorder(ptr.right)\n    print(ptr.data, end=' ')\n\ndef preorder(ptr):   # Preorder\n  if ptr!=None:\n    print(ptr.data, end= ' ')\n    preorder(ptr.left)\n    preorder(ptr.right)\n\n\nprint('=======================================================')\nprint('Postorder：')\npostorder(ptr)\nprint()\nprint('=======================================================')\nprint('Preorder：')\npreorder(ptr)\nprint() \n\n=======================================================\nPostorder：\n3 14 6 19 17 \n=======================================================\nPreorder：\n17 6 3 14 19 \n\n\n\n\nE.5.3.3.1 Binary search tree ADTs\nhttps://visualgo.net/en/bst\nThe ADT for a binary search tree is similar to the one we defined for a general linear list with the same operation. As a matter of fact, we see more BST lists than general linear lists today. The reason is that searching a BST is more efficient that searching a linear list: a general linear list uses sequential searching, but BSTs use a version of binary search.\nAnother feature that makes a BST interesting is that we can use a version of the binary search we used in Chapter 8 for a binary search tree. Figure below shows the UML for a BST search.\n\n\n\n\nE.5.3.4 Exercise 5: Search the above tree.\n\n\ndef search(ptr,val):    \n  i=1\n  while True:\n    if ptr==None:    \n      return \"Not Found\"\n    if ptr.data==val:      \n      print('Total search number %d'%i)\n      return \"Found\"\n    elif ptr.data &gt; val: \n      ptr=ptr.left\n    else:\n      ptr=ptr.right\n    i+=1\n\n\nsearch(ptr, 20)\n\n'Not Found'\n\n\n\nsearch(ptr, 14)\n\nTotal search number 3\n\n\n'Found'"
  },
  {
    "objectID": "06_Abstract_data_types_sol.html#graphs",
    "href": "06_Abstract_data_types_sol.html#graphs",
    "title": "Appendix E — Abstract Data Types",
    "section": "E.6 Graphs",
    "text": "E.6 Graphs\nA graph is an ADT made of a set of nodes, called vertices, and set of lines connecting the vertices, called edges or arcs. Whereas a tree defines a hierarchical structure in which a node can have only one single parent, each node in a graph can have one or more parents. Graphs may be either directed or undirected. In a directed graph, or digraph, each edge, which connects two vertices, has a direction (shown in the figure by an arrowhead) from one vertex to the other. In an undirected graph, there is no direction. Figure below shows an example of both a directed graph (a) and an undirected graph (b).\n\n\n\nThe vertices in a graph can represent objects or concepts and the edges or arcs can represent a relationship between those objects or concepts. If a graph is directed, the relations are one-way: if a graph is undirected, the relation is two-way.\nFor instance, a map of cities and the roads connecting the cities can be represented in a computer using an undirected graph. The cities are vertices and the undirected edges are the roads that connect them. If we want to show the distances between the cities, we can use weighted graphs, in which each edge has a weight that represent the distance between two cities connected by that edge. Another application of graphs is in computer networks (Chapter 6). The vertices can represent the nodes or hubs; the edges can represent the route. Each edge can have a weight that defines the cost of reaching from one hub to the adjacent hub. A router can use graph algorithms to find the shortest path between itself and the final destination of a packet."
  },
  {
    "objectID": "Assignment 1_sol.html#which-of-the-following-equals-to-false",
    "href": "Assignment 1_sol.html#which-of-the-following-equals-to-false",
    "title": "Appendix F — Assignment 1",
    "section": "F.1 (1) Which of the following equals to False?",
    "text": "F.1 (1) Which of the following equals to False?\n\n\\((1 == 3)\\) or \\((8 == 8)\\)\n\n\\((2 + 2 == 4)\\) and not \\((2 + 2 == 5)\\) and \\((2 * 2 == 2 + 2)\\)\n\n\\((2 + 2 == 4)\\) and \\((2 + 8 == 5)\\) and \\((2 * 2 == 2 + 2)\\)\n\n\\((3 &lt; 5)\\) or \\((1 + 5 == 6)\\)\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 1_sol.html#what-should-spam-3-evaluate-to",
    "href": "Assignment 1_sol.html#what-should-spam-3-evaluate-to",
    "title": "Appendix F — Assignment 1",
    "section": "F.2 (2) What should ‘spam’  3* evaluate to?",
    "text": "F.2 (2) What should ‘spam’  3* evaluate to?\n\n‘ssspppaaammm’\n\n‘spam’ ‘spam’ ‘spam’\n\n‘spamssppaamm’\n\n‘spamspamspam’\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 1_sol.html#assume-that-we-execute-the-following-assignnment-statment",
    "href": "Assignment 1_sol.html#assume-that-we-execute-the-following-assignnment-statment",
    "title": "Appendix F — Assignment 1",
    "section": "F.3 (3) Assume that we execute the following assignnment statment:",
    "text": "F.3 (3) Assume that we execute the following assignnment statment:\nspam1 = input()\nspam2 = int(spam1)\nspam3 = spam2 + 18\n\nwhich variable has different data type than others?\n\nspam1\n\nspam2\n\nspam3\n\nAll of them have same data type\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 1_sol.html#which-of-the-following-is-not-a-data-type",
    "href": "Assignment 1_sol.html#which-of-the-following-is-not-a-data-type",
    "title": "Appendix F — Assignment 1",
    "section": "F.4 (4) Which of the following is not a data type?",
    "text": "F.4 (4) Which of the following is not a data type?\n\nintegers\n\ndictionary\n\nbook\n\nstrings\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 1_sol.html#what-does-the-variable-monkey-contain-after-the-following-code-runs",
    "href": "Assignment 1_sol.html#what-does-the-variable-monkey-contain-after-the-following-code-runs",
    "title": "Appendix F — Assignment 1",
    "section": "F.5 (5) What does the variable monkey contain after the following code runs?",
    "text": "F.5 (5) What does the variable monkey contain after the following code runs?\nmonkey = 25\nmonkey + 2\nmonkey - 5\n\n22\n\n27\n\n25\n\nNone of above\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 1_sol.html#why-does-this-expression-cause-an-error-how-can-you-fix-it",
    "href": "Assignment 1_sol.html#why-does-this-expression-cause-an-error-how-can-you-fix-it",
    "title": "Appendix F — Assignment 1",
    "section": "F.6 (6) Why does this expression cause an error? How can you fix it?",
    "text": "F.6 (6) Why does this expression cause an error? How can you fix it?\n'I have read for ' + 20 + ' minutes already.'\n\nAns: Double click to answer the question\n\nThe expression causes an error because 20 is an integer, and only strings can be concatenated to other strings with the + operator. The correct way is ‘I have read for’ + str(20) + ’ minutes already.’."
  },
  {
    "objectID": "Assignment 1_sol.html#what-is-the-difference-between-the-equal-to-operator-and-the-assignment-operator",
    "href": "Assignment 1_sol.html#what-is-the-difference-between-the-equal-to-operator-and-the-assignment-operator",
    "title": "Appendix F — Assignment 1",
    "section": "F.7 (7) What is the difference between the equal to operator and the assignment operator?",
    "text": "F.7 (7) What is the difference between the equal to operator and the assignment operator?\n\nAns: Double click to answer the question\n\n== is the equal to operator that compares two values and evaluates to a Boolean, while = is the assignment operator that stores a value in a variable."
  },
  {
    "objectID": "Assignment 1_sol.html#what-the-difference-between-range10-range0-10-and-range0-10-1-in-a-for-loop",
    "href": "Assignment 1_sol.html#what-the-difference-between-range10-range0-10-and-range0-10-1-in-a-for-loop",
    "title": "Appendix F — Assignment 1",
    "section": "F.8 (8) What the difference between range(10), range(0, 10) and range(0, 10, 1) in a for loop?",
    "text": "F.8 (8) What the difference between range(10), range(0, 10) and range(0, 10, 1) in a for loop?\n\nAns: Double click to answer the question\n\nThey all do the same thing. The range(10) call ranges from 0 up to (but not including) 10, range(0, 10) explicitly tells the loop to start at 0, and range(0, 10, 1) explicitly tells the loop to increase the variable by 1 on each iteration."
  },
  {
    "objectID": "Assignment 1_sol.html#write-code-that-prints-hello-five-times-if-1-is-stored-in-spam-prints-sherry-10-times-if-18-is-stored-in-spam-and-prints-nsysu-if-anything-else-is-stored-in-spam.",
    "href": "Assignment 1_sol.html#write-code-that-prints-hello-five-times-if-1-is-stored-in-spam-prints-sherry-10-times-if-18-is-stored-in-spam-and-prints-nsysu-if-anything-else-is-stored-in-spam.",
    "title": "Appendix F — Assignment 1",
    "section": "F.9 (9) Write code that prints Hello five times if 1 is stored in spam, prints Sherry 10 times if 18 is stored in spam, and prints NSYSU if anything else is stored in spam.",
    "text": "F.9 (9) Write code that prints Hello five times if 1 is stored in spam, prints Sherry 10 times if 18 is stored in spam, and prints NSYSU if anything else is stored in spam.\n\n# coding your answer here\nif spam == 1:\n    for i in range(5):\n        print(\"Hello\")\nelif spam == 18:\n    for i in range(10):\n        print(\"Sherry\")\nelse:\n    print(\"NSYSU\")"
  },
  {
    "objectID": "Assignment 1_sol.html#write-a-simple-program-that-asks-the-user-to-enter-your-name-and-how-many-animes-have-you-known-if-true-the-program-should-ask-how-much-time-you-have-spent-on-watching-animes-and-print-be-sure-to-spend-time-studying-programming-else-print-youre-doing-great-in-this-course-congratulation.",
    "href": "Assignment 1_sol.html#write-a-simple-program-that-asks-the-user-to-enter-your-name-and-how-many-animes-have-you-known-if-true-the-program-should-ask-how-much-time-you-have-spent-on-watching-animes-and-print-be-sure-to-spend-time-studying-programming-else-print-youre-doing-great-in-this-course-congratulation.",
    "title": "Appendix F — Assignment 1",
    "section": "F.10 (10) Write a simple program that asks the user to enter your name and How many animes have you known?, if true the program should ask How much time you have spent on watching animes? and print Be sure to spend time studying programming!, else print You're doing great in this course! Congratulation!.",
    "text": "F.10 (10) Write a simple program that asks the user to enter your name and How many animes have you known?, if true the program should ask How much time you have spent on watching animes? and print Be sure to spend time studying programming!, else print You're doing great in this course! Congratulation!.\nsample output\nEnter your name:   \nSherry   \nHow many animes have you known?   \n5   \nHow much time you have spent on watching animes?   \n20   \nBe sure to spend time studying programming!   \n\nor\nEnter your name:   \nSherry   \nHow many animes have you known?   \n0   \nYou're doing great in this course! Congratulation!\n\n\n# coding your answer here\nname = ''\nwhile not name:\n    print(\"Enter your name: \")\n    name = input()\n\nprint(\"How many animes have you known?\")\nnumOfAnimes = int(input())\n\nif numOfAnimes:\n    print(\"How much time you have spent on watching animes?\")\n    time = int(input())\n    if time:\n        print(\"Be sure to spend time studying programming!\")\nelse:\n    print(\"You're doing great in this course! Congratulation!\")"
  },
  {
    "objectID": "Assignment 2_sol.html#what-statement-creates-a-function",
    "href": "Assignment 2_sol.html#what-statement-creates-a-function",
    "title": "Appendix G — Assignment 2",
    "section": "G.1 (1) What statement creates a function?",
    "text": "G.1 (1) What statement creates a function?\n\ndef\n\ndefinition\n\nDef\n\nDefinition\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 2_sol.html#according-to-the-following-program",
    "href": "Assignment 2_sol.html#according-to-the-following-program",
    "title": "Appendix G — Assignment 2",
    "section": "G.2 (2) According to the following program:",
    "text": "G.2 (2) According to the following program:\ndef math():   \n    math = 100\n    print(math)   \n\ndef nsysu():   \n    math = \"interesting\"\n    math()    \n    print(math)  \n\nmath = \"I love math!\"  \nWhat should the ouputs look like when you run nsysu() and print(math)?\n\nI love math! I love math!, I love math!\n\ninteresting, I love math!\n\n100 100, 100\n\n100 interesting, I love math!\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 2_sol.html#what-does-from-math-import-if-you-have-a-file-named-math.py-which-stores-many-functions",
    "href": "Assignment 2_sol.html#what-does-from-math-import-if-you-have-a-file-named-math.py-which-stores-many-functions",
    "title": "Appendix G — Assignment 2",
    "section": "G.3 (3) What does from math import * if you have a file named math.py, which stores many functions?",
    "text": "G.3 (3) What does from math import * if you have a file named math.py, which stores many functions?\n\nimport the first function in math.py\n\nimport all functions from math.py\n\nimport the last function in math.py\n\nmeaningless\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 2_sol.html#how-do-you-use-the-function-linspace-in-numpy-according-to-import-numpy-as-np",
    "href": "Assignment 2_sol.html#how-do-you-use-the-function-linspace-in-numpy-according-to-import-numpy-as-np",
    "title": "Appendix G — Assignment 2",
    "section": "G.4 (4) How do you use the function linspace() in numpy according to import numpy as np?",
    "text": "G.4 (4) How do you use the function linspace() in numpy according to import numpy as np?\n\nlinspace()\n\nnp linspace()\n\nnumpy.linspace()\n\nnp.linspace()\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 2_sol.html#what-is-the-data-type-of-none",
    "href": "Assignment 2_sol.html#what-is-the-data-type-of-none",
    "title": "Appendix G — Assignment 2",
    "section": "G.5 (5) What is the data type of None?",
    "text": "G.5 (5) What is the data type of None?\n\nstr\n\nNonetype\n\nbool\n\nlist\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 2_sol.html#why-are-functions-adventageous-to-have-in-your-programs",
    "href": "Assignment 2_sol.html#why-are-functions-adventageous-to-have-in-your-programs",
    "title": "Appendix G — Assignment 2",
    "section": "G.6 (6) Why are functions adventageous to have in your programs?",
    "text": "G.6 (6) Why are functions adventageous to have in your programs?\n\nAns: Double click to answer the question\n\nFunctions reduce the need for duplicate code. This makes programs shorter, easier to read, and easier to update."
  },
  {
    "objectID": "Assignment 2_sol.html#what-happens-to-variables-in-a-local-scope-when-the-function-call-returns",
    "href": "Assignment 2_sol.html#what-happens-to-variables-in-a-local-scope-when-the-function-call-returns",
    "title": "Appendix G — Assignment 2",
    "section": "G.7 (7) What happens to variables in a local scope when the function call returns?",
    "text": "G.7 (7) What happens to variables in a local scope when the function call returns?\n\nAns: Double click to answer the question\n\nWhen a function returns, the local scope is destroyed, and all the variables in it are forgotten."
  },
  {
    "objectID": "Assignment 2_sol.html#how-can-you-force-a-variable-in-a-function-to-refer-to-the-global-variable",
    "href": "Assignment 2_sol.html#how-can-you-force-a-variable-in-a-function-to-refer-to-the-global-variable",
    "title": "Appendix G — Assignment 2",
    "section": "G.8 (8) How can you force a variable in a function to refer to the global variable?",
    "text": "G.8 (8) How can you force a variable in a function to refer to the global variable?\n\nAns: Double click to answer the question\n\nA global statement will force a variable in a function to refer to the global variable."
  },
  {
    "objectID": "Assignment 2_sol.html#write-a-function-named-collatz-that-has-one-parameter-named-number.-if-number-is-even-then-collatz-should-print-number-2-and-return-this-value.-if-number-is-odd-then-collatz-should-print-and-return-3-number-1.",
    "href": "Assignment 2_sol.html#write-a-function-named-collatz-that-has-one-parameter-named-number.-if-number-is-even-then-collatz-should-print-number-2-and-return-this-value.-if-number-is-odd-then-collatz-should-print-and-return-3-number-1.",
    "title": "Appendix G — Assignment 2",
    "section": "G.9 (9) Write a function named collatz() that has one parameter named number. If number is even, then collatz should print number // 2 and return this value. If number is odd, then collatz should print and return 3 * number + 1.",
    "text": "G.9 (9) Write a function named collatz() that has one parameter named number. If number is even, then collatz should print number // 2 and return this value. If number is odd, then collatz should print and return 3 * number + 1.\n\ndef collatz(number):\n    \"\"\"\n    Parameters\n    ----------\n    number: int\n        The input number.\n    Returns\n    -------\n    number: int\n        The ouput number.\n    \"\"\"\n    # coding your answer here\n    if number % 2 == 0:\n        number = number // 2\n    else:\n        number = 3 * number + 1\n    print(number)\n    return(number)"
  },
  {
    "objectID": "Assignment 2_sol.html#continuing-from-the-previous-question-write-a-program-that-allows-the-user-to-type-in-an-interger-and-that-keeps-callig-collatz-on-the-number-until-the-function-returns-the-value-1.",
    "href": "Assignment 2_sol.html#continuing-from-the-previous-question-write-a-program-that-allows-the-user-to-type-in-an-interger-and-that-keeps-callig-collatz-on-the-number-until-the-function-returns-the-value-1.",
    "title": "Appendix G — Assignment 2",
    "section": "G.10 (10) Continuing from the previous question, write a program that allows the user to type in an interger and that keeps callig collatz() on the number until the function returns the value 1.",
    "text": "G.10 (10) Continuing from the previous question, write a program that allows the user to type in an interger and that keeps callig collatz() on the number until the function returns the value 1.\nsample output\nEnter number:   \n3      \n10   \n5   \n16   \n8   \n4   \n2   \n1\n\n\n# coding your answer here\nnumber = int(input(\"Enter number: \\n\"))\nwhile number != 1:\n    number = collatz(number)"
  },
  {
    "objectID": "Assignment 3_sol.html#suppose-spam-contains-the-list-a-b-c-d.-what-does-spamintint3-2-11-evaluate-to",
    "href": "Assignment 3_sol.html#suppose-spam-contains-the-list-a-b-c-d.-what-does-spamintint3-2-11-evaluate-to",
    "title": "Appendix H — Assignment 3",
    "section": "H.1 (1) Suppose spam contains the list [‘a’, ‘b’, ‘c’, ‘d’]. What does spam[int(int('3' * 2) // 11)] evaluate to?",
    "text": "H.1 (1) Suppose spam contains the list [‘a’, ‘b’, ‘c’, ‘d’]. What does spam[int(int('3' * 2) // 11)] evaluate to?\n\n‘a’\n\n‘b’\n\n‘c’\n\n‘d’\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 3_sol.html#suppose-bacon-contains-the-list-3.14-sherry-18-sherry-true.-what-does-bacon.append100-make-to-the-list-value-in-bacon-look-like",
    "href": "Assignment 3_sol.html#suppose-bacon-contains-the-list-3.14-sherry-18-sherry-true.-what-does-bacon.append100-make-to-the-list-value-in-bacon-look-like",
    "title": "Appendix H — Assignment 3",
    "section": "H.2 (2) Suppose bacon contains the list [3.14, ‘Sherry’, 18, ‘Sherry’, True]. What does bacon.append(100) make to the list value in bacon look like?",
    "text": "H.2 (2) Suppose bacon contains the list [3.14, ‘Sherry’, 18, ‘Sherry’, True]. What does bacon.append(100) make to the list value in bacon look like?\n\n[100, 3.14, ‘Sherry’, 18, ‘Sherry’, True]\n\n[3.14, ‘Sherry’, 18, ‘Sherry’, True]\n\n[3.14, ‘Sherry’, 18, ‘Sherry’, True, 100]\n\nNone of above\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 3_sol.html#how-would-you-assign-the-value-hello-as-the-third-value-in-a-list-stored-in-a-variable-named-computer",
    "href": "Assignment 3_sol.html#how-would-you-assign-the-value-hello-as-the-third-value-in-a-list-stored-in-a-variable-named-computer",
    "title": "Appendix H — Assignment 3",
    "section": "H.3 (3) How would you assign the value 'hello' as the third value in a list stored in a variable named computer?",
    "text": "H.3 (3) How would you assign the value 'hello' as the third value in a list stored in a variable named computer?\n\ncomputer[3] &lt;- ‘hello’\n\ncomputer[3] == ‘hello’\n\ncomputer[2] = ‘hello’\n\ncomputer[2] == ‘hello’\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 3_sol.html#what-is",
    "href": "Assignment 3_sol.html#what-is",
    "title": "Appendix H — Assignment 3",
    "section": "H.4 (4) What is []?",
    "text": "H.4 (4) What is []?\n\ndictionary\n\ntuple\n\nlist\n\ndataframe\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 3_sol.html#what-are-the-operators-for-list-concatenation-and-list-replication",
    "href": "Assignment 3_sol.html#what-are-the-operators-for-list-concatenation-and-list-replication",
    "title": "Appendix H — Assignment 3",
    "section": "H.5 (5) What are the operators for list concatenation and list replication?",
    "text": "H.5 (5) What are the operators for list concatenation and list replication?\n\n-, /\n\n+, **\n\n+, *\n\n-, //\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 3_sol.html#what-are-two-ways-to-remove-values-from-a-list",
    "href": "Assignment 3_sol.html#what-are-two-ways-to-remove-values-from-a-list",
    "title": "Appendix H — Assignment 3",
    "section": "H.6 (6) What are two ways to remove values from a list?",
    "text": "H.6 (6) What are two ways to remove values from a list?\n\nAns: Double click to answer the question\n\nThe del statement and the remove() list method are two ways to remove values from a list."
  },
  {
    "objectID": "Assignment 3_sol.html#what-is-the-difference-between-lists-and-tuples",
    "href": "Assignment 3_sol.html#what-is-the-difference-between-lists-and-tuples",
    "title": "Appendix H — Assignment 3",
    "section": "H.7 (7) What is the difference between lists and tuples?",
    "text": "H.7 (7) What is the difference between lists and tuples?\n\nAns: Double click to answer the question\n\nLists are mutable; they can have values added, removed, or changed. Tuples are immutable; they cannot be changed at all. Also, tuples are written using parentheses, ( ), while lists use the square brackets, [ ]."
  },
  {
    "objectID": "Assignment 3_sol.html#what-is-the-difference-between-copy.copy-and-copy.deepcopy",
    "href": "Assignment 3_sol.html#what-is-the-difference-between-copy.copy-and-copy.deepcopy",
    "title": "Appendix H — Assignment 3",
    "section": "H.8 (8) What is the difference between copy.copy() and copy.deepcopy()?",
    "text": "H.8 (8) What is the difference between copy.copy() and copy.deepcopy()?\n\nAns: Double click to answer the question\n\nThe copy.copy() function will do a shallow copy of a list, while the copy.deepcopy() function will do a deep copy of a list.\nThat is, only copy.deepcopy() will duplicate any lists inside the list."
  },
  {
    "objectID": "Assignment 3_sol.html#write-a-function-takes-a-list-value-as-an-argument-and-returns-a-string-with-all-the-items-separated-by-comma-and-a-space-with-and-inserted-before-the-last-item.",
    "href": "Assignment 3_sol.html#write-a-function-takes-a-list-value-as-an-argument-and-returns-a-string-with-all-the-items-separated-by-comma-and-a-space-with-and-inserted-before-the-last-item.",
    "title": "Appendix H — Assignment 3",
    "section": "H.9 (9) Write a function takes a list value as an argument and returns a string with all the items separated by comma and a space, with and inserted before the last item.",
    "text": "H.9 (9) Write a function takes a list value as an argument and returns a string with all the items separated by comma and a space, with and inserted before the last item.\nsample output:\nIf you enter a list ['Mathematics', 'computer', programming'], then you should get Mathematics, computer, and programming.\n\ndef list_to_string(spam):\n    \"\"\"\n    Parameters\n    ----------\n    spam: list\n        The input list.\n    Returns\n    -------\n    string: str\n        The ouput string.\n    \"\"\"\n    # coding your answer here\n    string = \"\"\n    for i in range(len(spam)):\n        if i != len(spam) - 1:\n            string = string + spam[i] + \", \"\n        else:\n            string = string + \"and \" + spam[i]\n    return(string)"
  },
  {
    "objectID": "Assignment 3_sol.html#say-you-have-a-list-of-lists-grid-where-each-value-in-the-inner-lists-is-a-one-character-string.-copy-the-grid-value-and-write-code-that-uses-it-to-print-the-image.",
    "href": "Assignment 3_sol.html#say-you-have-a-list-of-lists-grid-where-each-value-in-the-inner-lists-is-a-one-character-string.-copy-the-grid-value-and-write-code-that-uses-it-to-print-the-image.",
    "title": "Appendix H — Assignment 3",
    "section": "H.10 (10) Say you have a list of lists, grid, where each value in the inner lists is a one-character string. Copy the grid value and write code that uses it to print the image.",
    "text": "H.10 (10) Say you have a list of lists, grid, where each value in the inner lists is a one-character string. Copy the grid value and write code that uses it to print the image.\n\ngrid = [['.', '.', '.', '.', '.', '.'],\n        ['.', 'O', 'O', '.', '.', '.'],\n        ['O', 'O', 'O', 'O', '.', '.'],\n        ['O', 'O', 'O', 'O', 'O', '.'],\n        ['.', 'O', 'O', 'O', 'O', 'O'],\n        ['O', 'O', 'O', 'O', 'O', '.'],\n        ['O', 'O', 'O', 'O', '.', '.'],\n        ['.', 'O', 'O', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.']]\n\nsample output\n. . 00 . 00 . .   \n. 0000000 .   \n. 0000000 .   \n. . 00000 . .   \n. . . 000 . . .   \n. . . . 0 . . . .\n\nHint:\nIn order to print the image, you will need to use a loop in a loop.\n\n# coding your answer here\nfor i in range(len(grid[0])):\n    string = \"\"\n    for j in range(len(grid)):\n        string = string + grid[j][i]\n    print(string)"
  },
  {
    "objectID": "Assignment 4_sol.html#what-is-a-dictionary-in-python",
    "href": "Assignment 4_sol.html#what-is-a-dictionary-in-python",
    "title": "Appendix I — Assignment 4",
    "section": "I.1 (1) What is a dictionary in Python?",
    "text": "I.1 (1) What is a dictionary in Python?\n\nAn ordered sequence of elements\n\nA collection of unique elements\n\nA collection of key-value pairs\n\nA sequence of key-value pairs\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 4_sol.html#how-do-you-access-a-value-in-a-dictionary",
    "href": "Assignment 4_sol.html#how-do-you-access-a-value-in-a-dictionary",
    "title": "Appendix I — Assignment 4",
    "section": "I.2 (2) How do you access a value in a dictionary?",
    "text": "I.2 (2) How do you access a value in a dictionary?\n\nBy its index\n\nBy its value\n\nBy its key\n\nBy its position\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 4_sol.html#what-is-the-syntax-for-adding-an-element-to-a-dictionary-in-python",
    "href": "Assignment 4_sol.html#what-is-the-syntax-for-adding-an-element-to-a-dictionary-in-python",
    "title": "Appendix I — Assignment 4",
    "section": "I.3 (3) What is the syntax for adding an element to a dictionary in Python?",
    "text": "I.3 (3) What is the syntax for adding an element to a dictionary in Python?\n\nmy_dict.add(key, value)\n\nmy_dict[key] = value\n\nmy_dict.append(key, value)\n\nmy_dict.extend(key, value)\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 4_sol.html#what-is-a-set-in-python",
    "href": "Assignment 4_sol.html#what-is-a-set-in-python",
    "title": "Appendix I — Assignment 4",
    "section": "I.4 (4) What is a set in Python?",
    "text": "I.4 (4) What is a set in Python?\n\nAn ordered sequence of elements\n\nA collection of unique elements\n\nA collection of key-value pairs\n\nA sequence of key-value pairs\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 4_sol.html#what-is-the-syntax-for-creating-a-set-in-python",
    "href": "Assignment 4_sol.html#what-is-the-syntax-for-creating-a-set-in-python",
    "title": "Appendix I — Assignment 4",
    "section": "I.5 (5) What is the syntax for creating a set in Python?",
    "text": "I.5 (5) What is the syntax for creating a set in Python?\n\nmy_set = {1, 2, 3}\n\nmy_set = [1, 2, 3]\n\nmy_set = (1, 2, 3)\n\nmy_set = {‘1’, ‘2’, ‘3’}\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 4_sol.html#what-is-the-difference-between-a-dictionary-and-a-list-in-python-and-when-would-you-choose-to-use-one-over-the-other",
    "href": "Assignment 4_sol.html#what-is-the-difference-between-a-dictionary-and-a-list-in-python-and-when-would-you-choose-to-use-one-over-the-other",
    "title": "Appendix I — Assignment 4",
    "section": "I.6 (6) What is the difference between a dictionary and a list in Python, and when would you choose to use one over the other?",
    "text": "I.6 (6) What is the difference between a dictionary and a list in Python, and when would you choose to use one over the other?\n\nAns: Double click to answer the question\n\nThe main difference between a dictionary and a list in Python is that a dictionary stores data as key-value pairs, while a list stores data as a sequence of elements. You would choose to use a dictionary over a list when you need to store data in a way that can be easily looked up based on a unique key."
  },
  {
    "objectID": "Assignment 4_sol.html#how-do-you-check-if-a-key-exists-in-a-dictionary-in-python",
    "href": "Assignment 4_sol.html#how-do-you-check-if-a-key-exists-in-a-dictionary-in-python",
    "title": "Appendix I — Assignment 4",
    "section": "I.7 (7) How do you check if a key exists in a dictionary in Python?",
    "text": "I.7 (7) How do you check if a key exists in a dictionary in Python?\n\nAns: Double click to answer the question\n\nYou can use the in operator to check if a key exists in a dictionary. For example: if key in my_dict:"
  },
  {
    "objectID": "Assignment 4_sol.html#how-do-you-create-a-deep-copy-of-a-dictionary-in-python",
    "href": "Assignment 4_sol.html#how-do-you-create-a-deep-copy-of-a-dictionary-in-python",
    "title": "Appendix I — Assignment 4",
    "section": "I.8 (8) How do you create a deep copy of a dictionary in Python?",
    "text": "I.8 (8) How do you create a deep copy of a dictionary in Python?\n\nAns: Double click to answer the question\n\nYou can create a deep copy of a dictionary in Python using the copy() method with the .deepcopy() method from the copy module.\nFor example:\nimport copy\nnew_dict = copy.deepcopy(my_dict)"
  },
  {
    "objectID": "Assignment 4_sol.html#suppose-you-have-a-list-of-student-grades-and-you-want-to-find-the-top-performing-student-and-the-average-grade-for-each-subject.-write-a-program-that-does-the-following",
    "href": "Assignment 4_sol.html#suppose-you-have-a-list-of-student-grades-and-you-want-to-find-the-top-performing-student-and-the-average-grade-for-each-subject.-write-a-program-that-does-the-following",
    "title": "Appendix I — Assignment 4",
    "section": "I.9 (9) Suppose you have a list of student grades, and you want to find the top-performing student and the average grade for each subject. Write a program that does the following:",
    "text": "I.9 (9) Suppose you have a list of student grades, and you want to find the top-performing student and the average grade for each subject. Write a program that does the following:\n\nCreate a dictionary called grades that maps subject names to lists of grades for each student. Assume that each student has the same number of grades for each subject.\nCreate a dictionary called subject_averages that maps subject names to their average grades across all students.\nCreate a dictionary called student_totals that maps student names to their total grades across all subjects.\nCreate a variable called top_student that contains the name of the student with the highest total grade.\nPrint out the top-performing student’s name and total grade, as well as the average grade for each subject.\n\n\ngrades = {\n    'Math': [[90, 85, 92, 87, 94], [95, 88, 91, 89, 92], [87, 83, 85, 90, 89]],\n    'Science': [[82, 88, 89, 91, 85], [90, 86, 88, 87, 92], [85, 83, 87, 84, 89]],\n    'English': [[88, 85, 92, 86, 90], [91, 87, 89, 92, 85], [83, 86, 88, 87, 90]],\n}\n\n# coding your answer here\n\n# Create dictionary to store subject averages\nsubject_averages = {}\n\n# Create dictionary to store student totals\nstudent_totals = {}\n\n# Calculate subject averages and student totals\nfor subject, subject_grades in grades.items():\n    subject_total = 0\n    for student_grades in subject_grades:\n        student_name = f\"Student {subject_grades.index(student_grades) + 1}\"\n        student_total = sum(student_grades)\n        student_totals[student_name] = student_totals.get(student_name, 0) + student_total\n        subject_total += student_total\n    subject_averages[subject] = subject_total / (len(subject_grades) * len(subject_grades[0]))\n\n# Find top-performing student\ntop_student = max(student_totals, key=student_totals.get)\n\n# Print results\nprint(f\"Top-performing student: {top_student}, Total grade: {student_totals[top_student]}\")\nfor subject, average in subject_averages.items():\n    print(f\"{subject} average grade: {average}\")\n\nTop-performing student: Student 2, Total grade: 1342\nMath average grade: 89.13333333333334\nScience average grade: 87.06666666666666\nEnglish average grade: 87.93333333333334"
  },
  {
    "objectID": "Assignment 4_sol.html#write-a-program-that-creates-a-dictionary-students-that-maps-student-names-to-their-ages.-the-program-should-prompt-the-user-to-enter-the-names-and-ages-of-at-least-three-students-and-then-print-out-the-contents-of-the-students-dictionary.",
    "href": "Assignment 4_sol.html#write-a-program-that-creates-a-dictionary-students-that-maps-student-names-to-their-ages.-the-program-should-prompt-the-user-to-enter-the-names-and-ages-of-at-least-three-students-and-then-print-out-the-contents-of-the-students-dictionary.",
    "title": "Appendix I — Assignment 4",
    "section": "I.10 (10) Write a program that creates a dictionary students that maps student names to their ages. The program should prompt the user to enter the names and ages of at least three students, and then print out the contents of the students dictionary.",
    "text": "I.10 (10) Write a program that creates a dictionary students that maps student names to their ages. The program should prompt the user to enter the names and ages of at least three students, and then print out the contents of the students dictionary.\nsample output:\nEnter a student name (or 'q' to quit): Sherry   \nEnter the student's age: 18   \nEnter a student name (or 'q' to quit): Money   \nEnter the student's age: 3   \nEnter a student name (or 'q' to quit): Steve   \nEnter the student's age: 30   \nEnter a student name (or 'q' to quit): q   \nStudent dictionary:   \n{'Sherry': '18', 'Money': '3', 'Steve': '30'}\n\n\n# coding your answer here\nstudents = {}\n\nwhile True:\n    name = input(\"Enter a student name (or 'q' to quit): \")\n    if name == 'q':\n        break\n    age = input(\"Enter the student's age: \")\n    students[name] = age\n\nprint(\"Student dictionary:\")\nprint(students)"
  },
  {
    "objectID": "Assignment 5_sol.html#what-do-the-n-and-t-escape-characters-represent",
    "href": "Assignment 5_sol.html#what-do-the-n-and-t-escape-characters-represent",
    "title": "Appendix J — Assignment 5",
    "section": "J.1 (1) What do the \\n and \\t escape characters represent?",
    "text": "J.1 (1) What do the \\n and \\t escape characters represent?\n\nnewline, tab\n\nspace, tab\n\nnewline, backslash\n\nbackslash, space\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 5_sol.html#what-do-the-following-expressions-evaluate-to",
    "href": "Assignment 5_sol.html#what-do-the-following-expressions-evaluate-to",
    "title": "Appendix J — Assignment 5",
    "section": "J.2 (2) What do the following expressions evaluate to?",
    "text": "J.2 (2) What do the following expressions evaluate to?\n'Hello, world!'[3], 'Hello, world!'[4:], and 'Hello, world!'[:5]\n\n‘l’, ‘, world!’, and ‘Hello’\n\n‘o’, ‘lo, world!’, and ‘Hello,’\n\n‘l’, ‘o’, and ‘, world!’\n\n‘l’, ‘o, world!’, and ‘Hello’\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 5_sol.html#how-can-you-trim-whitespace-characters-from-the-beginning-or-the-end-of-a-string",
    "href": "Assignment 5_sol.html#how-can-you-trim-whitespace-characters-from-the-beginning-or-the-end-of-a-string",
    "title": "Appendix J — Assignment 5",
    "section": "J.3 (3) How can you trim whitespace characters from the beginning or the end of a string?",
    "text": "J.3 (3) How can you trim whitespace characters from the beginning or the end of a string?\n\nlstrip() and rjust()\n\ncenter() and rstrip()\n\nlstrip() and rstrip()\n\nNone of above\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 5_sol.html#what-do-the--.jointhere-can-be-only-one..split-evaluate-to",
    "href": "Assignment 5_sol.html#what-do-the--.jointhere-can-be-only-one..split-evaluate-to",
    "title": "Appendix J — Assignment 5",
    "section": "J.4 (4) What do the '-'.join('There can be only one.'.split()) evaluate to?",
    "text": "J.4 (4) What do the '-'.join('There can be only one.'.split()) evaluate to?\n\n‘There can be only one.’\n\n‘There-can be-only-one.’\n\n‘There can-be only-one.’\n\n‘There-can-be-only-one.’\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 5_sol.html#which-of-the-following-methods-can-be-used-to-check-if-a-string-contains-only-numeric-characters",
    "href": "Assignment 5_sol.html#which-of-the-following-methods-can-be-used-to-check-if-a-string-contains-only-numeric-characters",
    "title": "Appendix J — Assignment 5",
    "section": "J.5 (5) Which of the following methods can be used to check if a string contains only numeric characters?",
    "text": "J.5 (5) Which of the following methods can be used to check if a string contains only numeric characters?\n\nisnumeric()\n\nisnum()\n\nisdecimal()\n\nisdigit()\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 5_sol.html#how-can-you-access-a-specific-character-in-a-string-in-python",
    "href": "Assignment 5_sol.html#how-can-you-access-a-specific-character-in-a-string-in-python",
    "title": "Appendix J — Assignment 5",
    "section": "J.6 (6) How can you access a specific character in a string in Python?",
    "text": "J.6 (6) How can you access a specific character in a string in Python?\n\nAns: Double click to answer the question\n\nYou can access a specific character in a string in Python using indexing."
  },
  {
    "objectID": "Assignment 5_sol.html#how-can-you-remove-all-occurrences-of-a-specific-character-from-a-string-in-python",
    "href": "Assignment 5_sol.html#how-can-you-remove-all-occurrences-of-a-specific-character-from-a-string-in-python",
    "title": "Appendix J — Assignment 5",
    "section": "J.7 (7) How can you remove all occurrences of a specific character from a string in Python?",
    "text": "J.7 (7) How can you remove all occurrences of a specific character from a string in Python?\n\nAns: Double click to answer the question\n\nYou can remove all occurrences of a specific character from a string in Python using the replace() method. For example, “hello”.replace(“l”, ““) will return”heo”."
  },
  {
    "objectID": "Assignment 5_sol.html#how-can-you-convert-a-string-to-a-list-of-characters-in-python",
    "href": "Assignment 5_sol.html#how-can-you-convert-a-string-to-a-list-of-characters-in-python",
    "title": "Appendix J — Assignment 5",
    "section": "J.8 (8) How can you convert a string to a list of characters in Python?",
    "text": "J.8 (8) How can you convert a string to a list of characters in Python?\n\nAns: Double click to answer the question\n\nYou can convert a string to a list of characters in Python using list(). For example, list(“hello”) will return [“h”, “e”, “l”, “l”, “o”]."
  },
  {
    "objectID": "Assignment 5_sol.html#write-a-program-that-prompts-the-user-to-enter-a-string-and-then-finds-the-most-common-word-in-the-string.",
    "href": "Assignment 5_sol.html#write-a-program-that-prompts-the-user-to-enter-a-string-and-then-finds-the-most-common-word-in-the-string.",
    "title": "Appendix J — Assignment 5",
    "section": "J.9 (9) Write a program that prompts the user to enter a string, and then finds the most common word in the string.",
    "text": "J.9 (9) Write a program that prompts the user to enter a string, and then finds the most common word in the string.\nHint:\n1. Convert the string to lowercase and split it into a list of words. 2. Create a dictionary called word_freq to store the frequency of each word in the list. 3. Find the most common word in the dictionary by using the max() function with the key argument set to word_freq.get, which returns the value associated with each word in the dictionary.\nsample output:\nInput: `The quick brown fox jumps over the lazy dog. The dog jumps over the fence.`   \nOutput: the\n\n\n# Program to find the most common word in a string\n\nstring = input(\"Enter a string: \")\n\n# coding your answer here\n# Converting the string to lowercase and splitting it into words\nwords = string.lower().split()\n\n# Creating a dictionary to store word frequencies\nword_freq = {}\n\n# Counting the frequency of each word in the list of words\nfor word in words:\n    if word in word_freq:\n        word_freq[word] += 1\n    else:\n        word_freq[word] = 1\n\n# Finding the most common word\nmost_common_word = max(word_freq, key=word_freq.get)\n\nprint(\"Most common word:\", most_common_word)"
  },
  {
    "objectID": "Assignment 5_sol.html#stringy-cards-is-a-card-game-that-requires-players-to-manipulate-strings-in-order-to-win.-the-objective-is-to-have-a-higher-score-than-the-dealer-without-going-over-21.",
    "href": "Assignment 5_sol.html#stringy-cards-is-a-card-game-that-requires-players-to-manipulate-strings-in-order-to-win.-the-objective-is-to-have-a-higher-score-than-the-dealer-without-going-over-21.",
    "title": "Appendix J — Assignment 5",
    "section": "J.10 (10) “Stringy Cards” is a card game that requires players to manipulate strings in order to win. The objective is to have a higher score than the dealer without going over 21.",
    "text": "J.10 (10) “Stringy Cards” is a card game that requires players to manipulate strings in order to win. The objective is to have a higher score than the dealer without going over 21.\nRule:\n1. Players are dealt two cards face up, and the dealer is dealt two cards, one face up and one face down. 2. The player’s objective is to have a higher score than the dealer without going over 21. 3. Each card has a point value based on its rank. 4. Players can choose to “hit” (take another card) or “stand” (keep their current hand). 5. After each round, the player is given a string to form using the cards in their hand for bonus points. 6. The game continues until the player decides to quit or runs out of cards. 7. The player’s score is tallied at the end, taking into account any bonus points earned or lost during the game. The player with the highest score wins the game.\n\nimport random\n\n# Define a list of card ranks and suits\nranks = [\"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"]\nsuits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\n\n# Initialize a dictionary to store the values of the cards\n# coding your answer here\nvalues = {\n    \"Ace\": 11,\n    \"2\": 2,\n    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n    \"8\": 8,\n    \"9\": 9,\n    \"10\": 10,\n    \"Jack\": 10,\n    \"Queen\": 10,\n    \"King\": 10\n}\n\n# Initialize a list to store the deck of cards\ndeck = []\n\n# Create the deck of cards\nfor suit in suits:\n    for rank in ranks:\n        card = rank + \" of \" + suit\n        deck.append(card)\n\n# Shuffle the deck of cards\nrandom.shuffle(deck)\n\n# Deal two cards to the player and the dealer\nplayer_hand = [deck.pop(), deck.pop()]\ndealer_hand = [deck.pop(), deck.pop()]\n\n# Initialize variables to keep track of the scores and the game status\nplayer_score = 0\ndealer_score = 0\ngame_over = False\n\n# Helper function to calculate the score of a hand\n# coding your answer here\ndef calculate_score(hand):\n    score = 0\n    aces = 0\n    for card in hand:\n        rank = card.split()[0]\n        value = values[rank]\n        score += value\n        if rank == \"Ace\":\n            aces += 1\n    while aces &gt; 0 and score &gt; 21:\n        score -= 10\n        aces -= 1\n    return score\n\n# Helper function to print the hands and scores\ndef print_hands_and_scores():\n    print(\"Player's hand: {}, Score: {}\".format(\", \".join(player_hand), player_score))\n    print(\"Dealer's hand: {}, Score: {}\".format(\", \".join(dealer_hand), dealer_score))\n\n# Main game loop\n# coding your answer here\nwhile not game_over:\n\n    # Print the hands and scores\n    print_hands_and_scores()\n\n    # Check if the player or the dealer has a blackjack\n    if player_score == 21:\n        print(\"Blackjack! Player wins!\")\n        game_over = True\n    elif dealer_score == 21:\n        print(\"Blackjack! Dealer wins!\")\n        game_over = True\n\n    # Ask the player if they want to hit or stand\n    else:\n        choice = input(\"Do you want to hit or stand? \")\n        if choice.lower() == \"hit\":\n            player_hand.append(deck.pop())\n            player_score = calculate_score(player_hand)\n            if player_score &gt; 21:\n                print(\"Bust! Dealer wins!\")\n                game_over = True\n        elif choice.lower() == \"stand\":\n            dealer_score = calculate_score(dealer_hand)\n            while dealer_score &lt; 17:\n                dealer_hand.append(deck.pop())\n                dealer_score = calculate_score(dealer_hand)\n            print_hands_and_scores()\n            if dealer_score &gt; 21:\n                print(\"Bust! Player wins!\")\n                game_over = True\n            elif dealer_score &gt;= player_score:\n                print(\"Dealer wins!\")\n                game_over = True\n            else:\n                print(\"Player wins!\")\n                game_over = True"
  },
  {
    "objectID": "Assignment 6_sol.html#which-of-the-following-statement-is-false",
    "href": "Assignment 6_sol.html#which-of-the-following-statement-is-false",
    "title": "Appendix K — Assignment 6",
    "section": "K.1 (1) Which of the following statement is False?",
    "text": "K.1 (1) Which of the following statement is False?\n\nPython does not have private attributes. Instead, you use naming conventions to design classes that encourage correct use.\nEach new class you create can provide an __init__ method that specifies how to initialize an object’s data attributes.\nWe can access the attribute of the class using the dot notation.\nIf we access an attribute starting with _, an error will occur.\n\n\nAns: Double click to answer the question\n\n\nActually, by convention, Python programmers know that any attribute name beginning with an underscore (_) is for a class’s internal use only. Even when we use this convention, attributes are always accessible."
  },
  {
    "objectID": "Assignment 6_sol.html#which-of-the-following-term-describes-the-has-a-relationship-between-two-classes",
    "href": "Assignment 6_sol.html#which-of-the-following-term-describes-the-has-a-relationship-between-two-classes",
    "title": "Appendix K — Assignment 6",
    "section": "K.2 (2) Which of the following term describes the “has a” relationship between two classes?",
    "text": "K.2 (2) Which of the following term describes the “has a” relationship between two classes?\n\nComposition\nInheritance\nPolymorphism\nEncapsulation\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 6_sol.html#which-of-the-following-statement-is-false-1",
    "href": "Assignment 6_sol.html#which-of-the-following-statement-is-false-1",
    "title": "Appendix K — Assignment 6",
    "section": "K.3 (3) Which of the following statement is False?",
    "text": "K.3 (3) Which of the following statement is False?\n\nThe self is used to represent the instance of the class in Python; if it is included in the method definition, it must come first before any other parameters.\nWhen calling an instance method in Python, self must be passed explicitly and it must come first before any other arguments.\nAny variable prefixed with self is available to every method in the class.\nA class definition begins with the keyword class followed by the class’s name and a colon (:).\n\n\nAns: Double click to answer the question\n\n\nWe do not have to pass it, it will be passed implicitly."
  },
  {
    "objectID": "Assignment 6_sol.html#when-we-call-the-print-function-and-use-an-object-as-the-argument-which-special-method-will-be-called-first",
    "href": "Assignment 6_sol.html#when-we-call-the-print-function-and-use-an-object-as-the-argument-which-special-method-will-be-called-first",
    "title": "Appendix K — Assignment 6",
    "section": "K.4 (4) When we call the print() function and use an object as the argument, which special method will be called first?",
    "text": "K.4 (4) When we call the print() function and use an object as the argument, which special method will be called first?\n\n__add__\n__repr__\n__str__\n__init__\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 6_sol.html#which-of-the-following-function-can-be-used-to-check-whether-an-object-belongs-to-a-specific-class-or-not",
    "href": "Assignment 6_sol.html#which-of-the-following-function-can-be-used-to-check-whether-an-object-belongs-to-a-specific-class-or-not",
    "title": "Appendix K — Assignment 6",
    "section": "K.5 (5) Which of the following function can be used to check whether an object belongs to a specific class or not?",
    "text": "K.5 (5) Which of the following function can be used to check whether an object belongs to a specific class or not?\n\ntype()\nisinstance()\ndir()\nid()\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 6_sol.html#considering-the-following-code-cell.-try-to-modify-the-integer-class-so-that-when-calling-the-show-function-it-will-not-show-the-decimal-point-and-the-decimal-part.",
    "href": "Assignment 6_sol.html#considering-the-following-code-cell.-try-to-modify-the-integer-class-so-that-when-calling-the-show-function-it-will-not-show-the-decimal-point-and-the-decimal-part.",
    "title": "Appendix K — Assignment 6",
    "section": "K.6 (6) Considering the following code cell. Try to modify the integer class so that when calling the show() function, it will not show the decimal point and the decimal part.",
    "text": "K.6 (6) Considering the following code cell. Try to modify the integer class so that when calling the show() function, it will not show the decimal point and the decimal part.\n\nclass floating:\n    def __init__(self, num):\n        self.num = num\n    def show(self):\n        print(f'{self.num:.1f}')\n\nclass integer(floating):\n    def __init__(self, num):\n        super().__init__(num)\n    # Your code here\n    def show(self):\n        print(f'{self.num:d}')\n\n\negg = floating(3.53)\negg.show()\nspam = integer(3)\nspam.show()\n\n3.5\n3"
  },
  {
    "objectID": "Assignment 6_sol.html#modify-the-above-classes-so-that-we-can-add-the-objects-from-the-integer-and-the-objects-from-the-floating-class-together.",
    "href": "Assignment 6_sol.html#modify-the-above-classes-so-that-we-can-add-the-objects-from-the-integer-and-the-objects-from-the-floating-class-together.",
    "title": "Appendix K — Assignment 6",
    "section": "K.7 (7) Modify the above classes so that we can add the objects from the integer and the objects from the floating class together.",
    "text": "K.7 (7) Modify the above classes so that we can add the objects from the integer and the objects from the floating class together.\n\nclass floating:\n    def __init__(self, num):\n        self.num = num\n    # Your code here\n    def show(self):\n        print(f'{self.num:.1f}')\n    \n    def __add__(self, other):\n        return self.num + other.num\n\nclass integer(floating):\n    def __init__(self, num):\n        super().__init__(num)\n        \n    def show(self):\n        print(f'{self.num:d}')\n\n\negg = floating(3.53)\nspam = integer(3)\n\n\nprint(spam + egg)\n\n6.529999999999999"
  },
  {
    "objectID": "Assignment 6_sol.html#you-may-notice-that-the-above-calculation-is-not-correct-in-the-math-sense-why-try-to-import-a-built-in-class-in-python-so-that-the-numbers-can-be-represented-exactly.-in-addition-calculate-3-3.53-exactly-using-the-class.",
    "href": "Assignment 6_sol.html#you-may-notice-that-the-above-calculation-is-not-correct-in-the-math-sense-why-try-to-import-a-built-in-class-in-python-so-that-the-numbers-can-be-represented-exactly.-in-addition-calculate-3-3.53-exactly-using-the-class.",
    "title": "Appendix K — Assignment 6",
    "section": "K.8 (8) You may notice that the above calculation is not correct in the math sense, why? Try to import a built-in class in Python so that the numbers can be represented exactly. In addition, calculate 3 + 3.53 exactly using the class.",
    "text": "K.8 (8) You may notice that the above calculation is not correct in the math sense, why? Try to import a built-in class in Python so that the numbers can be represented exactly. In addition, calculate 3 + 3.53 exactly using the class.\nHint: You may use Copilot to give you suggestion\nSince floating point representation is not exact, so there are some rounding errors.\n\n# Try to import a class in python so that the numbers can be represented exactly\nfrom decimal import Decimal\n\n# Calculate 3 + 3.53 exactly\negg = Decimal('3.53')\nspam = Decimal('3')\nprint(egg + spam)\n\n6.53"
  },
  {
    "objectID": "Assignment 6_sol.html#design-a-triangle-class-that-has-two-attributes-base-and-height-and-satisfies-the-following-properties",
    "href": "Assignment 6_sol.html#design-a-triangle-class-that-has-two-attributes-base-and-height-and-satisfies-the-following-properties",
    "title": "Appendix K — Assignment 6",
    "section": "K.9 (9) Design a triangle class that has two attributes, base and height and satisfies the following properties:",
    "text": "K.9 (9) Design a triangle class that has two attributes, base and height and satisfies the following properties:\n\nCreate a constructor that accepts base and height from the user.\nUsing the naming convention to declare the two attributes as private data so that an error occurs when the user directly accesses these two attributes using dot notation.\nAdd getter (get_base_height()) and setter(set_base_height) to the class so that the two attributes can be set and get simultaneously via these methods.\nCreate a method area() for the class that returns the area of the triangle.\nWhen the user prints out the triangle object, show the base and height of the triangle.\n\n\nclass trinagle:\n    def __init__(self, base, height):\n        self.__base = base\n        self.__height = height\n    def get_base_height(self):\n        return self.__base, self.__height\n    def set_base_height(self, base, height):\n        self.__height = height\n        self.__base = base\n    def area(self):\n        return self.__base * self.__height / 2\n    def __str__(self):\n        return f'Triangle: base = {self.__base}, height = {self.__height}'\n\n\nt1 = trinagle(3, 4)\nprint(t1.area())\nb, h = t1.get_base_height()\nprint(b, h)\nt1.set_base_height(7, 24)\nprint(t1)\n\n6.0\n3 4\nTriangle: base = 7, height = 24"
  },
  {
    "objectID": "Assignment 6_sol.html#design-a-righttriangle-class-by-inheriting-from-the-above-class-and-modifying-the-class-so-that-only-valid-base-and-height-can-be-set.-otherwise-you-should-raise-an-exception.",
    "href": "Assignment 6_sol.html#design-a-righttriangle-class-by-inheriting-from-the-above-class-and-modifying-the-class-so-that-only-valid-base-and-height-can-be-set.-otherwise-you-should-raise-an-exception.",
    "title": "Appendix K — Assignment 6",
    "section": "K.10 (10) Design a RightTriangle class by inheriting from the above class and modifying the class so that only valid base and height can be set. Otherwise, you should raise an exception.",
    "text": "K.10 (10) Design a RightTriangle class by inheriting from the above class and modifying the class so that only valid base and height can be set. Otherwise, you should raise an exception.\nHint: You can raise an exception using the statement raise ValueError('Invalid base and height')\n\nclass RightTriangle(trinagle):\n    def __init__(self, base, height):\n        self.set_base_height(base, height)\n    def set_base_height(self, base, height):\n        if self.valid(base, height):\n            self.__base = base\n            self.__height = height\n        else:\n            raise ValueError('Invalid base and height')\n    def valid(self, base, height):\n        # The first condition is optional\n        if ((base**2 + height**2)**0.5 == int((base**2 + height**2)**0.5)) and (base &gt; 0 or height &gt; 0):\n            return True\n        else:\n            return False\n\n\ntry:\n    print(RightTriangle(3, 4))\n    print(RightTriangle(7, 24))\n    print(RightTriangle(3, 5))\n    print(RightTriangle(-1, -1))\nexcept:\n    print('An error occured')\n\nAn error occured"
  },
  {
    "objectID": "Assignment 7_sol.html#which-of-the-following-statement-is-false",
    "href": "Assignment 7_sol.html#which-of-the-following-statement-is-false",
    "title": "Appendix L — Assignment 7",
    "section": "L.1 (1) Which of the following statement is False?",
    "text": "L.1 (1) Which of the following statement is False?\n\nWe will generally manipulate arrays using concise functional-style programming techniques with internal iteration rather than using an explicit for loop.\nMost array operations execute significantly faster than corresponding list operations.\nMethod reshape will return a deep copy of the original array with the new specified dimensions, and it does not modify the original array.\nTransposing an array using .T attribute does not modify the original array.\n\n\nAns: Double click to answer the question\n\n\nIt does not modify the original array. Actually, Method reshape returns a view (shallow copy) of the original array with the new dimensions."
  },
  {
    "objectID": "Assignment 7_sol.html#which-of-the-following-is-the-most-convenient-method-to-produce-evenly-spaced-numbers-over-a-specified-interval-by-specifying-the-number-of-numbers-desired",
    "href": "Assignment 7_sol.html#which-of-the-following-is-the-most-convenient-method-to-produce-evenly-spaced-numbers-over-a-specified-interval-by-specifying-the-number-of-numbers-desired",
    "title": "Appendix L — Assignment 7",
    "section": "L.2 (2) Which of the following is the most convenient method to produce evenly spaced numbers over a specified interval by specifying the number of numbers desired?",
    "text": "L.2 (2) Which of the following is the most convenient method to produce evenly spaced numbers over a specified interval by specifying the number of numbers desired?\n\narange\nlinspace\nfull\nrange\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 7_sol.html#which-of-the-following-statement-is-false-1",
    "href": "Assignment 7_sol.html#which-of-the-following-statement-is-false-1",
    "title": "Appendix L — Assignment 7",
    "section": "L.3 (3) Which of the following statement is False?",
    "text": "L.3 (3) Which of the following statement is False?\n\nUsually, the Numpy arrays are statically typed. The type of the elements is determined when the array is created\nA 24-element one-dimensional array can be reshaped into a 2-by-12, 8-by-3 or 4-by-6 array, and vice versa.\nJust like the built-in list, Numpy arrays can be used to store heterogeneous data with different data types.\nJust like the built-in list, Numpy arrays can be sliced and indexed.\n\n\nAns: Double click to answer the question\n\n\nThis statement is false because Numpy arrays are statically typed, which means that all elements in the array must have the same data type. In contrast, list objects can store elements of different data types."
  },
  {
    "objectID": "Assignment 7_sol.html#which-of-the-following-operation-is-invalid",
    "href": "Assignment 7_sol.html#which-of-the-following-operation-is-invalid",
    "title": "Appendix L — Assignment 7",
    "section": "L.4 (4) Which of the following operation is invalid?",
    "text": "L.4 (4) Which of the following operation is invalid?\n\na = np.zeros((5, 1)); b = np.arange(3); a + b\na = 3; b = np.full((2, 4), 3); a + b\na = np.array([1, 2, 3]).reshape(3, 1); b = np.array([4, 5]); a * b\na = np.ones((4, 2)); b = np.arange(4); a + b\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 7_sol.html#which-of-the-following-function-is-not-possible-to-produce-an-array-that-contains-the-numerical-value-10-as-its-element",
    "href": "Assignment 7_sol.html#which-of-the-following-function-is-not-possible-to-produce-an-array-that-contains-the-numerical-value-10-as-its-element",
    "title": "Appendix L — Assignment 7",
    "section": "L.5 (5) Which of the following function is not possible to produce an array that contains the numerical value 10 as its element?",
    "text": "L.5 (5) Which of the following function is not possible to produce an array that contains the numerical value 10 as its element?\n\nnp.linspace(1, 11, 5)\nnp.random.randint(11)\nnp.arange(11)\nnp.array(range(11))\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 7_sol.html#suppose-we-are-developing-a-chess-game-and-the-chess-game-provides-a-special-checkerboards-as-follows",
    "href": "Assignment 7_sol.html#suppose-we-are-developing-a-chess-game-and-the-chess-game-provides-a-special-checkerboards-as-follows",
    "title": "Appendix L — Assignment 7",
    "section": "L.6 (6) Suppose we are developing a chess game and the chess game provides a special checkerboards as follows:",
    "text": "L.6 (6) Suppose we are developing a chess game and the chess game provides a special checkerboards as follows:\n\n\n\nWe decide to use 1 to represent the white square and 0 to represent the black square. Write a program to create two 2D arrays to represent the two checkerboards as follows:\n[[1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.],\n [0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1.],\n [1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.],\n [0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1.]]\nNote you should not directly hardcode the above arrays. You should use Numpy methods to create the arrays. After you have finished the exercise, you can print out the checkerboard using the following code cell.\n\nimport numpy\n# Your code here\ncheckerboard = np.ones((4, 12))\ncheckerboard[::2, 1::2] = 0\ncheckerboard[1::2, ::2] = 0\ncheckerboard\n\narray([[1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.],\n       [0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1.],\n       [1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.],\n       [0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1.]])\n\n\n\nimport matplotlib.pyplot as plt\nplt.imshow(checkerboard, cmap='gray');"
  },
  {
    "objectID": "Assignment 7_sol.html#write-a-program-that-computes-the-value-of-pi-from-the-following-infinite-series-4-times-1-frac13frac15-frac17...-frac-1n2n-1-without-using-the-loop.-what-is-the-error-when-you-use-500-terms-to-compute-the-value-of-pi",
    "href": "Assignment 7_sol.html#write-a-program-that-computes-the-value-of-pi-from-the-following-infinite-series-4-times-1-frac13frac15-frac17...-frac-1n2n-1-without-using-the-loop.-what-is-the-error-when-you-use-500-terms-to-compute-the-value-of-pi",
    "title": "Appendix L — Assignment 7",
    "section": "L.7 (7) Write a program that computes the value of \\(\\pi\\) from the following infinite series \\(4 \\times (1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}...-\\frac{(-1)^n}{2n-1})\\) without using the loop. What is the error when you use 500 terms to compute the value of \\(\\pi\\)?",
    "text": "L.7 (7) Write a program that computes the value of \\(\\pi\\) from the following infinite series \\(4 \\times (1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}...-\\frac{(-1)^n}{2n-1})\\) without using the loop. What is the error when you use 500 terms to compute the value of \\(\\pi\\)?\nHint: You can use Numpy methods to create the array and compute the sum. Use the constant np.pi as the ground truth value for \\(\\pi\\) and use np.abs() to calculate the error.\n\nn = 500\nk = np.arange(1, n+1)\nerror = np.abs(np.pi - 4*np.sum(-(-1)**(k) / (2*k - 1)))\nprint(f\"The error is {error} when using {n} terms in the series.\")\n\nThe error is 0.0019999980000111606 when using 500 terms in the series."
  },
  {
    "objectID": "Assignment 7_sol.html#let",
    "href": "Assignment 7_sol.html#let",
    "title": "Appendix L — Assignment 7",
    "section": "L.8 (8) Let",
    "text": "L.8 (8) Let\nS = np.array([[43.,  1.],\n              [75.,  1.],\n              [80.,  1.],\n              [56.,  1.],\n              [61.,  1.]])\nThe first column is the original grade, while the second column is all-ones. Find a 1D vector v such that S @ v outputs the adjusted score according to the following formula:\nadjusted score = 40 + 0.6 * (original score)\n\nS = np.array([[43.,  1.],\n              [75.,  1.],\n              [80.,  1.],\n              [56.,  1.],\n              [61.,  1.]])\nv = [0.6, 40]\nS @ v\n\narray([65.8, 85. , 88. , 73.6, 76.6])\n\n\nThe 1D vector is [0.6, 40]."
  },
  {
    "objectID": "Assignment 7_sol.html#compare-the-performance-between-for-loop-and-numpy-vectorization-for-calculating-the-summation-of-all-odd-numbers-smaller-than-10000-i.e.-1-3-5-ldots-9997-9999.-what-is-the-speedup-factor-of-the-numpy-vectorization",
    "href": "Assignment 7_sol.html#compare-the-performance-between-for-loop-and-numpy-vectorization-for-calculating-the-summation-of-all-odd-numbers-smaller-than-10000-i.e.-1-3-5-ldots-9997-9999.-what-is-the-speedup-factor-of-the-numpy-vectorization",
    "title": "Appendix L — Assignment 7",
    "section": "L.9 (9) Compare the performance between for loop and Numpy vectorization for calculating the summation of all odd numbers smaller than 10000, i.e., \\(1 + 3 + 5 \\ldots + 9997 + 9999\\). What is the speedup factor of the Numpy vectorization?",
    "text": "L.9 (9) Compare the performance between for loop and Numpy vectorization for calculating the summation of all odd numbers smaller than 10000, i.e., \\(1 + 3 + 5 \\ldots + 9997 + 9999\\). What is the speedup factor of the Numpy vectorization?\nHint: Use %%timeit to measure the performance of the code.\n\n%%timeit\ni = 0\nfor item in range(1, 10000, 2):\n    i = i + item\n\n175 µs ± 2.97 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n\n\n\n%%timeit\nnp.sum(np.arange(1, 10000, 2))\n\n7.87 µs ± 99.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\nSpeed up is 175/7.87 = 22.2"
  },
  {
    "objectID": "Assignment 7_sol.html#find-the-maximum-and-minimum-values-of-the-function-fx-x2-on-the-interval--3-5-by-substituting-1000-evenly-spaced-numbers-between--3-and-5-into-the-function.-what-is-the-corresponding-x-value-for-the-maximum-and-minimum-values-and-how-do-they-compare-with-the-actual-values",
    "href": "Assignment 7_sol.html#find-the-maximum-and-minimum-values-of-the-function-fx-x2-on-the-interval--3-5-by-substituting-1000-evenly-spaced-numbers-between--3-and-5-into-the-function.-what-is-the-corresponding-x-value-for-the-maximum-and-minimum-values-and-how-do-they-compare-with-the-actual-values",
    "title": "Appendix L — Assignment 7",
    "section": "L.10 (10) Find the maximum and minimum values of the function \\(f(x) = x^2\\) on the interval \\([-3, 5]\\) by substituting 1000 evenly spaced numbers between \\(-3\\) and \\(5\\) into the function. What is the corresponding \\(x\\) value for the maximum and minimum values and how do they compare with the actual values?",
    "text": "L.10 (10) Find the maximum and minimum values of the function \\(f(x) = x^2\\) on the interval \\([-3, 5]\\) by substituting 1000 evenly spaced numbers between \\(-3\\) and \\(5\\) into the function. What is the corresponding \\(x\\) value for the maximum and minimum values and how do they compare with the actual values?\nHint: You may find np.linspace, np.max/np.min and np.argmax/np.argmin useful.\n\nN = 1000\nx = np.linspace(-3, 5, 1000)\ny = x**2\ny_max = np.max(y)\ny_min = np.min(y)\nx_max = x[np.argmax(y)]\nx_min = x[np.argmin(y)]\nprint('Maximum value is y =', y_max,'at x =', x_max)\nprint('Minimum value is y =', y_min,'at x =', x_min)\n\nMaximum value is y = 25.0 at x = 5.0\nMinimum value is y = 9.01802703604398e-06 at x = 0.0030030030030028243\n\n\nThey are quite close to the actual values. Where actual minimum is at \\(x=0\\) and maximum is at \\(x=5\\)."
  },
  {
    "objectID": "Assignment 8_sol.html#which-of-the-following-statement-is-false",
    "href": "Assignment 8_sol.html#which-of-the-following-statement-is-false",
    "title": "Appendix M — Assignment 8",
    "section": "M.1 (1) Which of the following statement is False?",
    "text": "M.1 (1) Which of the following statement is False?\n\nThere are two different interfaces in matplotlib. One is MATLAB(functional)-style interface, and the other is object-oriented interface.\nThe functional interface is stateless, while the object-oriented interface is stateful in matplotlib.\nTo generate a scatter plot in matplotlib, we can use either plot() or scatter() function.\nTo draw two figures in the same figure, we can call the plot() function twice.\n\n\nAns: Double click to answer the question\n\n\nThe functional interface is stateful."
  },
  {
    "objectID": "Assignment 8_sol.html#in-the-command-plt.plotx-y---sk-what-does-the-format-string---sk-mean",
    "href": "Assignment 8_sol.html#in-the-command-plt.plotx-y---sk-what-does-the-format-string---sk-mean",
    "title": "Appendix M — Assignment 8",
    "section": "M.2 (2) In the command plt.plot(x, y, '--sk'), what does the format string '--sk' mean?",
    "text": "M.2 (2) In the command plt.plot(x, y, '--sk'), what does the format string '--sk' mean?\n\nDraw a dash line with black color and square marker.\nDraw a solid line with black color and circle marker.\nDraw a dotted line with sky blue color and square marker.\nDraw a dash line with pink color and circle marker.\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 8_sol.html#which-of-the-following-statement-is-false-1",
    "href": "Assignment 8_sol.html#which-of-the-following-statement-is-false-1",
    "title": "Appendix M — Assignment 8",
    "section": "M.3 (3) Which of the following statement is False?",
    "text": "M.3 (3) Which of the following statement is False?\n\nEach axis in matplotlib contains both major and minor tick marks. As implied by their names, major ticks are generally more noticeable or sizable, while minor ticks tend to be smaller.\nThe keyword argument density=True in hist() function serves to normalize the histogram, enabling it to be shown on the same axes as the data.\nBy default, spines are situated at the edges of the axis and act as lines that connect axis tick marks, delineating the data area’s boundaries.\nThe primary benefit of using plot() instead of scatter() is the capability it offers to create scatter plots, allowing for individual customization of each point’s properties.\n\n\nAns: Double click to answer the question\n\n\nscatter() instead of plot() enjoy the benifit of being more customizable."
  },
  {
    "objectID": "Assignment 8_sol.html#which-of-the-following-grid-will-be-returned-by-the-command-plt.subplots3-2",
    "href": "Assignment 8_sol.html#which-of-the-following-grid-will-be-returned-by-the-command-plt.subplots3-2",
    "title": "Appendix M — Assignment 8",
    "section": "M.4 (4) Which of the following grid will be returned by the command plt.subplots(3, 2)?",
    "text": "M.4 (4) Which of the following grid will be returned by the command plt.subplots(3, 2)?\n\nA grid with 3 columns and 2 rows and the first subplot is at the top left corner.\nA grid with 3 rows and 2 columns and the first subplot is at the bottom left corner.\nA grid with 3 rows and 2 columns and the first subplot is at the top left corner.\nA grid with 3 columns and 2 rows and the first subplot is at the bottom left corner.\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 8_sol.html#which-of-the-following-command-is-used-to-show-the-plots-directly-within-the-notebook-so-that-the-plots-can-be-embedded-as-static-images-in-the-notebook",
    "href": "Assignment 8_sol.html#which-of-the-following-command-is-used-to-show-the-plots-directly-within-the-notebook-so-that-the-plots-can-be-embedded-as-static-images-in-the-notebook",
    "title": "Appendix M — Assignment 8",
    "section": "M.5 (5) Which of the following command is used to show the plots directly within the notebook so that the plots can be embedded as static images in the notebook?",
    "text": "M.5 (5) Which of the following command is used to show the plots directly within the notebook so that the plots can be embedded as static images in the notebook?\n\n%matplotlib qt\n%matplotlib inline\n%matplotlib notebook\n%matplotlib ipympl\n\n\nAns: Double click to answer the question\n\n\n\n\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.style.use('seaborn-whitegrid')\n\nC:\\Users\\adm\\AppData\\Local\\Temp\\ipykernel_32440\\1473361050.py:4: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')"
  },
  {
    "objectID": "Assignment 8_sol.html#try-to-plot-the-rose-curve-ratimes-sinntheta-with-a2-and-n2-which-means-the-curve-has-4-petals-as-follows",
    "href": "Assignment 8_sol.html#try-to-plot-the-rose-curve-ratimes-sinntheta-with-a2-and-n2-which-means-the-curve-has-4-petals-as-follows",
    "title": "Appendix M — Assignment 8",
    "section": "M.6 (6) Try to plot the rose curve \\(r=a\\times \\sin(n\\theta)\\) with \\(a=2\\) and \\(n=2\\) which means the curve has 4 petals as follows:",
    "text": "M.6 (6) Try to plot the rose curve \\(r=a\\times \\sin(n\\theta)\\) with \\(a=2\\) and \\(n=2\\) which means the curve has 4 petals as follows:\n\n# The rose curve:\nt = np.linspace(0, 2*np.pi, 1000)\nr = 2*np.sin(2*t)\n# plot in polar coordinates\nplt.axes(projection='polar')\nplt.plot(t+(r&lt;0)*np.pi, np.abs(r), '-')\n\n# Set ticks for polar coordinate\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2], ['0', '$\\pi/2$', '$\\pi$', '$3\\pi/2$']);\nplt.yticks([0, 0.5, 1, 1.5, 2]);\n\n\n\n\nNote that you should change the ticks according to the above plot and you can use the trick mentioned in our slides to set the radius of 0 to the origin.\n\n# Your code here"
  },
  {
    "objectID": "Assignment 8_sol.html#try-to-plot-sinx-sin2x-sin3x-sin4x-in-different-subplots-in-the-same-figure-organized-as-follows",
    "href": "Assignment 8_sol.html#try-to-plot-sinx-sin2x-sin3x-sin4x-in-different-subplots-in-the-same-figure-organized-as-follows",
    "title": "Appendix M — Assignment 8",
    "section": "M.7 (7) Try to plot \\(\\sin(x)\\), \\(\\sin(2x)\\), \\(\\sin(3x)\\), \\(\\sin(4x)\\), in different subplots in the same figure organized as follows:",
    "text": "M.7 (7) Try to plot \\(\\sin(x)\\), \\(\\sin(2x)\\), \\(\\sin(3x)\\), \\(\\sin(4x)\\), in different subplots in the same figure organized as follows:\n\n# Sine Functions with Different Frequencies:\nx = np.linspace(0, 2 * np.pi, 1000)\n\n# Calculate the sine functions\ny1 = np.sin(x)\ny2 = np.sin(2 * x)\ny3 = np.sin(3 * x)\ny4 = np.sin(4 * x)\n\n# Create the figure and subplots\nfig, axs = plt.subplots(2, 2, figsize=(10, 10))\n\n# Plot the sine functions in the subplots\naxs[0, 0].plot(x, y1)\naxs[0, 0].set_title('sin(x)')\n\naxs[1, 0].plot(x, y2)\naxs[1, 0].set_title('sin(2x)')\n\naxs[0, 1].plot(x, y3)\naxs[0, 1].set_title('sin(3x)')\n\naxs[1, 1].plot(x, y4)\naxs[1, 1].set_title('sin(4x)');\n\n\n\n\nRemember to add the title to your plot using set_title() function.\n\n# Your code here"
  },
  {
    "objectID": "Assignment 8_sol.html#try-to-plot-the-sin2x-function-in-the-range-x--pi-pi-and-fill-the-area-between-the-curve-and-the-x-axis-with-the-color-blue-and-alpha0.25-as-follows",
    "href": "Assignment 8_sol.html#try-to-plot-the-sin2x-function-in-the-range-x--pi-pi-and-fill-the-area-between-the-curve-and-the-x-axis-with-the-color-blue-and-alpha0.25-as-follows",
    "title": "Appendix M — Assignment 8",
    "section": "M.8 (8) Try to plot the \\(\\sin(2x)\\) function in the range \\(x = [-\\pi, \\pi]\\) and fill the area between the curve and the x-axis with the color blue and alpha=0.25 as follows:",
    "text": "M.8 (8) Try to plot the \\(\\sin(2x)\\) function in the range \\(x = [-\\pi, \\pi]\\) and fill the area between the curve and the x-axis with the color blue and alpha=0.25 as follows:\n\n# Example plot:\nn = 1000\nX = np.linspace(-np.pi, np.pi, n)\nY = np.sin(2 * X)\n\n#plt.axes([0.025, 0.025, 0.95, 0.95])\nplt.plot(X, Y, color='blue', alpha=1.00)\nplt.fill_between(X, 0, Y, color='blue', alpha=.25)\n\nplt.xlim(-np.pi, np.pi)\n#plt.ylim(-2.5, 2.5)\nradian_multiples = [-1, -1/2, 0, 1/2, 1]\nradians = [n * np.pi for n in radian_multiples]\nradian_labels = ['$\\pi$', '$-\\pi/2$', '0', '$\\pi/2$', '$\\pi$']\nplt.xticks(radians, radian_labels);\n\n\n\n\nYou can use the following code to set the ticks:\nradian_multiples = [-1, -1/2, 0, 1/2, 1]\nradians = [n * np.pi for n in radian_multiples]\nradian_labels = ['$\\pi$', '$-\\pi/2$', '0', '$\\pi/2$', '$\\pi$']\nplt.xticks(radians, radian_labels);\n\n# Your code here"
  },
  {
    "objectID": "Assignment 8_sol.html#use-np.random.rand-to-generate-10000-data-points-and-plot-the-histogram-of-the-data-points-with-50-bins-and-normalize-it-so-that-the-area-under-the-histogram-integrates-to-1.-check-out-the-documentation-of-np.random.rand-on-the-official-website.-does-the-plot-look-like-the-distribution-mentioned-on-the-official-website",
    "href": "Assignment 8_sol.html#use-np.random.rand-to-generate-10000-data-points-and-plot-the-histogram-of-the-data-points-with-50-bins-and-normalize-it-so-that-the-area-under-the-histogram-integrates-to-1.-check-out-the-documentation-of-np.random.rand-on-the-official-website.-does-the-plot-look-like-the-distribution-mentioned-on-the-official-website",
    "title": "Appendix M — Assignment 8",
    "section": "M.9 (9) Use np.random.rand() to generate 10000 data points and plot the histogram of the data points with 50 bins and normalize it so that the area under the histogram integrates to 1. Check out the documentation of np.random.rand() on the official website. Does the plot look like the distribution mentioned on the official website?",
    "text": "M.9 (9) Use np.random.rand() to generate 10000 data points and plot the histogram of the data points with 50 bins and normalize it so that the area under the histogram integrates to 1. Check out the documentation of np.random.rand() on the official website. Does the plot look like the distribution mentioned on the official website?\n\ndata = np.random.rand(10000)\nplt.hist(data, bins=50, density=True, alpha=0.5);\n\n\n\n\nYes, it looks like the data are random samples from a uniform distribution over [0, 1)."
  },
  {
    "objectID": "Assignment 8_sol.html#when-we-try-to-plot-tanx-using-plot-function-and-set-the-limit-of-x-between--2pi-2pi-we-will-get-the-following-figure",
    "href": "Assignment 8_sol.html#when-we-try-to-plot-tanx-using-plot-function-and-set-the-limit-of-x-between--2pi-2pi-we-will-get-the-following-figure",
    "title": "Appendix M — Assignment 8",
    "section": "M.10 (10) When we try to plot \\(tan(x)\\) using plot() function and set the limit of x between \\([-2\\pi, 2\\pi]\\), we will get the following figure:",
    "text": "M.10 (10) When we try to plot \\(tan(x)\\) using plot() function and set the limit of x between \\([-2\\pi, 2\\pi]\\), we will get the following figure:\n\nx = np.linspace(-2 * np.pi, 2 * np.pi, 1000)\ny = np.tan(x)\n\nplt.xlabel(\"x\")\nplt.ylabel(\"$tan(x)$\")\nplt.xlim(-2 * np.pi, 2 * np.pi)\nplt.title(\"$y = tan(x)$\")\nplt.plot(x, y)\nradian_multiples = [-2, -3/2, -1, -1/2, 0, 1/2, 1, 3/2, 2]\nradians = [n * np.pi for n in radian_multiples]\nradian_labels = ['$-2\\pi$', '$-3\\pi/2$', '$\\pi$', '$-\\pi/2$', '0', '$\\pi/2$', '$\\pi$', '$3\\pi/2$', '$2\\pi$']\n\nplt.xticks(radians, radian_labels);\n\n\n\n\nTry to explain why the plot is not as expected and solve the problem to obtain the following plot:\n\n# The fix tan(x) plot\nx = np.linspace(-2 * np.pi, 2 * np.pi, 1000)\ny = np.tan(x)\n#y[:-1][np.diff(y) &lt; 0] = np.nan\ny[np.isclose(x, 3*np.pi/2, rtol=1e-02)] = np.nan\ny[np.isclose(x, np.pi/2, rtol=1e-02)] = np.nan\ny[np.isclose(x, -np.pi/2, rtol=1e-02)] = np.nan\ny[np.isclose(x, -3*np.pi/2, rtol=1e-02)] = np.nan\n\nplt.xlabel(\"x\")\nplt.ylabel(\"$tan(x)$\")\nplt.xlim(-2 * np.pi, 2 * np.pi)\nplt.ylim(-5, 5)\nplt.title(\"$y = tan(x)$\")\nplt.plot(x, y)\n\nradian_multiples = [-2, -3/2, -1, -1/2, 0, 1/2, 1, 3/2, 2]\nradians = [n * np.pi for n in radian_multiples]\nradian_labels = ['$-2\\pi$', '$-3\\pi/2$', '$\\pi$', '$-\\pi/2$', '0', '$\\pi/2$', '$\\pi$', '$3\\pi/2$', '$2\\pi$']\n\nplt.xticks(radians, radian_labels);\n\n\n\n\nHint: You can set the point at the discontinuity to np.nan so that the point won’t be plotted in the figure."
  },
  {
    "objectID": "Assignment 9_sol.html#which-of-the-following-statement-is-false",
    "href": "Assignment 9_sol.html#which-of-the-following-statement-is-false",
    "title": "Appendix N — Assignment 9",
    "section": "N.1 (1) Which of the following statement is False?",
    "text": "N.1 (1) Which of the following statement is False?\n\nWe can evaluate the values of special constants, like \\(e\\), \\(\\pi\\), and \\(\\infty\\) using SymPy.\nYou can express one symbol in terms of another and perform substitutions accordingly, using the subs() method. For instance, you can substitute \\(\\cos(x)\\) with \\(\\sin(x+\\pi/2)\\) by calling subs({sp.cos(x):sp.sin(x+sp.pi/2)}).\nnsolve() function is a numerical version of the solve() function. Therefore, if solve() function fails to find a solution, nsolve() function will also fail to find a solution.\nThe lambdify() function in SymPy converts SymPy expressions into equivalent Python functions, enabling them to be computed numerically.\n\n\nAns: Double click to answer the question\n\n\nIf solve() fails to find a solution, it doesn’t mean nsolve() will also fail. They use different methods and can handle different types of equations."
  },
  {
    "objectID": "Assignment 9_sol.html#which-of-the-following-function-can-be-use-to-display-the-expression-in-the-reverse-order-so-that-the-terms-of-an-expression-are-arranged-according-to-the-powers-of-x-in-ascending-order",
    "href": "Assignment 9_sol.html#which-of-the-following-function-can-be-use-to-display-the-expression-in-the-reverse-order-so-that-the-terms-of-an-expression-are-arranged-according-to-the-powers-of-x-in-ascending-order",
    "title": "Appendix N — Assignment 9",
    "section": "N.2 (2) Which of the following function can be use to display the expression in the reverse order, so that the terms of an expression are arranged according to the powers of x, in ascending order?",
    "text": "N.2 (2) Which of the following function can be use to display the expression in the reverse order, so that the terms of an expression are arranged according to the powers of x, in ascending order?\n\ninit_printing()\nevalf()\nsimplify()\nlambdify()\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 9_sol.html#which-of-the-following-statement-is-false-1",
    "href": "Assignment 9_sol.html#which-of-the-following-statement-is-false-1",
    "title": "Appendix N — Assignment 9",
    "section": "N.3 (3) Which of the following statement is False?",
    "text": "N.3 (3) Which of the following statement is False?\n\nBy default, the direction from which the limit is computed is negative in SymPy, unless the point of computation is positive or negative infinity.\nWhen constructing a matrix in SymPy, the approach is quite similar to that of NumPy. You provide a list of lists, where each inner list is a row of the matrix.\nBy default, the solve() function will return the solutions in a list.\nIn sympy, you can expand a trigonometric expression by setting trig=True in the expand() function.\n\n\nAns: Double click to answer the question\n\n\nBy default, the direction from which the limit is computed is positive in SymPy."
  },
  {
    "objectID": "Assignment 9_sol.html#which-of-the-following-operation-will-return-the-evaluation-results-rather-than-an-unevaluated-object",
    "href": "Assignment 9_sol.html#which-of-the-following-operation-will-return-the-evaluation-results-rather-than-an-unevaluated-object",
    "title": "Appendix N — Assignment 9",
    "section": "N.4 (4) Which of the following operation will return the evaluation results rather than an unevaluated object?",
    "text": "N.4 (4) Which of the following operation will return the evaluation results rather than an unevaluated object?\n\nsp.Limit(1/x, x, -sp.oo)\nsp.Derivative(1/x, x)\nsp.diff(x**2, x)\nsp.Integral(x**2)\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 9_sol.html#which-of-the-following-function-can-be-used-to-evaluate-an-expression-to-a-floating-point-number",
    "href": "Assignment 9_sol.html#which-of-the-following-function-can-be-used-to-evaluate-an-expression-to-a-floating-point-number",
    "title": "Appendix N — Assignment 9",
    "section": "N.5 (5) Which of the following function can be used to evaluate an expression to a floating-point number?",
    "text": "N.5 (5) Which of the following function can be used to evaluate an expression to a floating-point number?\n\ndoit()\nsimplify()\nlambdify()\nevalf()\n\n\nAns: Double click to answer the question"
  },
  {
    "objectID": "Assignment 9_sol.html#consider-the-following-two-equations",
    "href": "Assignment 9_sol.html#consider-the-following-two-equations",
    "title": "Appendix N — Assignment 9",
    "section": "N.6 (6) Consider the following two equations:",
    "text": "N.6 (6) Consider the following two equations:\n\\[\n\\begin{align}\nx + y + z &= 6 \\\\\n2x + 3y + z &= 12 \\\\\n3x - 2y + z &=2\n\\end{align}\n\\]\nTry to find the pair of values (x, y) that satisfies both equations using SymPy. After that, substitute the values of x and y into the original equations to verify that the solutions are correct using SymPy.\n\n%pip install sympy --upgrade\n\nCollecting sympy\n  Downloading sympy-1.12-py3-none-any.whl (5.7 MB)\nRequirement already satisfied, skipping upgrade: mpmath&gt;=0.19 in c:\\users\\phonchi\\anaconda3\\lib\\site-packages (from sympy) (1.1.0)\nInstalling collected packages: sympy\n  Attempting uninstall: sympy\n    Found existing installation: sympy 1.6.1\n    Uninstalling sympy-1.6.1:\n      Successfully uninstalled sympy-1.6.1\nSuccessfully installed sympy-1.12\nNote: you may need to restart the kernel to use updated packages.\n\n\n\nimport sympy as sp\nx = sp.Symbol('x')\ny = sp.Symbol('y')\nz = sp.Symbol('z')\nexpr1 = x + y +z - 6\nexpr2 = 2*x + 3*y +z - 12\nexpr3 = 3*x - 2*y + z - 2\n\nsp.solve((expr1, expr2, expr3), dict=True)\n\n[{x: 10/7, y: 16/7, z: 16/7}]\n\n\n\nsol = sp.solve((expr1, expr2, expr3), dict=True)\nexpr1.subs({x:sol[0][x], y:sol[0][y], z:sol[0][z]}), expr2.subs({x:sol[0][x], y:sol[0][y], z:sol[0][z]}), expr3.subs({x:sol[0][x], y:sol[0][y], z:sol[0][z]})\n\n(0, 0, 0)"
  },
  {
    "objectID": "Assignment 9_sol.html#factoring-the-following-polynomial-and-finding-its-roots-using-sympy",
    "href": "Assignment 9_sol.html#factoring-the-following-polynomial-and-finding-its-roots-using-sympy",
    "title": "Appendix N — Assignment 9",
    "section": "N.7 (7) Factoring the following polynomial, and finding its roots using SymPy:",
    "text": "N.7 (7) Factoring the following polynomial, and finding its roots using SymPy:\n\\[x^4-6x^3+x^2+24x+16\\]\n\nx = sp.Symbol('x')\np1 = x**4 - 6*x**3+x**2+24*x+16\nsp.factor(p1)\n\n\\(\\displaystyle \\left(x - 4\\right)^{2} \\left(x + 1\\right)^{2}\\)\n\n\n\nsp.solve(p1, dict=True)\n\n[{x: -1}, {x: 4}]"
  },
  {
    "objectID": "Assignment 9_sol.html#find-all-the-intersection-points-between-fx20-x3-and-gx6x2-times-1.12x-using-sympy-by-first-plotting-the-function-and-using-the-graph-to-narrow-down-the-range-of-the-intersection-points.-then-use-nsolve-function-to-find-the-intersection-points.-your-results-should-be-the-coordinate-values-in-numerical-format.",
    "href": "Assignment 9_sol.html#find-all-the-intersection-points-between-fx20-x3-and-gx6x2-times-1.12x-using-sympy-by-first-plotting-the-function-and-using-the-graph-to-narrow-down-the-range-of-the-intersection-points.-then-use-nsolve-function-to-find-the-intersection-points.-your-results-should-be-the-coordinate-values-in-numerical-format.",
    "title": "Appendix N — Assignment 9",
    "section": "N.8 (8) Find all the intersection points between \\(f(x)=20-x^3\\) and \\(g(x)=6x^2 \\times 1.12^x\\) using SymPy by first plotting the function and using the graph to narrow down the range of the intersection points. Then, use nsolve() function to find the intersection points. Your results should be the coordinate values in numerical format.",
    "text": "N.8 (8) Find all the intersection points between \\(f(x)=20-x^3\\) and \\(g(x)=6x^2 \\times 1.12^x\\) using SymPy by first plotting the function and using the graph to narrow down the range of the intersection points. Then, use nsolve() function to find the intersection points. Your results should be the coordinate values in numerical format.\nHint: You may find solve() and nroots() can not be used to solve this problem. In addition, you may need to zoom in around 0 to find all the possible intersection points.\n\nx = sp.Symbol('x')\nsp.plot(20-x**3, 6*x**2*1.12**x, (x, -2, 2));\n\n\n\n\n\nexpr1 = 20-x**3 - 6*x**2*1.12**x\neq1 = 20-x**3\neq2 = 6*x**2*1.12**x\nxx = sp.nsolve(expr1, 1)\nxx, eq1.subs(x, xx), eq2.subs(x, xx)\n\n(1.52065140948474, 16.4836750153385, 16.4836750153385)"
  },
  {
    "objectID": "Assignment 9_sol.html#try-to-evaluate-the-expression-log3e-to-20-precision-significant-digits-using-sympy.",
    "href": "Assignment 9_sol.html#try-to-evaluate-the-expression-log3e-to-20-precision-significant-digits-using-sympy.",
    "title": "Appendix N — Assignment 9",
    "section": "N.9 (9) Try to evaluate the expression \\(\\log{3}+e\\) to 20 precision (significant digits) using SymPy.",
    "text": "N.9 (9) Try to evaluate the expression \\(\\log{3}+e\\) to 20 precision (significant digits) using SymPy.\n\n(sp.log(3)+sp.E).evalf(20)\n\n\\(\\displaystyle 3.8168941171271549268\\)"
  },
  {
    "objectID": "Assignment 9_sol.html#try-to-solve-the-following-problems-using-sympy",
    "href": "Assignment 9_sol.html#try-to-solve-the-following-problems-using-sympy",
    "title": "Appendix N — Assignment 9",
    "section": "N.10 (10) Try to solve the following problems using SymPy:",
    "text": "N.10 (10) Try to solve the following problems using SymPy:\nSimplify the following expression: \\(\\tan(x)\\times \\cos(3x) \\times \\sin(x)\\) so that the final results only contains sin(x) and its power term (\\(\\sin^n(x)\\)).\nHint: You can use simplify() and expand() functions to simplify the expression. You may find trig=True option in expand() function useful.\n\nx = sp.Symbol('x')\nexp = sp.tan(x)*sp.cos(3*x)*sp.sin(x)\nexp2 = sp.simplify(exp.expand(trig=True))\nexp2\n\n\\(\\displaystyle - 4 \\sin^{4}{\\left(x \\right)} + \\sin^{2}{\\left(x \\right)}\\)"
  },
  {
    "objectID": "Quiz1_sol.html#a.-single-choice-questions-3-45",
    "href": "Quiz1_sol.html#a.-single-choice-questions-3-45",
    "title": "Appendix O — Quiz 1",
    "section": "O.1 A. Single Choice Questions (3%, 45%)",
    "text": "O.1 A. Single Choice Questions (3%, 45%)\n\nO.1.1 (1) Which of the following statements is False?\n\nPython’s built-in function type() can be used to determine an object’s data type.\nA function performs its task when you call it by writing its name, followed by square brackets, [].\nThe parentheses after a function name in a function call contain the function’s argument — the data that the function needs to perform its task.\nPython is case sensitive, so number and Number are different identifiers.\n\n\nAns: (B) a function performs its task when you call it by writing its name, followed by parentheses, ().\n\n\n\nO.1.2 (2) Which of the following statement will have a different Boolean value than the others?\n\n\"\"\nNone\n\"No\"\n3 &lt; 5 and 4 &lt; 3\n\n\nAns: (C)\n\n\n\nO.1.3 (3) Which of the following statement is True?\n\nPython uses the ^ symbol to raise one value to the power of another (e.g., 2 ^ 10).\nThe value of the following expression is 2: 7.5 % 3.5.\nThe data type of 2 + j in Python is always a complex number.\nA statement in Python can span more than one line.\n\n\nAns: (D). (A) Python uses **. (B) Should be 0.5. (C) Should be 2 + 1j.\n\n\n\nO.1.4 (4) Which of the following statements is True?\n\nSets are iterable, so they are sequences and support indexing and slicing with square brackets, [].\nSets are not iterable, so you cannot process each element in a set with a for loop.\nYou can create an empty set with {}.\nA dictionary’s keys must be immutable and unique, but multiple keys can have the same value.\n\n\nAns: (D). (A) They are not sequence. (B) Sets are iterable! (C) This is dictionary, you should use set().\n\n\n\nO.1.5 (5) Which of the following statement is False?\n\nIf you have more than one statement in the body of if clause, those statements need to have the same indentation.\nIf you assign value to a new variable in the if clause. Assume that you enter the if clause during the execution; the variable will not be accessible after the if clause.\ncontinue and break statements can be used in both for and while loops.\nYou can cause the program to terminate or exit before the last instruction by calling the sys.exit() function.\n\n\nAns: (B) The varible will still be accessible.\n\n\n\nO.1.6 (6) Which of the following will NOT be printed out when calling the help() function on a custom or built-in function?\n\nName of the function\ndocstring\nBody of the function\nParameter list of the function\n\n\nAns: (C)\n\n\n\nO.1.7 (7) Which of the following statement is True?\n\nThe random.randint(1,5) statement will randomly generate integers from 1 to 4.\nThe parameter with default value should always be put on the leftmost part of the parameter list of a function.\nWhen there’s no return statement in a function, it implicitly returns the value None after executing the last statement in the function’s block.\nIf we would like to pass an arbitrary number of positional arguments to the function, we can use a special parameter like **kwargs.\n\n\nAns: (C). (A) generates integers from 1 to 5. (B) The parameter with default value should be put on the righthand side of normal parameter. (D) We should use something like *args.\n\n\n\nO.1.8 (8) What does the following line of code display?\nprint(20, 30, 40, sep=', ')\n\n203040\n20,30,40\n20, 30, 40\nSyntax error\n\n\nAns: (C)\n\n\n\nO.1.9 (9) Which of the following is NOT a valid collection (container) inside Python?\n\n[3, 'spam', 2, (1,5)]\n('egg', 4, 7, [10, 3 ,5])\n{'spam', 1, 7, [10, 3 ,5]}\n{(2,3):'first tuple', (3,5): 'second tuple', 'a': 3}\n\n\nAns: (C) This is important because when you add an object to a set, its hash value is computed and used to determine its position in the set. If the object is mutable, and its contents change, then its hash value changes, and it can no longer be found in the set.\n\n\n\nO.1.10 (10) Which of the following statements is False?\n\nIf you modify the sublist, which is sliced from a list, the original list is not modified.\nWhen you pass a list to a function and modify the list inside the function, the original list is not modified.\nAssume that spam is a string object. Considering the statement spam = spam + \"world\". The id (memory location) of spam before and after the execution will be different.\nAssume that spam is a list object. Considering the statement spam = spam.append(\"world\"). The id (memory location) of spam before and after the execution will be the same.\n\n\nAns: (B) the original list will also be modified. (D) is also True.\n\n\n\nO.1.11 (11) Which of the following is not a correct way to create a string in Python?\n\n\"nsysu\"\n'nsysu'\n\"\"\" nsysu \"\"\"\nstr(nsysu)\n\n\nAns: (D)\n\n\n\nO.1.12 (12) Which of the following statements is False?\n\nString methods lower() and upper() can convert strings to all lowercase or all uppercase letters, respectively.\nPython has separate data types for string and character.\nRaw strings — preceded by the character r — treat each backslash as a regular character rather than the beginning of an escape sequence.\nBackslash characters in strings introduce escape sequences — like \\n for new-line and \\t for tab.\n\n\nAns: (B) Python represents both string and characters using the same data type str\n\n\n\nO.1.13 (13) Which of the following function can be used to find all the methods available for an object in Python?\n\ndir()\nhelp()\nlen()\ntype()\n\n\nAns: (A)\n\n\n\nO.1.14 (14) Which of the following statements is False?\n\nAttempting to divide by 0 results in a ZeroDivisionError.\nTrying to access a local variable outside its function’s block causes a NameError, indicating that the variable is not defined.\nAfter the last except clause, an optional else clause specifies code that should execute only if the code in the try suite raised an exception.\nThe finally clause is guaranteed to execute, regardless of whether its try clause executes successfully or an exception occurs.\n\n\nAns: (C). After the last except clause, an optional else clause specifies code that should execute only if the code in the try clause did not raise exceptions.\n\n\n\nO.1.15 (15) Assume that we execute the following assignment statement and user inputs an integer:\nspam1 = input()\nspam2 = int(spam1)/5\nspam3 = spam2 + 18\nWhich variable has a different data type than others?\n\nspam1\n\nspam2\n\nspam3\n\nAll of them have different data types\n\n\nAns: (A) is str while the other two will have float datatype."
  },
  {
    "objectID": "Quiz1_sol.html#b.-short-answer-and-coding-questions",
    "href": "Quiz1_sol.html#b.-short-answer-and-coding-questions",
    "title": "Appendix O — Quiz 1",
    "section": "O.2 B. Short-answer and coding questions",
    "text": "O.2 B. Short-answer and coding questions\n\nO.2.1 (16) Write programs that displays the following triangle patterns. Be sure to use for loops to generate the patterns. (8%)\nHint: You can display all asterisks (#) using the following statement:\nprint('#', end='')\n\n\n\n##########\n #########\n  ########\n   #######\n    ######\n     #####\n      ####\n       ###\n        ##\n         #\n\n\n\n         #\n        ##\n       ###\n      ####\n     #####\n    ######\n   #######\n  ########\n #########\n##########\n\nfor row in range(10, 0, -1):\n    for space in range(10, row, -1):\n        print(' ', end='')\n    for column in range(1, row + 1):\n        print('#', end='')\n    print()\n\n##########\n #########\n  ########\n   #######\n    ######\n     #####\n      ####\n       ###\n        ##\n         #\n\n\n\nfor row in range(10, 0, -1):\n    for space in range(1, row):\n        print(' ', end='')\n    for column in range(10, row - 1, -1):\n        print('#', end='')\n    print()\n\n         #\n        ##\n       ###\n      ####\n     #####\n    ######\n   #######\n  ########\n #########\n##########\n\n\n\nAns: double click here to answer the question.\n\n\n\nO.2.2 (17) Here, we will simulate the process of a simple card game. The game is played with a standard deck of 52 cards, and we will randomly select 30 cards and divide them evenly between two players. Each player gets a hand of 15 cards. The goal of the game is to determine whether the player got a straight (i.e., five cards of consecutive face values) or not in his 15 cards. If the players got a straight, please return True. Otherwise, return False. Please complete the following game design by filling in the missing part in the function. (8%).\n\nimport random\n\nRANKS = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n\ndef create_deck():\n    suits = ['♣', '♦', '♥', '♠']\n    deck = [(rank, suit) for rank in RANKS for suit in suits] # Use list comprehension to create the deck.\n    return deck\n\n# A function that takes the deck as a parameter and returns two lists, each containing 26 randomly-selected \n# cards from the deck. Use list slicing and the random module to implement this function.\ndef deal_cards(deck):\n    random.shuffle(deck)\n    deck = deck[:30]\n    hand1 = deck[:15]  # Split it into 15 cards in each using slice\n    hand2 = deck[15:]\n    return hand1, hand2\n\ndef get_ranks(hand):\n    \"\"\"Return just the ranks in hand.\"\"\"\n    return [rank for rank, suit in hand]\n\ndef rank_key(card):\n    return RANKS.index(card)\n\ndef sort_hand(hand):\n    \"\"\"Order hand by index of each face in RANKS.\"\"\"\n    return sorted(hand, key=rank_key)\n\ndef is_straight(hand):\n    \"\"\"Returns a Boolean indicating whether hand contains a straight.\"\"\"\n    # check for any 5 consecutive faces\n    # Your code here  \n    # 1. Return just the ranks in hand\n    ranks = get_ranks(hand)\n    # 2. Get unique rank from the ranks\n    ranks = set(ranks)\n    # 3. Sort the rank using the above function\n    ranks = sort_hand(ranks)\n    # 4. Using for loops to test whether we get a straight or not\n    for i in range(len(ranks) - 5):\n        for j in range(8):\n            if ranks[i:i+5] == RANKS[j:j+5]:\n                return True\n    return False\n\n\n# Test data 1\n\nrandom.seed(2023)\ndeck = create_deck()\nhand1, hand2 = deal_cards(deck)\n\ns1 = is_straight(hand1)\ns2 = is_straight(hand2)\n\n\n# Test data 2\nrandom.seed(20)\ndeck = create_deck()\nhand1, hand2 = deal_cards(deck)\n\ns3 = is_straight(hand1)\ns4 = is_straight(hand2)\n\nassert (s1,s2) == (True, True)\nassert (s3,s4) == (True, False)\n\n\n\nO.2.3 (18) In cryptoanalysis, frequency analysis is often used to decipher a message when the key is unknown. It calculates the frequency of each character in the encrypted text. Write a program that uses a dictionary to summarize the frequency of each letter in a given text. Treat uppercase and lowercase letters the same, ignore spaces and assume that the user does not enter any punctuation. Display the letters and their frequency in descending order by completing the following code snippet. (8%)\nHint: Refer to our slides to know how to count the number of occurrences of each letter in a string and how to sort the dictionaries according to the value.\n\ntext = 'This is some encrypted text with different words and this is some more text with a hidden message'\n\ncharacter_counts = {}\n\ntotal = 0\n# 1. Count occurrences of each letter, be sure to ignore the case and the space here\nfor character in \"\".join(text.lower().split()):\n    character_counts.setdefault(character, 0)\n    character_counts[character] = character_counts[character] + 1\n    total = total + 1\n\n# 2. Sort the dictionaries using the values\ndef value_key(x):\n    return x[1]\n\n# 3. Print out the character and the associated count\nfor character, count in sorted(character_counts.items(), key=value_key, reverse=True):\n    print(f'{character}: {count}')\n\ne: 12\nt: 10\ns: 9\ni: 8\nd: 6\nh: 5\no: 4\nm: 4\nn: 4\nr: 4\nw: 3\na: 3\nx: 2\nf: 2\nc: 1\ny: 1\np: 1\ng: 1\n\n\n\n\nO.2.4 (19) Write a function that receives a list of email addresses and returns a list that only contains the unique addresses. Treat uppercase and lowercase letters the same. The function should use a set to get the unique email addresses from the list. (6%)\n\ndef unique_address(mail):\n    \"\"\"\n    Parameters\n    ----------\n    mail: list\n        The input list that contains duplicated entries\n    Returns\n    -------\n    uniques : list\n        The list that contains unique entries\n    \"\"\"\n    # Your code here\n    uniques = list(set([m.lower() for m in mail]))\n    return uniques\n\n# Test data\ntext = ['John.doe@hotmail.com', 'michael.smith@gmail.com', 'ann.williams@msn.com', 'james.MILLER@gmail.com',\n        'james.miller@gmail.com', 'MICHAEL.smith@gmail.com', 'john.doe@hotmail.com','michael.smith@gmail.com']\n\nuniques = unique_address(text)\nprint(uniques)\n\n['ann.williams@msn.com', 'michael.smith@gmail.com', 'john.doe@hotmail.com', 'james.miller@gmail.com']\n\n\n\n\nO.2.5 (20) Assume that we have a plain text file that stores the grade for each student. Each row corresponds to each student, starting with the name of the student, followed by the three scores he/she got in each subject, separated by white space as follows: (6%)\nBob  96 80 100 \nAdam 73 90 95\nMichael 87 75 85\nHarry 85 80 75\nWrite program that reads the grades from the grades.txt and displays the average score for each student line by lien.\n\n# Read the file\nwith open('grades.txt') as file:\n    # Your code here\n    # Iterate over each line in the file\n    for line in file:\n        # Split the line into a list of strings using whitespace as a delimiter\n        cline = line.strip().split()\n\n        # Extract the student's name and grades\n        name = cline[0]\n        grades = [int(grade) for grade in cline[1:]]\n\n        # Calculate the average grade\n        avg_grade = sum(grades)/len(grades)\n\n        # Display the average grade for the student\n        print(f'{name}: {avg_grade}')\n\nBob: 92.0\nAdam: 86.0\nMichael: 82.33333333333333\nHarry: 80.0\n\n\n\n\nO.2.6 (21) Write a program that inputs a number of seconds from the user. Calculate the number of hours, minutes, and remaining seconds. You can assume that the user always enters a number of seconds higher than 3600. Print them separated by “ - ”. For example, if the user types 3850 seconds as input, the program should print: (5%)\n1 h - 4 m - 10 s\nHint: Use the floor division and the remainder operation to calculate the number of hours, minutes, and seconds.\n\n# Your code here\nseconds = int(input('Enter a number of seconds: '))\n\nhours = seconds // 3600\nseconds = seconds % 3600\n\nminutes =  seconds // 60\nseconds = seconds % 60\n\nprint(hours, 'h -' , minutes , 'm -', seconds, 's')\n\n1 h - 4 m - 10 s\n\n\n\n\nO.2.7 (22) Write a program that computes the value of \\(\\pi\\) from the following infinite series \\(4 \\times (1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}...-\\frac{(-1)^n}{2n-1})\\). Try to calculate how many terms you would need to get an error smaller than \\(10^{-3}\\). (6%)\nHint: Use the constant math.pi from the math module as the ground truth value for \\(\\pi\\) and use abs() to calculate the error.\n\nimport math\n\napprox_pi = 0\nprint(f\"Value of pi is: {math.pi}\")\nprint(f\"Initial error is: {abs(approx_pi-math.pi)}\")\n\n# Your code here\nn = 0\nerror = 1\n\nprint(\"Term\\tapproximation\\t\\terror\")\n\nwhile error &gt; 1e-3:\n    n += 1\n    term = (-1)**(n-1) / (2*n - 1)\n    approx_pi += 4 * term\n    error = abs(approx_pi - math.pi)\n    print(f'{n}\\t{approx_pi:.10f}\\t{error:.10f}')\n\nValue of pi is: 3.141592653589793\nInitial error is: 3.141592653589793\nTerm    approximation       error\n1   4.0000000000    0.8584073464\n2   2.6666666667    0.4749259869\n3   3.4666666667    0.3250740131\n4   2.8952380952    0.2463545584\n5   3.3396825397    0.1980898861\n6   2.9760461760    0.1655464775\n7   3.2837384837    0.1421458301\n8   3.0170718171    0.1245208365\n9   3.2523659347    0.1107732811\n10  3.0418396189    0.0997530347\n11  3.2323158094    0.0907231558\n12  3.0584027659    0.0831898877\n13  3.2184027659    0.0768101123\n14  3.0702546178    0.0713380358\n15  3.2081856523    0.0665929987\n16  3.0791533942    0.0624392594\n17  3.2003655154    0.0587728618\n18  3.0860798011    0.0555128525\n19  3.1941879092    0.0525952556\n20  3.0916238067    0.0499688469\n21  3.1891847823    0.0475921287\n22  3.0961615265    0.0454311271\n23  3.1850504154    0.0434577618\n24  3.0999440324    0.0416486212\n25  3.1815766854    0.0399840318\n26  3.1031453129    0.0384473407\n27  3.1786170110    0.0370243574\n28  3.1058897383    0.0357029153\n29  3.1760651769    0.0344725233\n30  3.1082685667    0.0333240869\n31  3.1738423372    0.0322496836\n32  3.1103502737    0.0312423799\n33  3.1718887352    0.0302960816\n34  3.1121872427    0.0294054109\n35  3.1701582572    0.0285656036\n36  3.1138202290    0.0277724246\n37  3.1686147496    0.0270220960\n38  3.1152814162    0.0263112374\n39  3.1672294682    0.0256368146\n40  3.1165965568    0.0249960968\n41  3.1659792728    0.0243866193\n42  3.1177865018    0.0238061518\n43  3.1648453253    0.0232526717\n44  3.1188683138    0.0227243398\n45  3.1638121340    0.0222194804\n46  3.1198560901    0.0217365635\n47  3.1628668428    0.0212741892\n48  3.1207615796    0.0208310740\n49  3.1619986930    0.0204060394\n50  3.1215946526    0.0199980010\n51  3.1611986130    0.0196059594\n52  3.1223636615    0.0192289921\n53  3.1604588996    0.0188662460\n54  3.1230757221    0.0185169315\n55  3.1597729698    0.0181803162\n56  3.1237369337    0.0178557199\n57  3.1591351638    0.0175425102\n58  3.1243525551    0.0172400985\n59  3.1585405893    0.0169479357\n60  3.1249271439    0.0166655097\n61  3.1579849952    0.0163923416\n62  3.1254646700    0.0161279836\n63  3.1574646700    0.0158720164\n64  3.1259686070    0.0156240466\n65  3.1569763589    0.0153837053\n66  3.1264420078    0.0151506458\n67  3.1565171957    0.0149245421\n68  3.1268875661    0.0147050875\n69  3.1560846464    0.0144919928\n70  3.1273076680    0.0142849856\n71  3.1556764623    0.0140838087\n72  3.1277044343    0.0138882193\n73  3.1552906412    0.0136979876\n74  3.1280797569    0.0135128967\n75  3.1549253945    0.0133327409\n76  3.1284353282    0.0131573254\n77  3.1545791191    0.0129864655\n78  3.1287726675    0.0128199861\n79  3.1542503745    0.0126577209\n80  3.1290931418    0.0124995118\n81  3.1539378623    0.0123452087\n82  3.1293979850    0.0121946686\n83  3.1536404092    0.0120477556\n84  3.1296883134    0.0119043402\n85  3.1533569525    0.0117642989\n86  3.1299651396    0.0116275140\n87  3.1530865269    0.0114938733\n88  3.1302293840    0.0113632696\n89  3.1528282541    0.0112356005\n90  3.1304818854    0.0111107682\n91  3.1525813329    0.0109886793\n92  3.1307234094    0.0108692442\n93  3.1523450310    0.0107523774\n94  3.1309546567    0.0106379969\n95  3.1521186778    0.0105260242\n96  3.1311762695    0.0104163841\n97  3.1519016581    0.0103090045\n98  3.1313888375    0.0102038160\n99  3.1516934061    0.0101007525\n100 3.1315929036    0.0099997500\n101 3.1514934011    0.0099007475\n102 3.1317889676    0.0098036860\n103 3.1513011627    0.0097085091\n104 3.1319774912    0.0096151624\n105 3.1511162472    0.0095235936\n106 3.1321589012    0.0094337524\n107 3.1509382439    0.0093455903\n108 3.1323335928    0.0092590608\n109 3.1507667725    0.0091741189\n110 3.1325019323    0.0090907213\n111 3.1506014798    0.0090088262\n112 3.1326642601    0.0089283935\n113 3.1504420379    0.0088493843\n114 3.1328208925    0.0087717611\n115 3.1502881414    0.0086954878\n116 3.1329721241    0.0086205295\n117 3.1501395061    0.0085468525\n118 3.1331182295    0.0084744241\n119 3.1499958666    0.0084032130\n120 3.1332594649    0.0083331887\n121 3.1498569753    0.0082643217\n122 3.1333960699    0.0081965836\n123 3.1497226006    0.0081299470\n124 3.1335282686    0.0080643850\n125 3.1495925256    0.0079998720\n126 3.1336562706    0.0079363830\n127 3.1494665473    0.0078738937\n128 3.1337802728    0.0078123808\n129 3.1493444751    0.0077518215\n130 3.1339004597    0.0076921939\n131 3.1492261302    0.0076334766\n132 3.1340170047    0.0075756489\n133 3.1491113443    0.0075186907\n134 3.1341300709    0.0074625827\n135 3.1489999594    0.0074073058\n136 3.1342398118    0.0073528418\n137 3.1488918264    0.0072991729\n138 3.1343463719    0.0072462817\n139 3.1487868051    0.0071941515\n140 3.1344498875    0.0071427660\n141 3.1486847630    0.0070921094\n142 3.1345504874    0.0070421662\n143 3.1485855751    0.0069929215\n144 3.1346482929    0.0069443607\n145 3.1484891233    0.0068964697\n146 3.1347434188    0.0068492347\n147 3.1483952960    0.0068026424\n148 3.1348359739    0.0067566796\n149 3.1483039874    0.0067113338\n150 3.1349260610    0.0066665926\n151 3.1482150975    0.0066224439\n152 3.1350137774    0.0065788762\n153 3.1481285315    0.0065358779\n154 3.1350992155    0.0064934380\n155 3.1480441994    0.0064515458\n156 3.1351824630    0.0064101906\n157 3.1479620157    0.0063693622\n158 3.1352636030    0.0063290505\n159 3.1478818996    0.0062892460\n160 3.1353427146    0.0062499390\n161 3.1478037738    0.0062111202\n162 3.1354198729    0.0061727807\n163 3.1477275652    0.0061349116\n164 3.1354951493    0.0060975043\n165 3.1476532040    0.0060605504\n166 3.1355686119    0.0060240417\n167 3.1475806239    0.0059879703\n168 3.1356403254    0.0059523282\n169 3.1475097616    0.0059171080\n170 3.1357103515    0.0058823021\n171 3.1474405568    0.0058479032\n172 3.1357787492    0.0058139044\n173 3.1473729521    0.0057802985\n174 3.1358455746    0.0057470790\n175 3.1473068927    0.0057142391\n176 3.1359108813    0.0056817723\n177 3.1472423260    0.0056496724\n178 3.1359747204    0.0056179332\n179 3.1471792022    0.0055865486\n180 3.1360371409    0.0055555127\n181 3.1471174733    0.0055248197\n182 3.1360981896    0.0054944640\n183 3.1470570937    0.0054644401\n184 3.1361579111    0.0054347425\n185 3.1469980195    0.0054053659\n186 3.1362163484    0.0053763052\n187 3.1469402089    0.0053475554\n188 3.1362735423    0.0053191113\n189 3.1468836219    0.0052909683\n190 3.1363295321    0.0052631214\n191 3.1468282198    0.0052355662\n192 3.1363843556    0.0052082980\n193 3.1467739660    0.0051813124\n194 3.1364380487    0.0051546049\n195 3.1467208250    0.0051281714\n196 3.1364906460    0.0051020076\n197 3.1466687630    0.0050761094\n198 3.1365421807    0.0050504728\n199 3.1466177475    0.0050250939\n200 3.1365926848    0.0049999688\n201 3.1465677472    0.0049750936\n202 3.1366421889    0.0049504647\n203 3.1465187321    0.0049260785\n204 3.1366907223    0.0049019313\n205 3.1464706734    0.0048780198\n206 3.1367383133    0.0048543403\n207 3.1464235433    0.0048308897\n208 3.1367849891    0.0048076645\n209 3.1463773152    0.0047846616\n210 3.1368307758    0.0047618778\n211 3.1463319635    0.0047393099\n212 3.1368756987    0.0047169549\n213 3.1462874634    0.0046948098\n214 3.1369197819    0.0046728717\n215 3.1462437912    0.0046511376\n216 3.1369630488    0.0046296048\n217 3.1462009241    0.0046082705\n218 3.1370055218    0.0045871318\n219 3.1461588398    0.0045661862\n220 3.1370472225    0.0045454311\n221 3.1461175173    0.0045248637\n222 3.1370881719    0.0045044817\n223 3.1460769360    0.0044842824\n224 3.1371283901    0.0044642635\n225 3.1460370761    0.0044444225\n226 3.1371678965    0.0044247571\n227 3.1459979186    0.0044052650\n228 3.1372067098    0.0043859438\n229 3.1459594450    0.0043667914\n230 3.1372448480    0.0043478055\n231 3.1459216376    0.0043289840\n232 3.1372823288    0.0043103248\n233 3.1458844793    0.0042918257\n234 3.1373191688    0.0042734848\n235 3.1458479535    0.0042552999\n236 3.1373553845    0.0042372691\n237 3.1458120441    0.0042193905\n238 3.1373909915    0.0042016621\n239 3.1457767357    0.0041840821\n240 3.1374260050    0.0041666486\n241 3.1457420133    0.0041493597\n242 3.1374604398    0.0041322138\n243 3.1457078625    0.0041152089\n244 3.1374943101    0.0040983434\n245 3.1456742692    0.0040816157\n246 3.1375276297    0.0040650239\n247 3.1456412200    0.0040485664\n248 3.1375604119    0.0040322417\n249 3.1456087017    0.0040160481\n250 3.1375926696    0.0039999840\n251 3.1455767015    0.0039840479\n252 3.1376244152    0.0039682383\n253 3.1455452073    0.0039525537\n254 3.1376556610    0.0039369926\n255 3.1455142071    0.0039215536\n256 3.1376864185    0.0039062351\n257 3.1454836894    0.0038910359\n258 3.1377166992    0.0038759544\n259 3.1454536431    0.0038609895\n260 3.1377465140    0.0038461396\n261 3.1454240572    0.0038314036\n262 3.1377758736    0.0038167800\n263 3.1453949212    0.0038022676\n264 3.1378047884    0.0037878652\n265 3.1453662251    0.0037735715\n266 3.1378332684    0.0037593852\n267 3.1453379588    0.0037453052\n268 3.1378613233    0.0037313303\n269 3.1453101129    0.0037174593\n270 3.1378889626    0.0037036910\n271 3.1452826779    0.0036900243\n272 3.1379161954    0.0036764582\n273 3.1452556450    0.0036629914\n274 3.1379430307    0.0036496229\n275 3.1452290052    0.0036363516\n276 3.1379694771    0.0036231765\n277 3.1452027501    0.0036100965\n278 3.1379955429    0.0035971107\n279 3.1451768715    0.0035842179\n280 3.1380212364    0.0035714172\n281 3.1451513612    0.0035587076\n282 3.1380465654    0.0035460881\n283 3.1451262115    0.0035335579\n284 3.1380715377    0.0035211158\n285 3.1451014147    0.0035087611\n286 3.1380961608    0.0034964928\n287 3.1450769636    0.0034843100\n288 3.1381204418    0.0034722118\n289 3.1450528508    0.0034601973\n290 3.1381443880    0.0034482656\n291 3.1450290696    0.0034364160\n292 3.1381680061    0.0034246475\n293 3.1450056129    0.0034129593\n294 3.1381913029    0.0034013507\n295 3.1449824744    0.0033898208\n296 3.1382142849    0.0033783687\n297 3.1449596474    0.0033669938\n298 3.1382369583    0.0033556953\n299 3.1449371258    0.0033444723\n300 3.1382593295    0.0033333241\n301 3.1449149036    0.0033222500\n302 3.1382814044    0.0033112492\n303 3.1448929746    0.0033003210\n304 3.1383031888    0.0032894648\n305 3.1448713333    0.0032786797\n306 3.1383246885    0.0032679651\n307 3.1448499739    0.0032573204\n308 3.1383459089    0.0032467447\n309 3.1448288911    0.0032362375\n310 3.1383668555    0.0032257981\n311 3.1448080794    0.0032154258\n312 3.1383875336    0.0032051200\n313 3.1447875336    0.0031948800\n314 3.1384079483    0.0031847053\n315 3.1447672488    0.0031745952\n316 3.1384281046    0.0031645490\n317 3.1447472199    0.0031545663\n318 3.1384480073    0.0031446463\n319 3.1447274421    0.0031347885\n320 3.1384676612    0.0031249924\n321 3.1447079108    0.0031152572\n322 3.1384870710    0.0031055826\n323 3.1446886214    0.0030959678\n324 3.1385062412    0.0030864124\n325 3.1446695694    0.0030769158\n326 3.1385251761    0.0030674774\n327 3.1446507504    0.0030580968\n328 3.1385438802    0.0030487734\n329 3.1446321602    0.0030395067\n330 3.1385623575    0.0030302961\n331 3.1446137947    0.0030211411\n332 3.1385806122    0.0030120414\n333 3.1445956498    0.0030029962\n334 3.1385986483    0.0029940053\n335 3.1445777216    0.0029850680\n336 3.1386164697    0.0029761839\n337 3.1445600061    0.0029673525\n338 3.1386340802    0.0029585734\n339 3.1445424997    0.0029498461\n340 3.1386514835    0.0029411701\n341 3.1445251986    0.0029325450\n342 3.1386686832    0.0029239704\n343 3.1445080993    0.0029154457\n344 3.1386856830    0.0029069706\n345 3.1444911982    0.0028985446\n346 3.1387024862    0.0028901674\n347 3.1444744920    0.0028818384\n348 3.1387190963    0.0028735573\n349 3.1444579772    0.0028653236\n350 3.1387355166    0.0028571370\n351 3.1444416507    0.0028489971\n352 3.1387517502    0.0028409034\n353 3.1444255091    0.0028328555\n354 3.1387678005    0.0028248531\n355 3.1444095494    0.0028168958\n356 3.1387836704    0.0028089832\n357 3.1443937685    0.0028011150\n358 3.1387993629    0.0027932906\n359 3.1443781635    0.0027855099\n360 3.1388148812    0.0027777724\n361 3.1443627314    0.0027700778\n362 3.1388302279    0.0027624257\n363 3.1443474693    0.0027548157\n364 3.1388454060    0.0027472476\n365 3.1443323745    0.0027397209\n366 3.1388604183    0.0027322353\n367 3.1443174442    0.0027247906\n368 3.1388752673    0.0027173863\n369 3.1443026757    0.0027100221\n370 3.1388899558    0.0027026978\n371 3.1442880665    0.0026954129\n372 3.1389044864    0.0026881672\n373 3.1442736139    0.0026809603\n374 3.1389188616    0.0026737920\n375 3.1442593155    0.0026666619\n376 3.1389330838    0.0026595698\n377 3.1442451688    0.0026525152\n378 3.1389471556    0.0026454980\n379 3.1442311714    0.0026385178\n380 3.1389610792    0.0026315744\n381 3.1442173210    0.0026246674\n382 3.1389748570    0.0026177966\n383 3.1442036152    0.0026109616\n384 3.1389884913    0.0026041623\n385 3.1441900518    0.0025973982\n386 3.1390019844    0.0025906692\n387 3.1441766286    0.0025839750\n388 3.1390153383    0.0025773153\n389 3.1441633434    0.0025706898\n390 3.1390285552    0.0025640983\n391 3.1441501942    0.0025575406\n392 3.1390416373    0.0025510163\n393 3.1441371787    0.0025445251\n394 3.1390545866    0.0025380670\n395 3.1441242951    0.0025316415\n396 3.1390674051    0.0025252485\n397 3.1441115413    0.0025188877\n398 3.1390800947    0.0025125588\n399 3.1440989153    0.0025062617\n400 3.1390926575    0.0024999961\n401 3.1440864153    0.0024937617\n402 3.1391050952    0.0024875583\n403 3.1440740393    0.0024813858\n404 3.1391174099    0.0024752437\n405 3.1440617856    0.0024691320\n406 3.1391296031    0.0024630505\n407 3.1440496523    0.0024569987\n408 3.1391416769    0.0024509767\n409 3.1440376377    0.0024449841\n410 3.1391536328    0.0024390208\n411 3.1440257400    0.0024330864\n412 3.1391654727    0.0024271809\n413 3.1440139575    0.0024213040\n414 3.1391771982    0.0024154554\n415 3.1440022886    0.0024096351\n416 3.1391888109    0.0024038427\n417 3.1439907317    0.0023980781\n418 3.1392003125    0.0023923411\n419 3.1439792850    0.0023866314\n420 3.1392117046    0.0023809490\n421 3.1439679472    0.0023752936\n422 3.1392229887    0.0023696649\n423 3.1439567165    0.0023640629\n424 3.1392341663    0.0023584873\n425 3.1439455915    0.0023529379\n426 3.1392452390    0.0023474146\n427 3.1439345708    0.0023419172\n428 3.1392562082    0.0023364454\n429 3.1439236528    0.0023309992\n430 3.1392670753    0.0023255783\n431 3.1439128361    0.0023201825\n432 3.1392778419    0.0023148117\n433 3.1439021193    0.0023094657\n434 3.1392885092    0.0023041444\n435 3.1438915011    0.0022988475\n436 3.1392990786    0.0022935750\n437 3.1438809801    0.0022883265\n438 3.1393095515    0.0022831020\n439 3.1438705550    0.0022779014\n440 3.1393199293    0.0022727243\n441 3.1438602244    0.0022675708\n442 3.1393302130    0.0022624405\n443 3.1438499871    0.0022573335\n444 3.1393404042    0.0022522494\n445 3.1438398418    0.0022471882\n446 3.1393505039    0.0022421496\n447 3.1438297873    0.0022371337\n448 3.1393605135    0.0022321401\n449 3.1438198223    0.0022271687\n450 3.1393704341    0.0022222195\n451 3.1438099458    0.0022172922\n452 3.1393802669    0.0022123867\n453 3.1438001564    0.0022075028\n454 3.1393900131    0.0022026405\n455 3.1437904531    0.0021977995\n456 3.1393996738    0.0021929798\n457 3.1437808348    0.0021881812\n458 3.1394092501    0.0021834035\n459 3.1437713002    0.0021786467\n460 3.1394187431    0.0021739105\n461 3.1437618484    0.0021691948\n462 3.1394281540    0.0021644996\n463 3.1437524783    0.0021598247\n464 3.1394374837    0.0021551699\n465 3.1437431887    0.0021505351\n466 3.1394467333    0.0021459203\n467 3.1437339788    0.0021413252\n468 3.1394559039    0.0021367497\n469 3.1437248473    0.0021321937\n470 3.1394649964    0.0021276572\n471 3.1437157934    0.0021231399\n472 3.1394740119    0.0021186417\n473 3.1437068161    0.0021141625\n474 3.1394829513    0.0021097023\n475 3.1436979144    0.0021052608\n476 3.1394918156    0.0021008380\n477 3.1436890873    0.0020964338\n478 3.1395006057    0.0020920479\n479 3.1436803340    0.0020876804\n480 3.1395093225    0.0020833311\n481 3.1436716534    0.0020789998\n482 3.1395179670    0.0020746866\n483 3.1436630447    0.0020703912\n484 3.1395265401    0.0020661135\n485 3.1436545071    0.0020618535\n486 3.1395350426    0.0020576110\n487 3.1436460395    0.0020533859\n488 3.1395434754    0.0020491782\n489 3.1436376412    0.0020449876\n490 3.1395518394    0.0020408142\n491 3.1436293114    0.0020366578\n492 3.1395601354    0.0020325182\n493 3.1436210491    0.0020283955\n494 3.1395683642    0.0020242894\n495 3.1436128535    0.0020202000\n496 3.1395765266    0.0020161270\n497 3.1436047240    0.0020120704\n498 3.1395846235    0.0020080301\n499 3.1435966596    0.0020040060\n500 3.1395926556    0.0019999980\n501 3.1435886596    0.0019960060\n502 3.1396006237    0.0019920299\n503 3.1435807232    0.0019880696\n504 3.1396085286    0.0019841250\n505 3.1435728497    0.0019801961\n506 3.1396163709    0.0019762827\n507 3.1435650383    0.0019723847\n508 3.1396241516    0.0019685020\n509 3.1435572882    0.0019646346\n510 3.1396318712    0.0019607824\n511 3.1435495989    0.0019569453\n512 3.1396395305    0.0019531231\n513 3.1435419695    0.0019493159\n514 3.1396471301    0.0019455235\n515 3.1435343993    0.0019417457\n516 3.1396546709    0.0019379827\n517 3.1435268878    0.0019342342\n518 3.1396621535    0.0019305001\n519 3.1435194341    0.0019267805\n520 3.1396695784    0.0019230751\n521 3.1435120376    0.0019193840\n522 3.1396769465    0.0019157071\n523 3.1435046977    0.0019120441\n524 3.1396842584    0.0019083952\n525 3.1434974138    0.0019047602\n526 3.1396915146    0.0019011390\n527 3.1434901851    0.0018975315\n528 3.1396987159    0.0018939377\n529 3.1434830111    0.0018903575\n530 3.1397058628    0.0018867908\n531 3.1434758911    0.0018832375\n532 3.1397129560    0.0018796976\n533 3.1434688245    0.0018761710\n534 3.1397199961    0.0018726575\n535 3.1434618108    0.0018691572\n536 3.1397269836    0.0018656700\n537 3.1434548494    0.0018621958\n538 3.1397339191    0.0018587345\n539 3.1434479396    0.0018552860\n540 3.1397408033    0.0018518503\n541 3.1434410808    0.0018484273\n542 3.1397476367    0.0018450169\n543 3.1434342727    0.0018416191\n544 3.1397544198    0.0018382337\n545 3.1434275144    0.0018348608\n546 3.1397611533    0.0018315003\n547 3.1434208056    0.0018281520\n548 3.1397678376    0.0018248160\n549 3.1434141457    0.0018214921\n550 3.1397744733    0.0018181803\n551 3.1434075341    0.0018148805\n552 3.1397810609    0.0018115927\n553 3.1434009704    0.0018083168\n554 3.1397876009    0.0018050527\n555 3.1433944539    0.0018018003\n556 3.1397940939    0.0017985597\n557 3.1433879843    0.0017953307\n558 3.1398005403    0.0017921133\n559 3.1433815609    0.0017889073\n560 3.1398069407    0.0017857129\n561 3.1433751834    0.0017825298\n562 3.1398132956    0.0017793580\n563 3.1433688511    0.0017761975\n564 3.1398196053    0.0017730483\n565 3.1433625637    0.0017699101\n566 3.1398258705    0.0017667831\n567 3.1433563206    0.0017636671\n568 3.1398320916    0.0017605620\n569 3.1433501215    0.0017574679\n570 3.1398382690    0.0017543846\n571 3.1433439657    0.0017513121\n572 3.1398444032    0.0017482504\n573 3.1433378530    0.0017451994\n574 3.1398504946    0.0017421590\n575 3.1433317827    0.0017391291\n576 3.1398565438    0.0017361098\n577 3.1433257545    0.0017331010\n578 3.1398625511    0.0017301025\n579 3.1433197680    0.0017271144\n580 3.1398685169    0.0017241366\n581 3.1433138227    0.0017211691\n582 3.1398744418    0.0017182118\n583 3.1433079182    0.0017152646\n584 3.1398803261    0.0017123275\n585 3.1433020541    0.0017094005\n586 3.1398861702    0.0017064834\n587 3.1432962299    0.0017035763\n588 3.1398919745    0.0017006790\n589 3.1432904452    0.0016977916\n590 3.1398977396    0.0016949140\n591 3.1432846998    0.0016920462\n592 3.1399034656    0.0016891880\n593 3.1432789930    0.0016863394\n594 3.1399091531    0.0016835005\n595 3.1432733247    0.0016806711\n596 3.1399148024    0.0016778512\n597 3.1432676943    0.0016750407\n598 3.1399204140    0.0016722396\n599 3.1432621015    0.0016694479\n600 3.1399259881    0.0016666655\n601 3.1432565459    0.0016638924\n602 3.1399315252    0.0016611284\n603 3.1432510272    0.0016583737\n604 3.1399370256    0.0016556280\n605 3.1432455450    0.0016528914\n606 3.1399424897    0.0016501639\n607 3.1432400989    0.0016474453\n608 3.1399479179    0.0016447357\n609 3.1432346886    0.0016420350\n610 3.1399533104    0.0016393432\n611 3.1432293137    0.0016366601\n612 3.1399586678    0.0016339858\n613 3.1432239739    0.0016313203\n614 3.1399639902    0.0016286634\n615 3.1432186688    0.0016260152\n616 3.1399692780    0.0016233756\n617 3.1432133981    0.0016207445\n618 3.1399745317    0.0016181219\n619 3.1432081614    0.0016155078\n620 3.1399797514    0.0016129022\n621 3.1432029585    0.0016103049\n622 3.1399849376    0.0016077160\n623 3.1431977890    0.0016051354\n624 3.1399900905    0.0016025631\n625 3.1431926526    0.0015999990\n626 3.1399952105    0.0015974431\n627 3.1431875489    0.0015948953\n628 3.1400002979    0.0015923557\n629 3.1431824777    0.0015898241\n630 3.1400053530    0.0015873006\n631 3.1431774386    0.0015847851\n632 3.1400103761    0.0015822775\n633 3.1431724314    0.0015797778\n634 3.1400153675    0.0015772861\n635 3.1431674558    0.0015748022\n636 3.1400203275    0.0015723261\n637 3.1431625113    0.0015698577\n638 3.1400252564    0.0015673972\n639 3.1431575979    0.0015649443\n640 3.1400301545    0.0015624990\n641 3.1431527150    0.0015600615\n642 3.1400350221    0.0015576315\n643 3.1431478626    0.0015552090\n644 3.1400398595    0.0015527941\n645 3.1431430403    0.0015503867\n646 3.1400446669    0.0015479867\n647 3.1431382477    0.0015455941\n648 3.1400494446    0.0015432090\n649 3.1431334847    0.0015408311\n650 3.1400541930    0.0015384606\n651 3.1431287510    0.0015360974\n652 3.1400589122    0.0015337414\n653 3.1431240463    0.0015313927\n654 3.1400636025    0.0015290511\n655 3.1431193703    0.0015267167\n656 3.1400682642    0.0015243894\n657 3.1431147227    0.0015220691\n658 3.1400728976    0.0015197560\n659 3.1431101034    0.0015174498\n660 3.1400775029    0.0015151506\n661 3.1431055120    0.0015128584\n662 3.1400820804    0.0015105732\n663 3.1431009484    0.0015082948\n664 3.1400866303    0.0015060232\n665 3.1430964121    0.0015037585\n666 3.1400911529    0.0015015007\n667 3.1430919031    0.0014992495\n668 3.1400956484    0.0014970051\n669 3.1430874211    0.0014947675\n670 3.1401001171    0.0014925365\n671 3.1430829657    0.0014903121\n672 3.1401045592    0.0014880944\n673 3.1430785369    0.0014858833\n674 3.1401089749    0.0014836787\n675 3.1430741343    0.0014814807\n676 3.1401133645    0.0014792891\n677 3.1430697577    0.0014771041\n678 3.1401177281    0.0014749255\n679 3.1430654068    0.0014727533\n680 3.1401220661    0.0014705874\n681 3.1430610816    0.0014684280\n682 3.1401263787    0.0014662749\n683 3.1430567816    0.0014641281\n684 3.1401306661    0.0014619875\n685 3.1430525068    0.0014598532\n686 3.1401349284    0.0014577252\n687 3.1430482569    0.0014556033\n688 3.1401391660    0.0014534876\n689 3.1430440316    0.0014513780\n690 3.1401433790    0.0014492746\n691 3.1430398308    0.0014471772\n692 3.1401475676    0.0014450860\n693 3.1430356543    0.0014430007\n694 3.1401517321    0.0014409214\n695 3.1430315018    0.0014388482\n696 3.1401558727    0.0014367809\n697 3.1430273731    0.0014347195\n698 3.1401599896    0.0014326640\n699 3.1430232680    0.0014306144\n700 3.1401640829    0.0014285707\n701 3.1430191864    0.0014265328\n702 3.1401681529    0.0014245007\n703 3.1430151280    0.0014224744\n704 3.1401721998    0.0014204538\n705 3.1430110926    0.0014184390\n706 3.1401762237    0.0014164299\n707 3.1430070800    0.0014144264\n708 3.1401802249    0.0014124287\n709 3.1430030901    0.0014104365\n710 3.1401842036    0.0014084500\n711 3.1429991227    0.0014064691\n712 3.1401881599    0.0014044937\n713 3.1429951774    0.0014025239\n714 3.1401920941    0.0014005595\n715 3.1429912543    0.0013986007\n716 3.1401960062    0.0013966474\n717 3.1429873531    0.0013946995\n718 3.1401998966    0.0013927570\n719 3.1429834735    0.0013908199\n720 3.1402037654    0.0013888882\n721 3.1429796155    0.0013869619\n722 3.1402076127    0.0013850409\n723 3.1429757788    0.0013831252\n724 3.1402114388    0.0013812148\n725 3.1429719633    0.0013793097\n726 3.1402152438    0.0013774098\n727 3.1429681688    0.0013755152\n728 3.1402190279    0.0013736257\n729 3.1429643951    0.0013717415\n730 3.1402227912    0.0013698624\n731 3.1429606420    0.0013679884\n732 3.1402265340    0.0013661196\n733 3.1429569094    0.0013642558\n734 3.1402302564    0.0013623972\n735 3.1429531972    0.0013605436\n736 3.1402339586    0.0013586950\n737 3.1429495051    0.0013568515\n738 3.1402376407    0.0013550129\n739 3.1429458329    0.0013531794\n740 3.1402413029    0.0013513507\n741 3.1429421806    0.0013495271\n742 3.1402449453    0.0013477083\n743 3.1429385480    0.0013458944\n744 3.1402485682    0.0013440854\n745 3.1429349349    0.0013422813\n746 3.1402521716    0.0013404820\n747 3.1429313411    0.0013386875\n748 3.1402557558    0.0013368978\n749 3.1429277665    0.0013351129\n750 3.1402593208    0.0013333327\n751 3.1429242109    0.0013315573\n752 3.1402628669    0.0013297866\n753 3.1429206743    0.0013280207\n754 3.1402663942    0.0013262594\n755 3.1429171563    0.0013245027\n756 3.1402699028    0.0013227507\n757 3.1429136570    0.0013210034\n758 3.1402733930    0.0013192606\n759 3.1429101761    0.0013175225\n760 3.1402768647    0.0013157889\n761 3.1429067135    0.0013140599\n762 3.1402803182    0.0013123354\n763 3.1429032690    0.0013106154\n764 3.1402837536    0.0013089000\n765 3.1428998426    0.0013071890\n766 3.1402871711    0.0013054825\n767 3.1428964340    0.0013037804\n768 3.1402905708    0.0013020828\n769 3.1428930432    0.0013003896\n770 3.1402939528    0.0012987008\n771 3.1428896699    0.0012970163\n772 3.1402973173    0.0012953362\n773 3.1428863141    0.0012936605\n774 3.1403006645    0.0012919891\n775 3.1428829756    0.0012903220\n776 3.1403039943    0.0012886593\n777 3.1428796543    0.0012870008\n778 3.1403073071    0.0012853465\n779 3.1428763501    0.0012836965\n780 3.1403106028    0.0012820508\n781 3.1428730628    0.0012804092\n782 3.1403138817    0.0012787719\n783 3.1428697923    0.0012771387\n784 3.1403171439    0.0012755097\n785 3.1428665384    0.0012738848\n786 3.1403203895    0.0012722641\n787 3.1428633011    0.0012706475\n788 3.1403236186    0.0012690350\n789 3.1428600802    0.0012674266\n790 3.1403268313    0.0012658223\n791 3.1428568756    0.0012642220\n792 3.1403300278    0.0012626258\n793 3.1428536871    0.0012610335\n794 3.1403332082    0.0012594453\n795 3.1428505147    0.0012578611\n796 3.1403363727    0.0012562809\n797 3.1428473582    0.0012547047\n798 3.1403395212    0.0012531323\n799 3.1428442176    0.0012515640\n800 3.1403426541    0.0012499995\n801 3.1428410926    0.0012484390\n802 3.1403457713    0.0012468823\n803 3.1428379831    0.0012453295\n804 3.1403488730    0.0012437806\n805 3.1428348891    0.0012422355\n806 3.1403519593    0.0012406943\n807 3.1428318105    0.0012391569\n808 3.1403550303    0.0012376233\n809 3.1428287471    0.0012360935\n810 3.1403580862    0.0012345674\n811 3.1428256987    0.0012330452\n812 3.1403611270    0.0012315266\n813 3.1428226654    0.0012300118\n814 3.1403641528    0.0012285008\n815 3.1428196470    0.0012269934\n816 3.1403671639    0.0012254897\n817 3.1428166433    0.0012239897\n818 3.1403701602    0.0012224934\n819 3.1428136544    0.0012210008\n820 3.1403731418    0.0012195117\n821 3.1428106799    0.0012180263\n822 3.1403761090    0.0012165446\n823 3.1428077200    0.0012150664\n824 3.1403790618    0.0012135918\n825 3.1428047744    0.0012121208\n826 3.1403820003    0.0012106533\n827 3.1428018430    0.0012091894\n828 3.1403849246    0.0012077290\n829 3.1427989258    0.0012062722\n830 3.1403878347    0.0012048188\n831 3.1427960226    0.0012033690\n832 3.1403907309    0.0012019226\n833 3.1427931333    0.0012004798\n834 3.1403936133    0.0011990403\n835 3.1427902580    0.0011976044\n836 3.1403964818    0.0011961718\n837 3.1427873963    0.0011947427\n838 3.1403993366    0.0011933170\n839 3.1427845483    0.0011918947\n840 3.1404021778    0.0011904758\n841 3.1427817138    0.0011890602\n842 3.1404050056    0.0011876480\n843 3.1427788928    0.0011862392\n844 3.1404078199    0.0011848337\n845 3.1427760851    0.0011834315\n846 3.1404106209    0.0011820327\n847 3.1427732907    0.0011806371\n848 3.1404134087    0.0011792449\n849 3.1427705095    0.0011778559\n850 3.1404161834    0.0011764702\n851 3.1427677413    0.0011750877\n852 3.1404189451    0.0011737085\n853 3.1427649861    0.0011723325\n854 3.1404216938    0.0011709598\n855 3.1427622438    0.0011695902\n856 3.1404244297    0.0011682239\n857 3.1427595143    0.0011668607\n858 3.1404271528    0.0011655008\n859 3.1427567975    0.0011641440\n860 3.1404298633    0.0011627903\n861 3.1427540934    0.0011614398\n862 3.1404325612    0.0011600924\n863 3.1427514018    0.0011587482\n864 3.1404352466    0.0011574070\n865 3.1427487226    0.0011560690\n866 3.1404379196    0.0011547340\n867 3.1427460557    0.0011534022\n868 3.1404405802    0.0011520734\n869 3.1427434012    0.0011507476\n870 3.1404432287    0.0011494249\n871 3.1427407588    0.0011481052\n872 3.1404458650    0.0011467886\n873 3.1427381286    0.0011454750\n874 3.1404484892    0.0011441644\n875 3.1427355104    0.0011428568\n876 3.1404511015    0.0011415521\n877 3.1427329041    0.0011402505\n878 3.1404537018    0.0011389518\n879 3.1427303096    0.0011376561\n880 3.1404562903    0.0011363633\n881 3.1427277270    0.0011350734\n882 3.1404588671    0.0011337865\n883 3.1427251561    0.0011325025\n884 3.1404614322    0.0011312214\n885 3.1427225967    0.0011299431\n886 3.1404639858    0.0011286678\n887 3.1427200489    0.0011273954\n888 3.1404665278    0.0011261258\n889 3.1427175126    0.0011248590\n890 3.1404690584    0.0011235952\n891 3.1427149877    0.0011223341\n892 3.1404715777    0.0011210759\n893 3.1427124741    0.0011198205\n894 3.1404740857    0.0011185679\n895 3.1427099717    0.0011173181\n896 3.1404765825    0.0011160711\n897 3.1427074804    0.0011148269\n898 3.1404790682    0.0011135854\n899 3.1427050003    0.0011123467\n900 3.1404815428    0.0011111108\n901 3.1427025312    0.0011098776\n902 3.1404840065    0.0011086471\n903 3.1427000730    0.0011074194\n904 3.1404864592    0.0011061944\n905 3.1426976256    0.0011049720\n906 3.1404889012    0.0011037524\n907 3.1426951891    0.0011025355\n908 3.1404913323    0.0011013213\n909 3.1426927633    0.0011001097\n910 3.1404937528    0.0010989008\n911 3.1426903481    0.0010976945\n912 3.1404961627    0.0010964909\n913 3.1426879435    0.0010952899\n914 3.1404985620    0.0010940916\n915 3.1426855494    0.0010928958\n916 3.1405009509    0.0010917027\n917 3.1426831658    0.0010905122\n918 3.1405033293    0.0010893243\n919 3.1426807925    0.0010881390\n920 3.1405056974    0.0010869562\n921 3.1426784296    0.0010857760\n922 3.1405080552    0.0010845984\n923 3.1426760769    0.0010834233\n924 3.1405104028    0.0010822508\n925 3.1426737344    0.0010810808\n926 3.1405127403    0.0010799133\n927 3.1426714019    0.0010787483\n928 3.1405150677    0.0010775859\n929 3.1426690795    0.0010764260\n930 3.1405173851    0.0010752685\n931 3.1426667671    0.0010741135\n932 3.1405196925    0.0010729611\n933 3.1426644646    0.0010718111\n934 3.1405219901    0.0010706635\n935 3.1426621720    0.0010695184\n936 3.1405242778    0.0010683758\n937 3.1426598891    0.0010672356\n938 3.1405265558    0.0010660978\n939 3.1426576160    0.0010649624\n940 3.1405288241    0.0010638295\n941 3.1426553525    0.0010626990\n942 3.1405310828    0.0010615708\n943 3.1426530987    0.0010604451\n944 3.1405333319    0.0010593217\n945 3.1426508544    0.0010582008\n946 3.1405355714    0.0010570822\n947 3.1426486195    0.0010559659\n948 3.1405378016    0.0010548520\n949 3.1426463941    0.0010537405\n950 3.1405400223    0.0010526313\n951 3.1426441780    0.0010515244\n952 3.1405422337    0.0010504199\n953 3.1426419712    0.0010493177\n954 3.1405444358    0.0010482177\n955 3.1426397737    0.0010471201\n956 3.1405466288    0.0010460248\n957 3.1426375854    0.0010449318\n958 3.1405488125    0.0010438411\n959 3.1426354062    0.0010427526\n960 3.1405509872    0.0010416664\n961 3.1426332360    0.0010405824\n962 3.1405531528    0.0010395008\n963 3.1426310749    0.0010384213\n964 3.1405553095    0.0010373441\n965 3.1426289227    0.0010362692\n966 3.1405574572    0.0010351964\n967 3.1426267795    0.0010341259\n968 3.1405595960    0.0010330576\n969 3.1426246451    0.0010319915\n970 3.1405617260    0.0010309276\n971 3.1426225194    0.0010298658\n972 3.1405638473    0.0010288063\n973 3.1426204025    0.0010277490\n974 3.1405659598    0.0010266938\n975 3.1426182943    0.0010256408\n976 3.1405680637    0.0010245899\n977 3.1426161948    0.0010235412\n978 3.1405701590    0.0010224946\n979 3.1426141038    0.0010214502\n980 3.1405722457    0.0010204079\n981 3.1426120213    0.0010193677\n982 3.1405743239    0.0010183297\n983 3.1426099473    0.0010172937\n984 3.1405763937    0.0010162599\n985 3.1426078818    0.0010152282\n986 3.1405784551    0.0010141985\n987 3.1426058246    0.0010131710\n988 3.1405805081    0.0010121455\n989 3.1426037757    0.0010111221\n990 3.1405825528    0.0010101008\n991 3.1426017351    0.0010090815\n992 3.1405845893    0.0010080643\n993 3.1425997027    0.0010070491\n994 3.1405866176    0.0010060360\n995 3.1425976785    0.0010050249\n996 3.1405886378    0.0010040158\n997 3.1425956624    0.0010030088\n998 3.1405906498    0.0010020038\n999 3.1425936543    0.0010010008\n1000    3.1405926538    0.0009999997\n\n\nWe need 1000 terms in order to get the error below \\(10^{-3}\\)\n\n\nO.2.8 (23) Considering the following code snippet: (8%)\ndef eggs(somelist):\n    somelist[-1].append('Bob')\n    print(somelist)\n\nspam = [3,5,6,['Hello', 'Alice']]\nspam2 = spam  # Fix me here\neggs(spam2)\nprint(spam)\n\nWhat will be printed out when executing the code? Please also explain why you get such a result.\nFrom (a), you see that the global variable spam has been modified. Fix the above code annotated with “Fix me here” if you do not want it to be changed.\n\n\ndef eggs(somelist):\n    somelist[-1].append('Bob')\n    print(somelist)\n\nspam = [3,5,6,['Hello', 'Alice']]\nspam2 = spam\neggs(spam2)\nprint(spam)\n\n[3, 5, 6, ['Hello', 'Alice', 'Bob']]\n[3, 5, 6, ['Hello', 'Alice', 'Bob']]\n\n\n\nThe print out message is\n\n[3, 5, 6, ['Hello', 'Alice', 'Bob']]\n[3, 5, 6, ['Hello', 'Alice', 'Bob']]\nbecause list is mutable object, so it will be modified inside the eggs() function.\n\nIf you want to avoid the modification, you can use deepcopy() from the copy module as follows:\n\n\nimport copy\ndef eggs(somelist):\n    somelist[-1].append('Bob')\n    print(somelist)\n\nspam = [3,5,6,['Hello', 'Alice']]\nspam2 = copy.deepcopy(spam)\neggs(spam2)\nprint(spam)\n\n[3, 5, 6, ['Hello', 'Alice', 'Bob']]\n[3, 5, 6, ['Hello', 'Alice']]"
  },
  {
    "objectID": "Quiz2_sol.html#a.-single-choice-questions-4-48",
    "href": "Quiz2_sol.html#a.-single-choice-questions-4-48",
    "title": "Appendix P — Quiz 2",
    "section": "P.1 A. Single Choice Questions (4%, 48%)",
    "text": "P.1 A. Single Choice Questions (4%, 48%)\n\nP.1.1 (1) Which of the following statements is False?\n\nThe super() function is a specific function that enables calling a method from the parent class.\nThe cls parameter functions similarly to self, but instead of referring to an object, it refers to the class of an object.\nIn the Python class, the self parameter is required in the definition of every method, and it must come first before any other parameters.\nIf we directly access an attribute starting with __, an error will occur.\n\n\nAns: (C) In Python, the self parameter is not required in the definition of every method. Specifically, it is not used in @staticmethods or @classmethods.\n\n\n\nP.1.2 (2) When we directly evaluate (like when you type the object’s name and hit shift+enter) an object in the Jupyter Notebook, which special method will be called first?\n\n__del__\n__repr__\n__str__\n__init__\n\n\nAns: (B)\n\n\n\nP.1.3 (3) Which of the following statements is False?\n\nThe Float class in SymPy can be used to represent a floating-point number, but the precision of the results is limited.\nUsing the evalf() method in SymPy makes it possible to evaluate an expression and obtain the result as a floating-point number.\nSymPy is distinct from numerical libraries because it is created to perform algebraic manipulations symbolically, which allows us to obtain exact solutions to mathematical problems.\nIn SymPy, certain operations are not executed instantaneously. Instead, they generate an unevaluated object, which can be later evaluated by invoking the doit() method.\n\n\nAns: (A) The Float class in SymPy indeed allows us to represent floating-point numbers, but unlike standard floating-point numbers in Python (which have a fixed precision), the precision of a Float in SymPy can be arbitrarily high!\n\n\n\nP.1.4 (4) By default, what will be printed out when we execute the following code snippet?\nimport sympy as sp\nx,y = sp.symbols('x,y') # you can create multiple symbols at once using multiple assignment\n(x + 2)*(x + 1)\n\n\\((x+1)(x+2)\\)\n\\(x^2+3x+2\\)\n\\(1+2x+x^2\\)\n\\((x+2)(x+1)\\)\n\n\nAns: (A)\n\n\n\nP.1.5 (5) Which of the following statements is True?\n\nThe main difference between the array methods reshape() and resize() is that the resize() returns a view of the original array while reshape() returns a deep copy of the original array.\nThe main difference between the array methods ravel() and flatten() is that the ravel() returns a view of the original array while flatten() returns a deep copy of the original array.\nIn NumPy, the speed of for loop will usually be faster than vectorized operation when performing the element-wise operation.\nIn NumPy, to perform an element-wise operation between two arrays, the two arrays must have the same shape.\n\n\nAns: (B).\n\n\nthe reshape() function returns a new array that has the same data but a different shape, and it usually returns a view, not a deep copy. The resize() function changes the shape and size of array in-place.\nvectorized operations are usually much faster than for loops due to the fact that vectorized operations take advantage of low-level optimizations and parallelism, which are not available when manually looping over the elements of the array.\nFor element-wise operations between two arrays in NumPy, they do not need to be the exact same shape due to broadcasting rules. Broadcasting allows operations to be performed on arrays of different sizes and/or dimensions, given certain conditions are met.\n\n\n\nP.1.6 (6) Which of the following statement is False?\n\nThe array attribute size is the product of the shape tuple’s values. For instance, an array with three rows of two elements each will have a size equal to 6.\nWhen we call the linspace() function to create an array, the endpoint will be included in the array by default.\nThe main difference between the built-in function random.randint() and the np.random.randint() is that the former will exclude the endpoint while the latter will not.\nWhen we use the reduction function on a 2D array and specify axis=0, the calculation will be performed on all the row values within each column.\n\n\nAns: (C) The main difference between the built in function random.randint() and the np.random.randint() is that the former will include the endpoint while the latter will not.\n\n\n\nP.1.7 (7) Which of the following is not a correct function/method mapping between the functional interface and the OOP interface in matplotlib?\n\nplt.xlabel() -&gt; ax.set_xlabel()\nplt.ylim()  -&gt;  ax.set_ylim()\nplt.legend()  -&gt;  ax.set_legend()\nplt.title()  -&gt;  ax.set_title()\n\n\nAns: (C)\n\n\n\nP.1.8 (8) Which of the following statement is True?\n\nTo define a new class in Python we always need to implement the constructor __init__ and the destructor __del__ method.\nThe inheritance describes the “has a” relationship between two classes.\nA static method is a special method that can access the attributes or methods of the class (using cls) or its objects (using self).\nOperator overloading, which enables operators to exhibit varying behavior depending on the object types they interact with, is also an aspect of polymorphism.\n\n\nAns: (D). (A) Usually, we do not have to define __del__. (B) Should be composition. (C) static method can not access these two kinds of method or attribute.\n\n\n\nP.1.9 (9) In the command plt.plot(x, y, '-bo'), what does the format string '-bo' mean?\n\nDraw a solid line with black color and circle marker.\nDraw a dotted line with black color and circle marker.\nDraw a dotted line with blue color and square marker.\nDraw a solid line with blue color and circle marker.\n\n\nAns: (D)\n\n\n\nP.1.10 (10) Which of the following statements is False?\n\nIn SymPy, the terms of an expression are arranged according to the powers of x, in descending order, starting from the highest power to the lowest.\nSymPy will not perform any simplification or expansion for an expression unless explicitly requested to do so.\nBoth solve() and nroots() can be used to find the roots of an equation, but the former will return the roots as numerical values while the latter will return the roots as symbolic expressions.\nThe high-order term O(x^n) after the series expansion can be eliminated by using the removeO() method.\n\n\nAns: (C) nroots() does not return the roots as symbolic expressions, but as numerical approximations.\n\n\n\nP.1.11 (11) Which of the following statement is False?\n\nThe plt.text() function allows us to position text at a specific x/y coordinate, while the plt.annotate() function provides the ability to create text along with an arrow.\nIn the plt.scatter() function, we can use the alpha keyword to adjust the transparency level of each data point.\nAlthough a significant number of plt functions (functional interface) have corresponding ax methods (OOP interface) with identical names, this rule does not hold universally for all commands.\nSpines represent the lines that link the tick marks on the axes and delineate the data area. Typically, they are located at the center of the figure by default.\n\n\nAns: (D) They are at the border of the figure by default.\n\n\n\nP.1.12 (12) If we would like to calculate c = a + b, which of the following arrays a and b will satisfy the broadcasting rules?\n\na = np.array([1, 2, 3]); b = np.array([4, 5, 6, 7])\na = np.array([[1, 2, 3], [4, 5, 6]]); b = np.array([[1, 2], [3, 4]])\na = np.array([[1, 2, 3], [4, 5, 6]]); b = np.array([7, 8])\na = np.array([[1, 2, 3]]); b = np.array([[1], [2]])\n\n\nAns: (D)\n\n\nWhen the number of dimensions between two arrays differs, the array with fewer dimensions is padded with ones on its leading (left) side to match the number of dimensions of the other array.\nIf the shape of the two arrays doesn’t match in any dimension, the array with a shape of 1 in that dimension is expanded to match the shape of the other array.\nIf the sizes of the arrays conflict in any dimension and neither is equal to 1, an error is raised."
  },
  {
    "objectID": "Quiz2_sol.html#b.-short-answer-and-coding-questions",
    "href": "Quiz2_sol.html#b.-short-answer-and-coding-questions",
    "title": "Appendix P — Quiz 2",
    "section": "P.2 B. Short-answer and coding questions",
    "text": "P.2 B. Short-answer and coding questions\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sympy as sp\nplt.style.use('seaborn-whitegrid')\n\nC:\\Users\\adm\\AppData\\Local\\Temp\\ipykernel_29012\\3720340587.py:5: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as 'seaborn-v0_8-&lt;style&gt;'. Alternatively, directly use the seaborn API instead.\n  plt.style.use('seaborn-whitegrid')\n\n\n\nP.2.1 (13) Considering the following Fraction class that has two attributes, num and den try to complete the following tasks: (8%)\n\nCreate a dunder method for the class so that two objects from the class can be added together.\nWhen the user prints out the Fraction object, show the object in the form of a rational number and floating number.\nInherit the Fraction class and create a new class called integer that can be added to the Fraction class and when printing out the integer object, do not show the denominator part.\n\n\nclass Fraction():\n    def __init__(self, numerator, denominator):\n        self.set_num_den(numerator, denominator)\n\n    def set_num_den(self, numerator, denominator):\n        self.__num = numerator\n        self.__den = denominator\n\n    def get_num_den(self):\n        return self.__num, self.__den\n    \n    # dunder method\n    def __add__(self, otherfrac):\n        newnum = self.__num * otherfrac.__den + self.__den* otherfrac.__num\n        newden = self.__den * otherfrac.__den\n        return Fraction(newnum, newden)\n    \n    def __str__(self):\n        return f\"{self.__num}/{self.__den}, {self.__num/self.__den}\"\n    \nclass integer(Fraction):\n    def __init__(self, numerator):\n        super().__init__(numerator, 1)\n        \n    def __str__(self):\n        num, den = super().get_num_den() #getter\n        return f\"{num}\"\n\n\n# Test the class\nx = Fraction(1,3)\ny = integer(2)\nprint(y)\nz = x + y\nprint(z)\nprint(z.get_num_den())\n\n2\n7/3, 2.3333333333333335\n(7, 3)\n\n\n\n\nP.2.2 (14) Suppose we are developing a chess game and the chess game provides a special checkerboard as follows: (8%)\n\n# The checkerboard\n\nWe decide to use 1 to represent the white square and 0 to represent the black square. Write a program to create two 2D arrays to represent the checkerboards. Note you should not directly hardcode the above arrays. You should use NumPy methods to create the arrays. After you have finished the exercise, you can print out the checkerboard using the following code cell. Finally, calculate the number of pixels of the back area and the white area, respectively, using NumPy.\n\ncheckerboard = np.ones((8, 8))\ncheckerboard[::3, 1::3] = 0\ncheckerboard[1::3, ::3] = 0\ncheckerboard\n\narray([[1., 0., 1., 1., 0., 1., 1., 0.],\n       [0., 1., 1., 0., 1., 1., 0., 1.],\n       [1., 1., 1., 1., 1., 1., 1., 1.],\n       [1., 0., 1., 1., 0., 1., 1., 0.],\n       [0., 1., 1., 0., 1., 1., 0., 1.],\n       [1., 1., 1., 1., 1., 1., 1., 1.],\n       [1., 0., 1., 1., 0., 1., 1., 0.],\n       [0., 1., 1., 0., 1., 1., 0., 1.]])\n\n\n\nplt.imshow(checkerboard, cmap='gray');\n\n\n\n\n\nwhite_area = np.sum(checkerboard)\nblack_area = 8*8 - np.sum(checkerboard)\nint(white_area), int(black_area)\n\n(46, 18)\n\n\n\nAns: The white area contains 46 pixels while the black area occupies 18 pixels.\n\n\n\nP.2.3 (15) The definite integral represents the area under the curve of the graph of \\(y=f(x)\\) on the interval \\([a,b]\\). (10%)\n\\[\n\\int_a^b f(x) \\, dx = \\text{area under the curve } y = f(x) \\text{ on } [a,b]\n\\]\nNote that the area above the \\(x\\)-axis is considered positive, while the area below the \\(x\\)-axis counts as negative area. Try to visualize the integral:\n\\[\n\\int_{\\pi/2}^{3\\pi/2} \\left( \\sin(0.2 x) + \\sin(2x)\\right) dx\n\\] (8%).\nYou need to draw the curve of \\(y = \\sin(0.2 x) + \\sin(2x)\\) and use blue and red color to fill the positive and negative area respectively. Finally, calculate the area of the integral from \\(\\pi/2\\) to \\(3\\pi/2\\) using SymPy. Your result should be a floating number.\n\ndef f(x):\n    return np.sin(0.2*x) + np.sin(2*x)\n\nx = np.linspace(0,2*np.pi,100)\ny = f(x)\nplt.plot(x,y)\n\nX = np.linspace(np.pi/2,3*np.pi/2,100)\nY = f(X)\nplt.fill_between(X, 0, Y, Y &gt; 0, color='blue', alpha=.25)\nplt.fill_between(X, 0, Y, Y &lt; 0, color='red',  alpha=.25)\n\nplt.xticks([np.pi/2,3*np.pi/2],['$\\pi/2$','$3\\pi/2$'])\nplt.xlim([0,2*np.pi]); plt.ylim([-2,3]);\n\n\n\n\n\nx = sp.Symbol('x')\nf = sp.sin(0.2*x) + sp.sin(2*x)\n# sp.Integral(sp.sin(x), (x, 0, sp.pi / 2)).doit()\nsp.integrate(f, (x, sp.pi/2, sp.pi*3/2)).evalf()\n\n\\(\\displaystyle 1.8163563200134\\)\n\n\n\n\nP.2.4 (16) In this problem, we will compare two approaches to approximate the \\(\\arctan(1)\\) using the sum of infinite series. (8%)\n\nFisrtly, write a program that computes the value of \\(\\pi\\) from the following infinite series \\(\\arctan(x) = \\sum_0^{\\infty}(-1)^n\\frac{x^{2n+1}}{(2n+1)}\\) using NumPy by substitute x=1.\nSecondly, expand the \\(\\arctan(x)\\) using Taylor serise at \\(x=0\\) using SymPy.\nFinally, set the number of terms for both approximations to 100 and make sure they agree with each other. (8%)\n\nHint: You may find lambdify() useful to convert a symbolic expression to a function that can be evaluated numerically.\n\nn = 100\nk = np.arange(0, n)\nt1 = np.sum((-1)**(k) / (2*k + 1))\n\n\ntaylor = sp.series(sp.atan(x), x, 0, 200).removeO()\nevaltaylor = sp.utilities.lambdify(x, taylor, modules=['numpy'])\nt2 = evaltaylor(1)\n\n\nnp.isclose(t1, t2)\n\nTrue\n\n\n\n\nP.2.5 (17) In this problem, we will compare two approaches to calculate the roots of a given function \\(x^3+3x^2+x-1\\). (10%)\n\nFirst, generate evenly spaced numbers between \\(-3\\) and \\(3\\).\nSecondly, explain the functionality of sign(), diff() and nonzero() in NumPy.\nThirdly, use the above function to find where the function crosses the x-axis (the roots of the function) by substitution.\nFinally, use SymPy to find the roots of the function (set the number of digits of the decimal part to 3) and make sure that they agree with each other.\n\nHint: You may need to adjust the number of evenly spaced points in the first step to get the same result.\n\nnp.sign(): This function returns an element-wise indication of the sign of a number. It returns -1 for negative numbers, 0 for zero, and 1 for positive numbers.\nnp.diff(): This function calculates the n-th discrete difference along the given axis. The first difference is given by out[n] = a[n+1] - a[n] along the given axis.\nnp.nonzero(): This function returns the indices of the elements that are non-zero.\n\n\nN = 2000\nx = np.linspace(-3, 3, N)\ny = x**3 + 3*x**2+ x -1\nidx = np.nonzero(np.diff(np.sign(y)))\nroots1 = x[idx]\nroots1\n\narray([-2.41437072, -1.00010001,  0.41417071])\n\n\n\nx = sp.Symbol('x')\nexpr = x**3 + 3*x**2+ x -1\nroots2 = sp.nroots(expr, n=3)\nroots2\n\n[-2.41, -1.00, 0.414]\n\n\n\nnp.isclose(roots1, np.array(roots2, dtype=np.float32), atol=1e-2)\n\narray([ True,  True,  True])\n\n\n\n\nP.2.6 (18) Try to plot \\(cot(x)\\) using plot() function and set the limit of x between \\([-2\\pi, 2\\pi]\\). In addition, you need to move the spline to the center, add the title and change the ticks of the figure so that the plot looks as follows: (8%)\n\n# The plot\ndef cotan(x):\n    return np.cos(x)/np.sin(x)\n\nx = np.linspace(-2 * np.pi, 2 * np.pi, 1000)\ny = cotan(x)\n\ny[np.isclose(x, np.pi, rtol=1e-02)] = np.nan\ny[np.isclose(x, 0, atol=1e-02)] = np.nan\ny[np.isclose(x, -np.pi, rtol=1e-02)] = np.nan\n\nplt.xlabel(\"x\")\nplt.ylabel(\"$cot(x)$\")\nplt.xlim(-2 * np.pi, 2 * np.pi)\nplt.ylim(-5, 5)\nplt.title(\"$y = cot(x)$\")\nplt.plot(x, y)\n\nradian_multiples = [-2, -3/2, -1, -1/2, 0, 1/2, 1, 3/2, 2]\nradians = [n * np.pi for n in radian_multiples]\nradian_labels = ['$-2\\pi$', '$-3\\pi/2$', '$\\pi$', '$-\\pi/2$', '0', '$\\pi/2$', '$\\pi$', '$3\\pi/2$', '$2\\pi$']\n\nplt.xticks(radians, radian_labels);\n\nax = plt.gca()\nax.spines[['top', 'right']].set_visible(False)\nax.spines['bottom'].set_position(('data',0))\nax.spines['left'].set_position(('data',0))"
  }
]